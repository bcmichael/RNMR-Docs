<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Full Command Descriptions - RNMR Documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <link href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Full Command Descriptions";
    var mkdocs_page_input_path = "command\\full_command.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> RNMR Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="tocbase current">
    
    
      


  <li class="navtree toctree-l1 inactive">
    <a class="" href="../..">Index</a>
  </li>
    
      


  <li class="navtree toctree-l1 inactive">
    <a class="" href="../../getting_started/">Getting Started</a>
  </li>
    
      


  <li class="navtree toctree-l1 inactive">
    <a class="" href="../../running_routine_experiments/">Running Routine Experiments</a>
  </li>
    
      


  <li class="navtree toctree-l1 inactive">
    <a class="" href="../../macros/">Macros</a>
  </li>
    
      


  <li class="navtree toctree-l1 inactive">
    <a class="" href="../../pulse_programming/">Pulse Programming</a>
  </li>
    
      
  <li class="navtree toctree-l1 label">
    <p class="caption">Commands</p>
  </li>


  

  
    <li class="navtree toctree-l1 group">
      <ul class="navtree subnav-l1 current">
          


  <li class="navtree toctree-l2 inactive">
    <a class="" href="../syntax/">Command Syntax</a>
  </li>
        
          


  <li class="navtree toctree-l2 inactive">
    <a class="" href="../command_summary/">Command Summary</a>
  </li>
        
          


  
    
    <li class="navtree toctree-l2 page current">
      <a class="current" href="./">
        Full Command Descriptions
          <span class="toctree-expand"></span>
      </a>
    </li>
    
      



  <li class="toctree-l2 current">
    <ul class="subnav-l2 current">
    
      
          

  <li class="toctree-l3 current with-children">
    <a href="#a">
      A
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3 current">
    <ul class="subnav-l3 current">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#abort">ABORT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#addv">ADDV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ai">AI</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ak">AK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#allb">ALLB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#allcpy">ALLCPY</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#amd">AMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#apnfil">APNFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#apnlst">APNLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#apnmac">APNMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#arv">ARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#asig">ASIG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#askyn">ASKYN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#autoz">AUTOZ</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#b">
      B
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#bc">BC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#bf">BF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#bincp">BINCP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#brkdo">BRKDO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#bruk">BRUK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#buf">BUF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#bufa">BUFA</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#c">
      C
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#calc">CALC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#calci">CALCI</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#calib">CALIB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#case">CASE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cat">CAT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catarv">CATARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catgbl">CATGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catlcl">CATLCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catlst">CATLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catmac">CATMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catnuc">CATNUC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catpps">CATPPS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#catsym">CATSYM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cattbl">CATTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cd">CD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#chn">CHN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clsarv">CLSARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clsexp">CLSEXP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clsimp">CLSIMP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clsplt">CLSPLT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clsrd">CLSRD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#clswrt">CLSWRT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cmul">CMUL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cmulv">CMULV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cnd">CND</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cnvfl">CNVFL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#color">COLOR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#conjg">CONJG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#conlim">CONLIM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#conmd">CONMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cossq">COSSQ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cpxv">CPXV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cpy">CPY</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cpymac">CPYMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crs">CRS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crsa">CRSA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crtarv">CRTARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crtfil">CRTFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crtlst">CRTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crtmac">CRTMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#crttbl">CRTTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cvtmd">CVTMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cvtsz">CVTSZ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#cvtunit">CVTUNIT</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#d">
      D
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#d_1">D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#date">DATE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dbsz">DBSZ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dcdb">DCDB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dcdbp">DCDBP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dcdrec">DCDREC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dcl">DCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#depake">DEPAKE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#df">DF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dflgbl">DFLGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfllcl">DFLLCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dflt">DFLT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfltbl">DFLTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfngbl">DFNGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfnlcl">DFNLCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfnlst">DFNLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfnmac">DFNMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfnsym">DFNSYM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfntbl">DFNTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dfnpps">DFNPPS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dg">DG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dirb">DIRB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dl">DL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dltfil">DLTFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dltlst">DLTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dltmac">DLTMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dlttbl">DLTTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dly">DLY</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#do">DO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#dw">DW</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#e">
      E
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ecdb">ECDB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ecdbp">ECDBP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ecdrec">ECDREC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#echo">ECHO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#edtfil">EDTFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#edtlst">EDTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#edtmac">EDTMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#elstst">ELSTST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#em">EM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#enddo">ENDDO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#endsel">ENDSEL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#endtst">ENDTST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ex">EX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#exit">EXIT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#exp">EXP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#exp1d">EXP1D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#exp2d">EXP2D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#exp3d">EXP3D</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#f">
      F
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#f_1">F</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#flag">FLAG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#flf">FLF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#fmx">FMX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#fmxex">FMXEX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#fold">FOLD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#fsys">FSYS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ft">FT</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#g">
      G
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ga">GA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gain">GAIN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gainl">GAINL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gav">GAV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gb">GB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gblarg">GBLARG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gbldl">GBLDL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gencs">GENCS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#genpwdr">GENPWDR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gm">GM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gmv">GMV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#go">GO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gosub">GOSUB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#goto">GOTO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gotst">GOTST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gref">GREF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#grefa">GREFA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#gs">GS</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#h">
      H
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#hilb">HILB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#hilbz">HILBZ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#htr">HTR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#htrsts">HTRSTS</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#i">
      I
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ibox">IBOX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#idn">IDN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#idna">IDNA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ifcnd">IFCND</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ifeq">IFEQ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ifgbl">IFGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#iflcl">IFLCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ifmac">IFMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ifrec">IFREC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ift">IFT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#imp">IMP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#imp1d">IMP1D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#imp2d">IMP2D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#imp3d">IMP3D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#inflvl">INFLVL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#intg">INTG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#intrg">INTRG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#inslst">INSLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ixval">IXVAL</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#k">
      K
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#keyarg">KEYARG</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#l">
      L
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lb">LB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lck">LCK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lckctl">LCKCTL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lckmtr">LCKMTR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lckval">LCKVAL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lclarg">LCLARG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lcldl">LCLDL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#li">LI</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lim">LIM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lima">LIMA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#limb">LIMB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#log">LOG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#loop">LOOP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lp">LP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpa">LPA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpb">LPB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpc">LPC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpca">LPCA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpcp">LPCP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpdev">LPDEV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpf">LPF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpfil">LPFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpk">LPK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lpk2d">LPK2D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ls">LS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lstdp">LSTDP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lstfil">LSTFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lstlst">LSTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lstmac">LSTMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#lw">LW</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#m">
      M
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#macarg">MACARG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mag">MAG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mapn">MAPN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mascmd">MASCMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#maxv">MAXV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mcpy">MCPY</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#md">MD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mdl">MDL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#me">ME</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#medbf">MEDBF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mexit">MEXIT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#minv">MINV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ml">ML</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mnmx">MNMX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mo">MO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mov">MOV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#movv">MOVV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mrgfs">MRGFS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mrn">MRN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#msg">MSG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#mulv">MULV</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#n">
      N
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#na">NA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nablk">NABLK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#namd">NAMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nchn">NCHN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ncon">NCON</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ndec">NDEC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ndly">NDLY</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ndsp">NDSP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#neg">NEG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ng">NG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#noise">NOISE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nop">NOP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#norm">NORM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nuc">NUC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nucd">NUCD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nucdl">NUCDL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nwait">NWAIT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#nxtdo">NXTDO</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#o">
      O
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#off">OFF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#offa">OFFA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#onerr">ONERR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnarv">OPNARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnexp">OPNEXP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnimp">OPNIMP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnplt">OPNPLT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnrd">OPNRD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#opnwrt">OPNWRT</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#p">
      P
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#p_1">P</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#parb">PARB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pc">PC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pen">PEN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pgsize">PGSIZE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ph">PH</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pidl">PIDL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pldev">PLDEV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#plfil">PLFIL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#plot">PLOT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#plotc">PLOTC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pls">PLS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#plsize">PLSIZE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#polar">POLAR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#poplst">POPLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#posl">POSL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pp">PP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ppex">PPEX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ppflg">PPFLG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ppmd">PPMD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#prglst">PRGLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#prgtbl">PRGTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#prof">PROF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#profb">PROFB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#prog">PROG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#proj">PROJ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#projb">PROJB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#prtarg">PRTARG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ps">PS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pshlst">PSHLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#psubv">PSUBV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#psx">PSX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#psxex">PSXEX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ptra">PTRA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ptrb">PTRB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pwr">PWR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pwrl">PWRL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pwx">PWX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#pwxex">PWXEX</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#q">
      Q
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#qc">QC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#quit">QUIT</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#r">
      R
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rcvmix">RCVMIX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rcvoff">RCVOFF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rd">RD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdarv">RDARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdlst">RDLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdpps">RDPPS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdppsnam">RDPPSNAM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdstr">RDSTR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdtbl">RDTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rdwrt">RDWRT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remgbl">REMGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remlcl">REMLCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remlst">REMLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remmac">REMMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rempps">REMPPS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remsym">REMSYM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#remtbl">REMTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#renmac">RENMAC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rgpib">RGPIB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rms">RMS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rot">ROT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rotp">ROTP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rppsb">RPPSB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rptdo">RPTDO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rrkc">RRKC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rsb">RSB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rstbuf">RSTBUF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rstgbl">RSTGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rsthtr">RSTHTR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rstlck">RSTLCK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rstlst">RSTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rstshm">RSTSHM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rsttbl">RSTTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rtnarg">RTNARG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rwdrd">RWDRD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#rwdwrt">RWDWRT</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#s">
      S
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sa">SA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sav">SAV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savarv">SAVARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savbuf">SAVBUF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savgbl">SAVGBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savhtr">SAVHTR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savlck">SAVLCK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savlog">SAVLOG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savlst">SAVLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savshm">SAVSHM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#savtbl">SAVTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sb">SB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sc">SC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sel">SEL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#set">SET</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#setidn">SETIDN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#setv">SETV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#setvp">SETVP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sg">SG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#shell">SHELL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#shft">SHFT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#shftp">SHFTP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#shm">SHM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#shmctl">SHMCTL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#show">SHOW</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sineb">SINEB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#size">SIZE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sizeb">SIZEB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sizlst">SIZLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#siztbl">SIZTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sp">SP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#spln">SPLN</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sqz">SQZ</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sref">SREF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#srefa">SREFA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#ss">SS</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#stk">STK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#stkoff">STKOFF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#str">STR</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#subv">SUBV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#sw">SW</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#swapv">SWAPV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#swl">SWL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#swp">SWP</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#t">
      T
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#talarm">TALARM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tcl">TCL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#th">TH</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tilt">TILT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#title">TITLE</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#titlea">TITLEA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tm">TM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tp">TP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tppi">TPPI</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tset">TSET</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tst">TST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#tval">TVAL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#twist">TWIST</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#u">
      U
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#unecho">UNECHO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#unfold">UNFOLD</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#unit">UNIT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#updarv">UPDARV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#user">USER</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#v">
      V
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#val">VAL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#view">VIEW</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#w">
      W
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wait">WAIT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wavb">WAVB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wavv">WAVV</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wgpib">WGPIB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wndlim">WNDLIM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wndlima">WNDLIMA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wpk">WPK</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wpk2d">WPK2D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wppsb">WPPSB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrf">WRF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrfex">WRFEX</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrkc">WRKC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrri">WRRI</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrt">WRT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrtlst">WRTLST</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wrttbl">WRTTBL</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wsb">WSB</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wtrm">WTRM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wtset">WTSET</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wttim">WTTIM</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wwash">WWASH</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wwf">WWF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#wwfex">WWFEX</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#x">
      X
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#xt">XT</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#xtp">XTP</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#xval">XVAL</a>
        </li>
    
    </ul>
  </li>

      
    
      
          

  <li class="toctree-l3">
    <a href="#z">
      Z
      <span class="toctree-expand"></span>
    </a>
  </li>



  <li class="toctree-l3">
    <ul class="subnav-l3 toc-hidden">
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zer">ZER</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zera">ZERA</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zf">ZF</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zg">ZG</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zo">ZO</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zo2d">ZO2D</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zo2dc">ZO2DC</a>
        </li>
    
      
        <li class="toctree-l4">
          <a class="toctree-l5" href="#zoa">ZOA</a>
        </li>
    
    </ul>
  </li>

      
    
    </ul>
  </li>


  
        
      </ul>
    </li>
    
  </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">RNMR Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Commands &raquo;</li>
        
      
    
    <li>Full Command Descriptions</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/bcmichael/RNMR-Docs/edit/master/docs/command/full_command.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="full_command_descriptions">Full Command Descriptions</h1>
<h2 id="a">A</h2>
<hr />
<h3 id="abort">ABORT</h3>
<p>Abort acquisition</p>
<p>Category: Acquisition</p>
<p>Format: <code>ABORT</code></p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
Aborts acquisition. If acquisition is not currently active, an error message will result. <code>ABORT</code> is equivalent to
<code>QUIT</code>.  Acquisition will be aborted abruptly i.e. RNMR will not wait for next shot to be completed.</p>
<h3 id="addv">ADDV</h3>
<p>Add buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>ADDV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>ADDV</code> adds the contents of <a href="../syntax/#buffers">processing buffers</a> src and dst and stores the result in dst.</p>
<pre><code>    DST = DST + SRC
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="ai">AI</h3>
<p>Scale to absolute intensity</p>
<p>Category: Display Control</p>
<p>Format: <code>AI</code> sfa</p>
<p>Defaults: current</p>
<p>Description:
<code>AI</code> scales data in the visible processing buffer to make the scale factor equal to a specified absolute scale factor,
sfa. If sfa is omitted RNMR will not prompt for it and will use the current absolute scale factor (as set and displayed
by <code>AK</code>). The scale factor must be greater than 0.0. The absolute scale factor (as set and displayed by <code>AK</code>) will also
be updated to the value of sfa.</p>
<h3 id="ak">AK</h3>
<p>Set absolute scale factor</p>
<p>Category: Display Control</p>
<p>Format: <code>AK</code> sfa</p>
<p>Defaults: current</p>
<p>Description:
<code>AK</code> sets the global absolute scale factor. If the absolute scale factor sfa is omitted RNMR will prompt for it with the
current global scale factor as a default. The global scale factor must be greater than 0.0. If a scale factor of 0 is
passed to <code>AK</code> the current scale factor of the visible processing buffer will be used.</p>
<h3 id="allb">ALLB</h3>
<p>Allocate a blocked record</p>
<p>Category: Blocked Records</p>
<p>Format: <code>ALLB</code> rec ndim size(1)...size(ndim) ndimx nsega</p>
<p>Defaults: wrec 2 64 ... 64 <ndim> 1</p>
<p>Description:
<code>ALLB</code> allocates a <a href="../syntax/#blocked_records">blocked record</a>. By allocating multidimensional records in advance, the
user is assured that there will be adequate disk space to hold all the data to be acquired.</p>
<p>The parameter rec is the <a href="../syntax/#records">record number</a> to be allocated. If 0 is entered for this parameter or if no
record is specified RNMR will not prompt for it and will use the write record pointer (as displayed and set by <code>PTRA</code>).
If the specified record is already in use RNMR will use the next available record. If RNMR selects the record for either
of the above reasons the record number will be printed as an informational message after allocation is complete.</p>
<p>The parameter ndim specifies the number of dimensions and must be between 1 and 4 inclusive. If ndim is not specified
RNMR will prompt for it with 2 as a default. <code>ALLB</code> accepts ndim arguments to set the size of the allocated record along
each dimension. If any of these sizes are omitted RNMR will prompt for them with 64 as a default. The sizes must be
positive integers.</p>
<p>The next parameter, <a href="../syntax/#ndimx">ndimx</a>, is the number of dimensions of the blocked record that will be
simultaneously accessible. If ndimx is omitted RNMR will prompt for it with ndim as a default. The final parameter,
<a href="../syntax/#nseg">nsega</a>, is the number of segments to allocate in the records. If nsega is not specified RNMR will not
prompt for it and will allocate 1 segment.</p>
<p>In order for a blocked record to be successfully allocated there must be enough space in the archive (as displayed by
<code>SP</code>). The other parameters of the blocked record can be set using <code>PARB</code> or <code>SET REC</code>.</p>
<h3 id="allcpy">ALLCPY</h3>
<p>Allocate a copy of a blocked record</p>
<p>Category: Blocked Records</p>
<p>Format: <code>ALLCPY</code> srcrec dstrec isize(1) ... isize(ndim) ndimx nsega</p>
<p>Defaults: rrec wrec insize(1)...insize(ndim) <ndim> 1</p>
<p>Description:
<code>ALLCPY</code> allocates a <a href="../syntax/#blocked_records">blocked record</a> dstrec copying the parameters but not the data from
blocked record srcrec. To copy both parameters and data, use the command <code>CPY</code>. The destination record may be given new
sizes, <a href="../syntax/#ndimx">number of accessible dimensions</a>, and <a href="../syntax/#nseg">number of segments</a> in place of those
used in the source record.</p>
<p>If no source <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record
pointer (as displayed and set by <code>PTRA</code>) as a default. If no destination record is specified RNMR will not prompt for
it and will use the write record pointer (as displayed and set by <code>PTRA</code>). If the specified destination record is
already in use RNMR will use the next available record. If RNMR selects the destination record for either of the above
reasons the record number will be printed as an informational message after allocation is complete.</p>
<p><code>ALLCPY</code> can accept a number of sizes up to the number of dimensions in the source record. These sizes will be used in
place of the some or all of the sizes from the source record. If any sizes are not specified RNMR will not prompt for
them and will use the sizes from the source record for those dimensions.</p>
<p>The next parameter, ndimx, is the number of dimensions of the blocked record that will be simultaneously accessible. If
ndimx is omitted RNMR will not prompt for it and will use the number of dimensions regardless of the value of ndimx in
the source record. The final parameter, nsega, is the number of segments to allocate in the records. If nsega is not
specified RNMR will not prompt for it and will allocate 1 segment regardless of the value of nsega in the source record.</p>
<p>In order for a blocked record to be successfully allocated there must be enough space in the archive (as displayed by
<code>SP</code>).</p>
<h3 id="amd">AMD</h3>
<p>Set acquisition modes</p>
<p>Category: Pulse Control</p>
<p>Format: <code>AMD</code> spec1 spec2 ... spec8</p>
<p>Qualifiers: /ACQ /BLK /MOD=MODMD</p>
<p>Qualifier Defaults: /ACQ /MOD=4</p>
<p>Defaults: none none ... none</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>AMD</code> sets the receiver phase cycling. /MOD defines the number of different phase values to be used. These phase values
will be equally spaced so the default value of 4 yields 90° phase steps while for example 6 would yield 60° steps.
Each element or mode of the <code>AMD</code> sequence is a number from 1 to the value specified by /MOD. With the default
qualifier /ACQ these modes indicate a sequence of phase shifts to apply to an acquired FID on sequential shots.</p>
<p>The default value is /MOD=4, which yields phase values of (0°, 90°, 180°, 270°) corresponding to the numbers 1
through 4. The maximum number of acquisition modes in a sequence is 64. If the number of modes entered is less than 64,
the specified modes will be replicated to a 64 mode sequence. For example, if the user specifies:</p>
<pre><code>    AMD 1111 3333
</code></pre>
<p>the eight modes specified are replicated by RNMR to give a full 64 step phase cycle:</p>
<pre><code> 11113333 11113333 11113333 11113333
 11113333 11113333 11113333 11113333
</code></pre>
<p>While all sequences are replicated to 64 modes internally, only a number of steps equal to the active phase cycle length
(set by <code>NAMD</code>) are actually used. The sequence of modes may be broken up across multiple command line arguments as
shown in the example above. This can help improve readability.</p>
<p>If <code>AMD</code> is called with no parameters RNMR will not prompt for modes. Instead it will print the current receiver phase
cycle out to the active phase cycle length with 16 modes per line.</p>
<p>The /BLK qualifier is used to setup additional receiver phase shifts for different blocks of acquisition. The number of
blocks can be set using <code>NAMD /BLK</code>. This capability is typically used to set up phase differences used for the
different steps in hypercomplex acquisition of multi-dimensional spectra.</p>
<h3 id="apnfil">APNFIL</h3>
<p>Append text to file</p>
<p>Category: File IO</p>
<p>Format: <code>APNFIL</code> fspec</p>
<p>Qualifiers: /END=&lt;end> /TTY</p>
<p>Qualifier Defaults: /END=''</p>
<p>Defaults: 'temp.dat'</p>
<p>Description:
<code>APNFIL</code> appends lines of text to a file fspec. /END sets a string which marks the end of what is to be appended.
<code>APNFIL</code> behaves slightly differently if called at the command line or in a macro. At the command line if no file is
specified RNMR will prompt for a file with temp.dat as a default. If the file exists and RNMR succeeds in opening it,
RNMR will then prompt for a line to append to the file with a default of &lt;end>. Otherwise an error will be thrown. RNMR
will continue to prompt for lines until a line is entered which matches &lt;end>. By default &lt;end> is an empty string and
<code>APNFIL</code> will end if an empty line is provided.</p>
<p>When called from a macro <code>APNFIL</code> will not prompt for a file name. The lines to be appended should be provided on the
lines following <code>APNFIL</code> in the macro and should start with ;;. The first line will be interpreted as a file name if
none is provided as an argument. <code>APNFIL</code> will stop appending lines when it either reaches a line that matches &lt;end> or
runs out of lines. /TTY will make RNMR prompt for the lines to enter much like the behavior at the command line even
when <code>APNFIL</code> is called from a macro. RNMR will still expect the file name to passed in the same way as when /TTY is not
used. An example of use in a macro is given here:</p>
<pre><code>APNFIL TEMP.TXT
;;Append this
;;Also append this
</code></pre>
<p>Text written by <code>APNFIL</code> will be all caps regardless of the capitalization provided in RNMR.</p>
<h3 id="apnlst">APNLST</h3>
<p>Append values to list</p>
<p>Category: Lists</p>
<p>Format: <code>APNLST</code> nam</p>
<p>Qualifiers: /END=&lt;end> /TTY</p>
<p>Qualifier Defaults: /END=''</p>
<p>Defaults: temp</p>
<p>Description:
<code>APNLST</code> appends lines to a list specified by nam. /END sets a string which marks the end of what is to be appended. If
no list is specified RNMR will prompt for a list name with a default of temp. The list must already have been created
using <code>CRTLST</code>. <code>APNLST</code> behaves slightly differently if called at the command line or in a macro. At the command line
RNMR will prompt for a line to append to the list with a default of &lt;end>. Otherwise an error will be thrown. RNMR
will continue to prompt for lines until a line is entered which matches &lt;end>. By default &lt;end> is an empty string and
<code>APNLST</code> will end if an empty line is provided.</p>
<p>When called from a macro <code>APNLST</code> will not prompt for a line to append unless the /TTY qualifier is used. Instead the
lines to be appended should be provided on the lines following <code>APNLST</code> in the macro and should start with ;;. <code>APNLST</code>
will stop appending lines when it either reaches a line that matches &lt;end> or runs out of lines. /TTY will make RNMR
prompt for the lines to enter much like the behavior at the command line even when <code>APNLST</code> is called from a macro.
used. An example of use in a macro is given here:</p>
<pre><code>APNLST TEMP
;;Append this
;;Also append this
</code></pre>
<p>Text appended by <code>APNLST</code> will be all caps regardless of the capitalization provided in RNMR.</p>
<h3 id="apnmac">APNMAC</h3>
<p>Append text to macro</p>
<p>Category: Macros</p>
<p>Format: <code>APNMAC</code> nam</p>
<p>Qualifiers: /END=&lt;end> /TTY</p>
<p>Qualifier Defaults: /END=''</p>
<p>Defaults: temp</p>
<p>Description:
<code>APNMAC</code> appends lines of text to a macro nam. /END sets a string which marks the end of what is to be appended.
<code>APNMAC</code> behaves slightly differently if called at the command line or in a macro. At the command line if no macro is
specified RNMR will prompt for a macro with temp as a default. If the macro exists, RNMR will then prompt for a line to
append to the macro with a default of &lt;end>. Otherwise an error will be thrown. RNMR will continue to prompt for lines
until a line is entered which matches &lt;end>. By default &lt;end> is an empty string and <code>APNMAC</code> will end if an empty
line is provided.</p>
<p>When called from a macro <code>APNMAC</code> will not prompt for a macro name. The lines to be appended should be provided on the
lines following <code>APNMAC</code> in the macro and should start with ;;. The first line will be interpreted as a macro name if
none is provided as an argument. <code>APNMAC</code> will stop appending lines when it either reaches a line that matches &lt;end> or
runs out of lines. /TTY will make RNMR prompt for the lines to enter much like the behavior at the command line even
when <code>APNMAC</code> is called from a macro. RNMR will still expect the macro name to passed in the same way as when /TTY is
not used. An example of use in a macro is given here:</p>
<pre><code>APNMAC TEMP.TXT
;;Append this
;;Also append this
</code></pre>
<p>Text written by <code>APNMAC</code> will be all caps regardless of the capitalization provided in RNMR.</p>
<h3 id="arv">ARV</h3>
<p>Return archive information</p>
<p>Category: Data Storage</p>
<p>Format: <code>ARV</code> arv</p>
<p>Qualifiers: /ACCESS /NAME</p>
<p>Qualifier Defaults: /NAME</p>
<p>Defaults: 1</p>
<p>Description:
<code>ARV</code> prints information about an <a href="../syntax/#archives">archive</a> arv as an informational message. If no archive is
specified RNMR will prompt for it with 1 as a default. The default /NAME qualifier causes <code>ARV</code> to print the name of
the specified archive as an informational message. The /ACCESS qualifier causes <code>ARV</code> to print an integer indicating
the level of access to the archive. The integer codes are generated by using the least significant bit to indicate
whether there is read access to the archive and the next least significant bit to indicate write access. Numbers for
which no archive is open will have neither and there will never be write access without read access. This yields the
following possible codes:</p>
<table>
<thead>
<tr>
<th>Access Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>No open archive</td>
</tr>
<tr>
<td>1</td>
<td>Read access</td>
</tr>
<tr>
<td>3</td>
<td>Read and write access</td>
</tr>
</tbody>
</table>
<h3 id="asig">ASIG</h3>
<p>Acknowledge signal</p>
<p>Category: Acquisition</p>
<p>Format: <code>ASIG</code> nam</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>ASIG</code> acknowledges and resets a <a href="../syntax/#signals">signal</a>. Signals occur asynchronously to macro execution during
acquisition and are primarily used for multi dimensional acquisition. If no signal is specified RNMR will prompt for it
with a default of temp. The specified signal must have been sent in order to acknowledge it. The presence of a signal
can be tested for using <code>TST SIG</code>.</p>
<h3 id="askyn">ASKYN</h3>
<p>Ask yes or no</p>
<p>Category: Control Flow</p>
<p>Format: <code>ASKYN</code> default labelt labelf</p>
<p>Defaults: NO none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ASKYN</code> falls into the same category as the old if commands. It prompts the user for a YES/NO response and jumps to
labelt if YES or labelf if NO.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="autoz">AUTOZ</h3>
<p>Set automatic Z shim parameters</p>
<p>Category: Shim</p>
<p>Format: <code>AUTOZ</code> step time</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMR shim control; RNMRA only</p>
<p>Description:
<code>AUTOZ</code> sets up automatic Z shimming in RNMRA. In order for this to function RNMR must have access to both the lock and
shim controls. In order for <code>AUTOZ</code> to have any effect the automatic Z shimming flag (as set and displayed by
<code>SET AUTOZ</code>) must be on. If either the step or time is omitted RNMR will prompt for them with the current values as a
default. The step must be between 0.0 and 1.0 inclusive, while time must be between 4.0 and 100.0 inclusive.</p>
<h2 id="b">B</h2>
<hr />
<h3 id="bc">BC</h3>
<p>Baseline correct FID</p>
<p>Category: Baseline</p>
<p>Format: <code>BC</code></p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>BC</code> performs a baseline correction to a complex FID in the visible processing buffer by subtracting the average of the
last 1/8th of the data points from the entire FID. To calculate the constant complex offset to be subtracted from the
entire FID, <code>BC</code> examines the final 1/8th of the FID data points with a minimum of 1 point if there are less than 8
points. The average of these points (a complex number) is subtracted from each (complex) point of the entire FID,
yielding a baseline corrected FID.</p>
<h3 id="bf">BF</h3>
<p>Baseline fix spectrum</p>
<p>Category: Baseline</p>
<p>Format: <code>BF</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>BF</code> performs a linear baseline fix by subtracting a straight line from the data in the visible processing buffer
between the current display limits.</p>
<p><code>BF</code> uses the average of the leftmost and rightmost 5 points between the current display limits to determine the line to
subtract. If there are fewer than 5 points between the current display limits <code>BF</code> subtracts the average over all the
points instead of calculating a line. <code>BF</code> only subtracts from the points between the current display limits, leaving
everything outside of those limits untouched.</p>
<h3 id="bincp">BINCP</h3>
<p>Perform binary pulse phase correction</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>BINCP</code> fnyq fmax</p>
<p>Defaults: first (fnyq-orgn)/2+orgn</p>
<p>Prerequisites: Frequency data in processing buffer (FREQ)</p>
<p>Description:
<code>BINCP</code> performs the phase portion of a binary pulse correction on data in the visible processing buffer. When used with
the <code>BINCP</code> solvent suppression pulse sequence, this command corrects the phase of the off-resonant component of the
magnetization, which is preserved while the on-resonance solvent peak is cancelled out. The parameters fnyq and fmax are
the nyquist frequency of the visible processing buffer and the max frequency to be used for the correction. Both
parameters are specified in terms of current frequency units including the frequency offset of the origin of the buffer
(orgn). The default value of fnyq will be correspond to the frequency of the first point in the buffer. The default of
fmax is (fnyq-orgn)/2+orgn. Internally <code>BINCP</code> subtracts the origin from the values before using them. In order to make
the calculations more understandable all references to these parameters going forward will refer to the corrected values
with the origin subtracted out. The corrected fnyq must be greater than 0. The absolute value of the corrected fmax
divided by the corrected fnyq must be between 0.1 and 2.0.</p>
<p>To calculate the phase portion of the finite pulse correction, <code>BINCP</code> first calculates a constant phase and a phase
increment:</p>
<pre><code>PHI = 270.0*DFRST/FMAX - 90.0
DPHI = 270.0*DSTEP/FMAX
</code></pre>
<p>where DSTEP is -1 times the frequency per point and DFRST is the frequency of the first point in the spectrum.</p>
<p>Each point I ranging from 1 to the size of the buffer is multiplied by a complex phase shift calculated as follows:</p>
<pre><code>EXP(i*(PHI + (I-1)* DPHI))
</code></pre>
<p>If the data point closest to zero frequency (without offset) is not the last point in the spectrum, then all points
in each block from zero to minimum (most negative) frequency are negated.</p>
<h3 id="brkdo">BRKDO</h3>
<p>Break out of a macro <code>DO</code> loop</p>
<p>Category: Control Flow</p>
<p>Format: <code>BRKDO</code></p>
<p>Prerequisites: Macro only and must be in a <code>DO</code> loop</p>
<p>Description:
<code>BRKDO</code> can be used to break out of a macro <code>DO</code> loop. The loop will terminate immediately without executing any more
commands within the loop regardless of how many more iterations it was supposed to do. Execution will continue on the
line after the <code>ENDDO</code> at the end of the loop. <code>BRKDO</code> must appear between <code>DO</code> and <code>ENDDO</code></p>
<h3 id="bruk">BRUK</h3>
<p>Convert BRUKER FID to complex FID</p>
<p>Category: Foreign</p>
<p>Format: <code>BRUK</code></p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>BRUK</code> converts a BRUKER format (real) FID in the visible processing buffer into a complex FID. Upon conversion from
BRUKER to complex format, the size of the FID (number of points) is adjusted to the smallest power of 2 greater than or
equal to the original size. <code>BRUK</code> will convert the data only if this adjusted size is at least 4 points and not
greater than the allocated buffer size (<code>SHOW BUF SIZEA</code>). The data is zero filled from the current size to the adjusted
size. The actual conversion from BRUKER (real) to complex data follows the  algorithm below:</p>
<ol>
<li>The entire zero-filled BRUKER FID is conjugated.</li>
<li>
<p>Starting with the second point, every other point in the FID is negated.</p>
</li>
<li>
<p>A real Fourier transform is performed on the FID, yielding a complex vector with half the adjusted size of the source
FID.</p>
</li>
<li>
<p>The resulting vector is inverse Fourier transformed.</p>
</li>
<li>
<p>Starting with the second point, every other point in the FID is negated.</p>
</li>
</ol>
<h3 id="buf">BUF</h3>
<p>View real or imaginary processing buffer</p>
<p>Category: Display Control</p>
<p>Format: <code>BUF</code> nam</p>
<p>Defaults: current</p>
<p>Description:
<code>BUF</code> selects whether the real or imaginary part of the visible processing buffer should be displayed. The parameter
nam may be set to real, imag, or complex to display the real part, imaginary part or both parts of the buffer
respectively. If nam is omitted RNMR will prompt for a response with the current buffer display type as a default.</p>
<h3 id="bufa">BUFA</h3>
<p>View real or imaginary acquisition buffer</p>
<p>Category: Display Control</p>
<p>Format: <code>BUFA</code> nam</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>BUFA</code> selects whether the real or imaginary part of the acquisition buffer should be displayed. The parameter nam may
be set to real, imag, or complex to display the real part, imaginary part or both parts of the buffer respectively. If
nam is omitted RNMR will prompt for a response with the current buffer display type as a default.</p>
<h2 id="c">C</h2>
<hr />
<h3 id="calc">CALC</h3>
<p>Perform floating point arithmetic and logical calculations</p>
<p>Category: Calculator</p>
<p>Format: <code>CALC</code> arg1 ... arg10</p>
<p>Qualifiers: /NDEC</p>
<p>Qualifier Defaults: /NDEC=-1</p>
<p>Defaults: none</p>
<p>Description:
<code>CALC</code> performs desk calculator operations in reverse Polish notation. Arguments are pushed onto the calculator stack
and operations are performed on them, yielding results which may either be printed to the screen (PRT) or popped into
local (&gt;&gt;) or global (&gt;) arguments or symbols (&gt;&gt;&gt;). <code>CALC</code> can perform basic arithmetic operations (+, -, *, /) using
infix notation when pushing values onto the stack. Infix operations are performed left to right with no regard for order
of operations, but parentheses can be used to alter this order. The result of this infix math is pushed onto the stack
like any other argument. All calculations are performed internally using single precision floating point arithmetic. The
results are presented as integers (NDEC -1) unless modified by the NDEC qualifier or the NDEC operator, as described
below. For example the following command:</p>
<pre><code>CALC /NDEC=2 1/3 PRT
</code></pre>
<p>will print the following as an informational message:</p>
<pre><code>VAL    =0.33
</code></pre>
<p>The /NDEC qualifier must be an integer from -1 to 6.</p>
<p><code>CALC</code> operates on each argument on the command line from left to right. Remember that each argument can contain no more
than 16 characters. The calculator stack used by <code>CALC</code> has a depth of 10. If an attempt is made to push more than 10
arguments onto the stack, the error message "(CALC0 ) STACK OVERFLOW" will be displayed. When <code>CALC</code> encounters a unary
arithmetic operator such as ABS (absolute value), it expects that there exists at least one value on the stack on which
to operate. To put this another way, TOS (Top Of Stack) must exist. If the stack is empty, the error message "(CALC0)
STACK UNDERFLOW" will be displayed. Similarly, there must be at least two values on the stack in order to perform a
binary arithmetic operation; a lack of sufficiently many arguments will give an underflow error. When a binary operation
is executed, the result replaces both (TOS) and (TOS-1), reducing the number of values on the stack by one. When a
constant is pushed onto the stack, the number of values on the stack increases by one. When a unary operation is
executed, the number of values on the stack does not change. <code>CALC</code> also has access to a 16 element register, which
values can be stored in.</p>
<p>The arguments which may be used with the <code>CALC</code> command are as follows:</p>
<p>Constants:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>Pushes the constant e onto the top of the stack.</td>
<td>(TOS)=e</td>
</tr>
<tr>
<td>PI</td>
<td>Pushes the constant pi onto the stack.</td>
<td>(TOS)=pi</td>
</tr>
</tbody>
</table>
<p>Unary Arithmetic Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS</td>
<td>Replaces the top of stack with its absolute value</td>
<td>(TOS)=ABS(TOS)</td>
</tr>
<tr>
<td>ACOS</td>
<td>Replaces the top of stack with its inverse cosine. The result is in units of radians.</td>
<td>(TOS)=ACOS(TOS)</td>
</tr>
<tr>
<td>ACOSD</td>
<td>Replaces the top of stack with its inverse cosine. The result is in units of degrees.</td>
<td>(TOS)=ACOSD(TOS)</td>
</tr>
<tr>
<td>ASIN</td>
<td>Replaces the top of stack with its inverse sine. The result is in units of radians.</td>
<td>(TOS)=ASIN(TOS)</td>
</tr>
<tr>
<td>ASIND</td>
<td>Replaces the top of stack with its inverse sine. The result is in units of degrees.</td>
<td>(TOS)=ASIND(TOS)</td>
</tr>
<tr>
<td>ATAN</td>
<td>Replaces the top of stack with its inverse tangent. The result is in units of radians.</td>
<td>(TOS)=ATAN(TOS)</td>
</tr>
<tr>
<td>ATAND</td>
<td>Replaces the top of stack with its inverse tangent. The result is in units of degrees.</td>
<td>(TOS)=ATAND(TOS)</td>
</tr>
<tr>
<td>COS</td>
<td>Replaces the top of stack with its cosine. The operand is assumed to be in units of radians.</td>
<td>(TOS)=COS(TOS)</td>
</tr>
<tr>
<td>COSD</td>
<td>Replaces the top of stack with its cosine. The operand is assumed to be in units of degrees.</td>
<td>(TOS)=COSD(TOS)</td>
</tr>
<tr>
<td>COSH</td>
<td>Replaces the top of stack with its hyperbolic cosine.</td>
<td>(TOS)=COSH(TOS)</td>
</tr>
<tr>
<td>EXP</td>
<td>Replaces the top of stack with e^(TOS). The operand must be no greater than 30.0.</td>
<td>(TOS)=EXP(TOS)</td>
</tr>
<tr>
<td>INT</td>
<td>Replaces the top of stack with the largest integer whose absolute value does not exceed the absolute value of (TOS) and has the same sign as (TOS).</td>
<td>(TOS)=AINT(TOS)</td>
</tr>
<tr>
<td>LOG</td>
<td>Replaces the top of stack with its natural (base e) logarithm.  The operand must be greater than 0.0.</td>
<td>(TOS)=LOG(TOS)</td>
</tr>
<tr>
<td>LOG10</td>
<td>Replaces the top of stack with its common (base 10) logarithm. The operand must be greater than 0.0.</td>
<td>(TOS)=ALOG10(TOS)</td>
</tr>
<tr>
<td>NEG</td>
<td>Replaces the top of stack with its negative.</td>
<td>(TOS)=-(TOS).</td>
</tr>
<tr>
<td>NINT</td>
<td>Replaces the top of stack with the integer nearest to (TOS).</td>
<td>(TOS)=ANINT(TOS).</td>
</tr>
<tr>
<td>SIN</td>
<td>Replaces the top of stack with its sine. The operand is assumed to be in units of radians.</td>
<td>(TOS)=SIN(TOS)</td>
</tr>
<tr>
<td>SIND</td>
<td>Replaces the top of stack with its sine. The operand is assumed to be in units of degrees.</td>
<td>(TOS)=SIND(TOS)</td>
</tr>
<tr>
<td>SIN</td>
<td>Replaces the top of stack with its hyperbolic sine.</td>
<td>(TOS)=SINH(TOS)</td>
</tr>
<tr>
<td>SQRT</td>
<td>Replaces the top of stack with its square root. The operand must be greater than or equal to 0.0.</td>
<td>(TOS)=SQRT(TOS)</td>
</tr>
<tr>
<td>TAN</td>
<td>Replaces the top of stack with its tangent. The operand is assumed to be in units of radians.</td>
<td>(TOS)=TAN(TOS)</td>
</tr>
<tr>
<td>TAND</td>
<td>Replaces the top of stack with its tangent. The operand is assumed to be in units of degrees.</td>
<td>(TOS)=TAND(TOS)</td>
</tr>
<tr>
<td>TAN</td>
<td>Replaces the top of stack with its hyperbolic tangent.</td>
<td>(TOS)=TANH(TOS)</td>
</tr>
</tbody>
</table>
<p>Binary Arithmetic Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>Replaces (TOS) and (TOS-1) with their sum.</td>
<td>(TOS)=(TOS-1)+(TOS)</td>
</tr>
<tr>
<td>ATAN2</td>
<td>Replaces (TOS-1) and (TOS) with the inverse tangent of their ratio. The result is in units of radians.</td>
<td>(TOS)=ATAN((TOS-1)/(TOS))</td>
</tr>
<tr>
<td>ATAN2D</td>
<td>Replaces (TOS-1) and (TOS) with the inverse tangent of their ratio. The result is in units of degrees.</td>
<td>(TOS)=ATAND((TOS-1)/(TOS))</td>
</tr>
<tr>
<td>DIV</td>
<td>Replaces (TOS-1) and (TOS) with their quotient. Division by zero is not allowed.</td>
<td>(TOS)=(TOS-1)/(TOS)</td>
</tr>
<tr>
<td>MAX</td>
<td>Replaces (TOS-1) and (TOS) with the greater of the two values.</td>
<td>(TOS)=AMAX1((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MIN</td>
<td>Replaces (TOS-1) and (TOS) with the lesser of the two values.</td>
<td>(TOS)=AMIN1((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MOD</td>
<td>Replaces (TOS-1) and (TOS) with the remainder of: (TOS1)/(TOS). Division by zero is not allowed.</td>
<td>(TOS)=AMOD((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MUL</td>
<td>Replaces (TOS-1) and (TOS) with their product.</td>
<td>(TOS)=(TOS-1)*(TOS)</td>
</tr>
<tr>
<td>SUB</td>
<td>Replaces (TOS-1) and (TOS) with their difference.</td>
<td>(TOS)=(TOS-1)-(TOS)</td>
</tr>
</tbody>
</table>
<p>Unary Logical Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT</td>
<td>Replaces (TOS) with the bitwise not of its integer representation.</td>
<td>(TOS)=NOT INT(TOS)</td>
</tr>
</tbody>
</table>
<p>Binary Logical Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>Replaces (TOS-1) and (TOS) with the bitwise and of their integer representations.</td>
<td>(TOS)=INT(TOS-1) AND INT(TOS)</td>
</tr>
<tr>
<td>OR</td>
<td>Replaces (TOS-1) and (TOS) with the bitwise or of their integer representations.</td>
<td>(TOS)=INT(TOS-1) OR INT(TOS)</td>
</tr>
</tbody>
</table>
<p>Binary Relational Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQ</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if they are equal or with 0.0 if they are not equal.</td>
<td>(TOS)=(TOS-1)==(TOS)</td>
</tr>
<tr>
<td>GE</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if (TOS-1) is greater than or equal to (TOS) or with 0.0 otherwise.</td>
<td>(TOS)=(TOS-1)&gt;=(TOS)</td>
</tr>
<tr>
<td>GT</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if (TOS-1) is greater than (TOS) or with 0.0 otherwise.</td>
<td>(TOS)=(TOS-1)&gt;(TOS)</td>
</tr>
<tr>
<td>LE</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if (TOS-1) is less than or equal to (TOS) or with 0.0 otherwise.</td>
<td>(TOS)=(TOS-1)&lt;=(TOS)</td>
</tr>
<tr>
<td>LT</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if (TOS-1) is less than (TOS) or with 0.0 otherwise.</td>
<td>(TOS)=(TOS-1)&lt;(TOS)</td>
</tr>
<tr>
<td>NE</td>
<td>Replaces (TOS-1) and (TOS) with 1.0 if they are not equal or with 0.0 if they are equal.</td>
<td>(TOS)=(TOS-1)!=(TOS)</td>
</tr>
</tbody>
</table>
<p>Register Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOAD</td>
<td>Replace TOS with the value in the register position specified by TOS</td>
</tr>
<tr>
<td>STORE</td>
<td>Store TOS-1 in the register position specified by TOS. STORE reduces the number of values on the stack by 2.</td>
</tr>
</tbody>
</table>
<p>Special Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DUP</td>
<td>Duplicates the top of stack, increasing the number of values on  the stack by 1. If the stack is empty, DUP will result in a (CALC0 ) STACK UNDERFLOW error message. Conversely, if the stack is full when <code>CALC</code> encounters the DUP operator, a (CALC0) STACK OVERFLOW error message will be displayed.</td>
</tr>
<tr>
<td>NDEC</td>
<td>sets the number of decimal places for displaying or popping results from the calculator stack. The top of stack defines the maximum number of decimal places that will be displayed. On completion, NDEC pops the top of stack, decreasing the stack size be one. In order to use NDEC, the stack must not be empty. "-1 NDEC" directs <code>CALC</code> to display and pop results as integers i.e. with no decimal point, while "0 NDEC" yields results with a final decimal point but no digits to the right of the decimal point. Higher values of NDEC request additional digits to the right of the decimal point, but these may be dropped if the value is too large.</td>
</tr>
<tr>
<td>PRT</td>
<td>Displays the top of stack as an informational message. The value of the top of stack is displayed with the current number of decimal places as set by a previous NDEC operator on the same <code>CALC</code> command line. If no NDEC operator preceded the PRT command, then the top of stack will be displayed as an integer (NDEC -1). On completion, PRT pops the top of stack, decreasing the stack size be one. In order to use PRT, the stack must not be empty.</td>
</tr>
<tr>
<td>SWAP</td>
<td>Swap the positions on the stack of the values at (TOS) and (TOS-1)</td>
</tr>
<tr>
<td>></td>
<td>Pops the top of stack into a global argument. The name of the global argument which will receive the value is given by the remaining characters in the <code>CALC</code> parameter beginning with ">". The name of the global argument may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because > pops the top of stack, the stack size is decreased by one after > is processed. In order to use >, the stack must not be empty.</td>
</tr>
<tr>
<td>>></td>
<td>Pops the top of stack into a local argument. The name of the local argument which will receive the value is given by the remaining characters in the <code>CALC</code> parameter beginning with ">>". The name of the local argument may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because >> pops the top of stack, the stack size is decreased by one after >> is processed. In order to use >>, the stack must not be empty.</td>
</tr>
<tr>
<td>>>></td>
<td>Pops the top of stack into a symbol. The name of the symbol which will receive the value is given by the remaining characters in the <code>CALC</code> parameter beginning with ">>>". The name of the symbol may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because >>> pops the top of stack, the stack size is decreased by one after >>> is processed. In order to use >>>, the stack must not be empty.</td>
</tr>
</tbody>
</table>
<p>Any argument on the <code>CALC</code> command line other than those listed above is treated as a default push onto the calculator
stack. Values may be pushed onto the stack only if the stack is not full, i.e. there are fewer than 10 values on the
stack before the push operation. A default push operation increases the stack depth by one. Because all <code>CALC</code>
manipulations are performed using real arithmetic, only integers or real numbers may be pushed onto the stack;
alphabetic and special characters may not be entered. Values to be pushed onto the stack may be written in exponential
notation if desired. A value to be pushed onto the stack must be no more than sixteen characters long. Values popped
from the stack into local or global arguments should not be more than sixteen characters. If a longer value is popped
into an argument the argument will be filled with *s. Be careful not to set NDEC to too large a value in order to avoid
this situation. An example of a default push is shown in the command below:</p>
<pre><code>CALC 1 2 MAX PRT
</code></pre>
<p>Here, the arguments "1" and "2" are not operations known to RNMR, so they are interpreted as values to be pushed onto
the calculator stack. Once all operations specified on the <code>CALC</code> command line have been executed, RNMR checks that the
calculator stack is empty. If it is not empty, an error message will be displayed.</p>
<h3 id="calci">CALCI</h3>
<p>Perform integer arithmetic, logical, and bitwise calculations</p>
<p>Category: Calculator</p>
<p>Format: <code>CALCI</code> arg1 ... arg10</p>
<p>Defaults: none</p>
<p>Description:
<code>CALCI</code> performs desk calculator operations in reverse Polish notation. Arguments are pushed onto the calculator stack
and operations are performed on them, yielding results which may either be printed to the screen (PRT) or popped into
local (&gt;&gt;) or global (&gt;) arguments or symbols (&gt;&gt;&gt;). <code>CALCI</code> can perform basic arithmetic operations (+, -, *, /) using
infix notation when pushing values onto the stack. Infix operations are performed left to right with no regard for order
of operations, but parentheses can be used to alter this order. The result of this infix math is pushed onto the stack
like any other argument. All calculations are performed internally using 32 bit integer arithmetic. As a result values
to be pushed onto the stack should be between -2,147,483,647 and 2,147,483,647. <code>CALCI</code> does allow for integer overflow
so be cautious if performing calculations with large numbers near these bounds. For example the following command:</p>
<pre><code>CALCI 2*3 PRT
</code></pre>
<p>will print the following as an informational message:</p>
<pre><code>VAL    =6
</code></pre>
<p><code>CALCI</code> operates on each argument on the command line from left to right. The calculator stack used by <code>CALCI</code> has a
depth of 10. If an attempt is made to push more than 10 arguments onto the stack, the error message "(CALCI0 ) STACK
OVERFLOW" will be displayed. When <code>CALCI</code> encounters a unary arithmetic operator such as ABS (absolute value), it
expects that there exists at least one value on the stack on which to operate. To put this another way, TOS (Top Of
Stack) must exist. If the stack is empty, the error message "(CALC0) STACK UNDERFLOW" will be displayed. Similarly,
there must be at least two values on the stack in order to perform a binary arithmetic operation; a lack of sufficiently
many arguments will give an underflow error. When a binary operation is executed, the result replaces both (TOS) and
(TOS-1), reducing the number of values on the stack by one. When a constant is pushed onto the stack, the number of
values on the stack increases by one. When a unary operation is executed, the number of values on the stack does not
change.</p>
<p>The arguments which may be used with the <code>CALCI</code> command are as follows:</p>
<p>Unary Arithmetic Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS</td>
<td>Replaces the top of stack with its absolute value</td>
<td>(TOS)=ABS(TOS)</td>
</tr>
<tr>
<td>EXP2</td>
<td>Replaces the top of stack with 2 raised to the power given by the top of the stack. The operand must be no greater than 30.</td>
<td>(TOS)=2^(TOS)</td>
</tr>
<tr>
<td>LOG2</td>
<td>Replaces the top of stack with its base 2 logarithm. The operand must be greater than 0.</td>
<td>(TOS)=LOG2(TOS)</td>
</tr>
<tr>
<td>NEG</td>
<td>Replaces the top of stack with its negative.</td>
<td>(TOS)=-(TOS).</td>
</tr>
</tbody>
</table>
<p>Binary Arithmetic Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>Replaces (TOS) and (TOS-1) with their sum.</td>
<td>(TOS)=(TOS-1)+(TOS)</td>
</tr>
<tr>
<td>DIV</td>
<td>Replaces (TOS-1) and (TOS) with their quotient using integer division. Division by zero is not allowed.</td>
<td>(TOS)=(TOS-1)/(TOS)</td>
</tr>
<tr>
<td>MAX</td>
<td>Replaces (TOS-1) and (TOS) with the greater of the two values.</td>
<td>(TOS)=AMAX1((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MIN</td>
<td>Replaces (TOS-1) and (TOS) with the lesser of the two values.</td>
<td>(TOS)=AMIN1((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MOD</td>
<td>Replaces (TOS-1) and (TOS) with the remainder of: (TOS1)/(TOS). Division by zero is not allowed.</td>
<td>(TOS)=AMOD((TOS-1),(TOS))</td>
</tr>
<tr>
<td>MUL</td>
<td>Replaces (TOS-1) and (TOS) with their product.</td>
<td>(TOS)=(TOS-1)*(TOS)</td>
</tr>
<tr>
<td>SUB</td>
<td>Replaces (TOS-1) and (TOS) with their difference.</td>
<td>(TOS)=(TOS-1)-(TOS)</td>
</tr>
</tbody>
</table>
<p>Unary Logical Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT</td>
<td>Replaces (TOS) with its bitwise not.</td>
<td>(TOS)=NOT (TOS)</td>
</tr>
</tbody>
</table>
<p>Binary Logical Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>Replaces (TOS-1) and (TOS) with their bitwise and.</td>
<td>(TOS)=(TOS-1) AND (TOS)</td>
</tr>
<tr>
<td>OR</td>
<td>Replaces (TOS-1) and (TOS) with their bitwise or.</td>
<td>(TOS)=(TOS-1) OR (TOS)</td>
</tr>
</tbody>
</table>
<p>Binary Relational Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQ</td>
<td>Replaces (TOS-1) and (TOS) with 1 if they are equal or with 0 if they are not equal.</td>
<td>(TOS)=(TOS-1)==(TOS)</td>
</tr>
<tr>
<td>GE</td>
<td>Replaces (TOS-1) and (TOS) with 1 if (TOS-1) is greater than or equal to (TOS) or with 0 otherwise.</td>
<td>(TOS)=(TOS-1)&gt;=(TOS)</td>
</tr>
<tr>
<td>GT</td>
<td>Replaces (TOS-1) and (TOS) with 1 if (TOS-1) is greater than (TOS) or with 0 otherwise.</td>
<td>(TOS)=(TOS-1)&gt;(TOS)</td>
</tr>
<tr>
<td>LE</td>
<td>Replaces (TOS-1) and (TOS) with 1 if (TOS-1) is less than or equal to (TOS) or with 0 otherwise.</td>
<td>(TOS)=(TOS-1)&lt;=(TOS)</td>
</tr>
<tr>
<td>LT</td>
<td>Replaces (TOS-1) and (TOS) with 1 if (TOS-1) is less than (TOS) or with 0 otherwise.</td>
<td>(TOS)=(TOS-1)&lt;(TOS)</td>
</tr>
<tr>
<td>NE</td>
<td>Replaces (TOS-1) and (TOS) with 1 if they are not equal or with 0 if they are equal.</td>
<td>(TOS)=(TOS-1)!=(TOS)</td>
</tr>
</tbody>
</table>
<p>Register Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOAD</td>
<td>Replace TOS with the value in the register position specified by TOS</td>
</tr>
<tr>
<td>STORE</td>
<td>Store TOS-1 in the register position specified by TOS. STORE reduces the number of values on the stack by 2.</td>
</tr>
</tbody>
</table>
<p>Bit Manipulation Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXTRACT</td>
<td>Extract (TOS) bits starting at bit (TOS-1) from (TOS-2). The extracted bits will be the least significant bits of the new (TOS) with all other bits being 0. EXTRACT reduces the number of values on the stack by 2.</td>
</tr>
<tr>
<td>INSERT</td>
<td>Insert (TOS) bits starting at bit (TOS-1) from (TOS-2) into (TOS-3) and put the result in (TOS). The rest of the bits will be untouched. INSERT reduces the number of values on the stack by 3.</td>
</tr>
<tr>
<td>SHFT</td>
<td>Replace (TOS) and (TOS-1) with (TOS-1) bit shifted by (TOS) bits. Positive (TOS) indicates a left shift while negative (TOS) indicates a right shift.</td>
</tr>
</tbody>
</table>
<p>Special Operators:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DUP</td>
<td>Duplicates the top of stack, increasing the number of values on  the stack by 1. If the stack is empty, DUP will result in a (CALC0 ) STACK UNDERFLOW error message. Conversely, if the stack is full when <code>CALCI</code> encounters the DUP operator, a (CALC0) STACK OVERFLOW error message will be displayed.</td>
</tr>
<tr>
<td>PRT</td>
<td>Displays the top of stack as an informational message. The value of the top of stack is displayed with the current number of decimal places as set by a previous NDEC operator on the same <code>CALCI</code> command line. If no NDEC operator preceded the PRT command, then the top of stack will be displayed as an integer (NDEC -1). On completion, PRT pops the top of stack, decreasing the stack size be one. In order to use PRT, the stack must not be empty.</td>
</tr>
<tr>
<td>SWAP</td>
<td>Swap the positions on the stack of the values at (TOS) and (TOS-1)</td>
</tr>
<tr>
<td>>></td>
<td>Pops the top of stack into a local argument. The name of the local argument which will receive the value is given by the remaining characters in the <code>CALCI</code> parameter beginning with ">>". The name of the local argument may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because >> pops the top of stack, the stack size is decreased by one after >> is processed. In order to use >>, the stack must not be empty.</td>
</tr>
<tr>
<td>></td>
<td>Pops the top of stack into a global argument. The name of the global argument which will receive the value is given by the remaining characters in the <code>CALCI</code> parameter beginning with ">". The name of the global argument may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because > pops the top of stack, the stack size is decreased by one after > is processed. In order to use >, the stack must not be empty.</td>
</tr>
<tr>
<td>>>></td>
<td>Pops the top of stack into a symbol. The name of the symbol which will receive the value is given by the remaining characters in the <code>CALCI</code> parameter beginning with ">>>". The name of the symbol may not be blank, cannot be longer than sixteen characters, and must use only the characters A-Z, 0-9, $, or _. Because >>> pops the top of stack, the stack size is decreased by one after >>> is processed. In order to use >>>, the stack must not be empty.</td>
</tr>
</tbody>
</table>
<p>Any argument on the <code>CALCI</code> command line other than those listed above is treated as a default push onto the calculator
stack. Values may be pushed onto the stack only if the stack is not full, i.e. there are fewer than 10 values on the
stack before the push operation. A default push operation increases the stack depth by one. Because all <code>CALCI</code>
manipulations are performed using integer arithmetic, only integers may be pushed onto the stack; decimals as well as
alphabetic and special characters may not be entered. An example of a default push is shown in the command below:</p>
<pre><code>CALCI 1 2 MAX PRT
</code></pre>
<p>Here, the arguments "1" and "2" are not operations known to RNMR, so they are interpreted as values to be pushed onto
the calculator stack. Once all operations specified on the <code>CALCI</code> command line have been executed, RNMR checks that the
calculator stack is empty. If it is not empty, an error message will be displayed.</p>
<h3 id="calib">CALIB</h3>
<p>Determine data buffer amplitudes and phases</p>
<p>Category: Acquisition</p>
<p>Format: <code>CALIB</code> fcalib</p>
<p>Qualifiers: /REAL /IMAG</p>
<p>Qualifier Defaults: /REAL</p>
<p>Defaults: current</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>CALIB</code> is used with the calib pulse program to calibrate spectrometer phases. It is to be used only by the support
staff. The argument fcalib is a real number interpreted in the current frequency unit of the visible processing buffer.
If fcalib is omitted  RNMR will prompt for it with the current calibration frequency as a default. After conversion to
Hz, the calibration frequency must be nonzero.</p>
<h3 id="case">CASE</h3>
<p>Process <code>CASE</code> clause of <code>SEL</code> block</p>
<p>Category: Control Flow</p>
<p>Format: <code>CASE</code> val</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>CASE</code> executes the block of commands that falls between it and either the next <code>CASE</code> command or <code>ENDSEL</code> if the value
used in the <code>SEL</code> block matches val. If val is omitted then <code>CASE</code> will act as if it matches for any value. <code>CASE</code> must
be between a <code>SEL</code> and a matching <code>ENDSEL</code>.</p>
<h3 id="cat">CAT</h3>
<p>List catalog of records</p>
<p>Category: Data Storage</p>
<p>Format: <code>CAT</code> first-rec last-rec</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: 0 200</p>
<p>Description:
<code>CAT</code> displays a catalog of records from first-rec to last-rec within a single archive. <code>CAT</code> takes two parameters,
which are the first and last <a href="../syntax/#records">record numbers</a> to be displayed. If first-rec is set to record 0 (which
does not exist) in an archive, all of the records in that archive up to last-rec will be listed. In this case if
last-rec is omitted all the records in the archive are listed. If neither parameter is specified the default behavior is
to list all records in archive 1. If first rec is set to any other value and last-rec is omitted only that record will
be listed. The value of last-rec should be specified by the number within the archive even if it is not in archive 1.</p>
<p>For each nonempty record, <code>CAT</code> returns the record  number, owner, record length, record position within the archive,
date, and title. Note that <code>CAT</code> reports record length and position in units of blocks, which are 512 bytes long each.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catarv">CATARV</h3>
<p>List catalog of archives</p>
<p>Category: Data Storage</p>
<p>Format: <code>CATARV</code> first_archive last_archive</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: 1 4</p>
<p>Description:
<code>CATARV</code> displays a list of <a href="../syntax/#archives">archives</a> from first-archive to last-archive. If only one argument is
specified, <code>CATARV</code> will list information about only that single archive. <code>CATARV</code> shows the archive number and if the
archive is open it also shows flags indicating the presence of read access and write access, as well as the name of the
archive.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catgbl">CATGBL</h3>
<p>List catalog of global variables</p>
<p>Category: Arguments</p>
<p>Format : <code>CATGBL</code> first last</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATGBL</code> displays a catalog of the currently defined global arguments by name from first to last in alphabetical order.
If both arguments are omitted <code>CATGBL</code> will list all global arguments. If only one argument is specified, <code>CATGBL</code> will
list information about only that single argument. Each global argument is listed by name along with its current value.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catlcl">CATLCL</h3>
<p>List catalog of local variables</p>
<p>Category: Arguments</p>
<p>Format: <code>CATLCL</code> first last</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATLCL</code> displays a catalog of the currently defined local arguments by name from first to last in alphabetical order.
If both arguments are omitted <code>CATLCL</code> will list all local arguments. If only one argument is specified, <code>CATLCL</code> will
list information about only that single argument. Each local argument is listed by name along with its current value.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catlst">CATLST</h3>
<p>List catalog of lists</p>
<p>Category: Lists</p>
<p>Format: <code>CATLST</code> first last</p>
<p>Qualifiers: /PRT /TTY /VAL /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATLST</code> displays a catalog of the currently defined lists by name from first to last in alphabetical order. If both
arguments are omitted <code>CATLST</code> will list all lists. If only one argument is specified, <code>CATLST</code> will list information
about only that single list. Each list is listed by name along with its maximum size and its current size.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/VAL</td>
<td>Also list the values in the list</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catmac">CATMAC</h3>
<p>List catalog of macros</p>
<p>Category: Macros</p>
<p>Format: <code>CATMAC</code> first last</p>
<p>Qualifiers: /PRT /SYS /TTY /USR /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATMAC</code> displays a catalog of the currently defined macros by name from first to last in alphabetical order. If both
arguments are omitted <code>CATMAC</code> will list all macros. If only one argument is specified, <code>CATMAC</code> will list information
about only that single macro. Each macro is listed by name along with whether it is a user or system macro and the file
where it is stored. The file will only be listed if the macro has been called during the current RNMR session.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/SYS</td>
<td>List system macros</td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/USR</td>
<td>List user macros</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<p>Note that if neither /USR nor /SYS is specified <code>CATMAC</code> will list both, which is the same behavior as if both are
specified.</p>
<h3 id="catnuc">CATNUC</h3>
<p>List catalog of nuclei</p>
<p>Category: Frequency Control</p>
<p>Format: <code>CATNUC</code> first last</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATNUC</code> displays a catalog of the currently defined nuclei by name from first to last in alphabetical order. If both
arguments are omitted <code>CATNUC</code> will list all nuclei. If only one argument is specified, <code>CATNUC</code> will list information
about only that single nucleus. Each nucleus is listed by name along with its current frequency (value used to convert
between PPM and Hz) in MHz and its reference frequency in Hz.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catpps">CATPPS</h3>
<p>List catalog of PP symbols</p>
<p>Category: Pulse Program Symbols</p>
<p>Format: <code>CATPPS</code> type first last</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none none ZZZZZZZZZZZZZZZZ</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>CATPPS</code> displays a catalog of the currently defined PP symbols. The catalog is organized by PP symbol type and then
each type section is organized by name from first to last in alphabetical order. If type is omitted from the command
line then <code>CATPPS</code> will display all types of symbols. If a type is specified then only the section of the catalog
corresponding to that type will be listed. If both first and last are omitted <code>CATPPS</code> will list all entries in each
included section. If only one of first and last is specified, <code>CATPPS</code> will list information about only that single PP
symbol in each included section. Each PP symbol is listed by name along with its location.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="catsym">CATSYM</h3>
<p>List catalog of symbols</p>
<p>Category: Arguments</p>
<p>Format: <code>CATSYM</code> first last</p>
<p>Qualifiers: /FLT /INT /NDEC /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /NDEC=1 /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATSYM</code> displays a catalog of the currently defined symbols by name from first to last in alphabetical order. If both
arguments are omitted <code>CATSYM</code> will list all symbols. If only one argument is specified <code>CATSYM</code> will list information
about only that single symbol. Each symbol is listed by name along with its current value. Floating point symbols will
be displayed with a number of decimal places set by /NDEC.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>List floating point symbols</td>
</tr>
<tr>
<td>/INT</td>
<td>List integer symbols</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places for displaying floating point symbols</td>
</tr>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<p>Note that if neither /FLT nor /INT is specified <code>CATSYM</code> will list both, which is the same behavior as if both are
specified.</p>
<h3 id="cattbl">CATTBL</h3>
<p>List catalog of name tables</p>
<p>Category: Tables</p>
<p>Format: <code>CATTBL</code> tbl first last</p>
<p>Qualifiers: /PRT /TTY /VAL /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: none ZZZZZZZZZZZZZZZZ</p>
<p>Description:
<code>CATTBL</code> displays a catalog of the currently defined tables. A single table to display may be selected using the tbl
argument. If no tbl is specified all of the currently defined tables will be listed. /VAL will cause <code>CATTBL</code> to list
the values in the tables by name from first to last in alphabetical order. If both first and last are omitted <code>CATTBL</code>
will list all values in the tables. If only one of first and last is specified, <code>CATTBL</code> will list information about
only that single value. Each table is listed by name along with its maximum size and its current size.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/VAL</td>
<td>Also list the values in the tables</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="cd">CD</h3>
<p>Perform convolution difference apodization</p>
<p>Category: Apodization</p>
<p>Format: <code>CD</code> narrow wide wfract</p>
<p>Defaults: 0.0 0.0 0.0</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>CD</code> performs a convolution difference apodization on an FID in the visible processing buffer. The apodization function
applied to the FID is given by:</p>
<pre><code>apodization = EM(narrow) - wfract*EM(wide)
</code></pre>
<p>Note that <code>CD</code> yields the same result as separately exponentially line broadening the original FID using <code>EM</code>, scaling
the wide result using <code>SC</code> and subtracting the two resulting FID's. This apodization is useful for separating out
spectral components with greatly different line widths and for masking the effects of probe ring-down. The narrow line
broadening and the wide line broadening are expressed in the current default frequency units (as displayed and set by
<code>UNIT /FREQ /DFLT</code>). If either of these parameters are not specified, RNMR will prompt for it with 0.0 as a default.
Each linewidth entered must be between -1000 Hz and 1000 Hz, inclusive. The parameter wfract specifies the fraction of
the wide component in the apodization. This fraction is a real number between 0.0 and 1.0, inclusive. If wfract is not
specified RNMR will prompt for it with 0.0 as the default.</p>
<h3 id="chn">CHN</h3>
<p>Map logical and physical channels to one another</p>
<p>Category: Experiment</p>
<p>Format: <code>CHN</code> args</p>
<p>Qualifiers: /LOG /PHY /SEQ</p>
<p>Qualifier Defaults: /SEQ</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT) RNMRA only</p>
<p>Description:
RNMR pulse sequences specify pulses to be run on logical channels. Logical channel 1 is always the observe channel and
the other logical channels may be used for other nuclei. These logical channels are distinct from the hardware channels
in the console which are physically connected to the desired amplifiers, duplexers, and ultimately probe inputs. <code>CHN</code>
sets the mapping between the logical and physical channels, so that the pulses are generated on the right channel in the
console.</p>
<p>The /LOG and /PHY qualifiers are used to set the mapping for a single channel while the /SEQ option sets all the
channels at once. /LOG accepts two arguments: the first being a logical channel and the second being a physical channel
to map it to. /PHY works the same as /LOG but the first argument should be the physical channel and the second argument
should be the logical channel. With these qualifiers if the first argument is omitted RNMR will prompt for it with 1 as
a default. If the second argument is omitted RNMR will prompt for it with the current mapped value as a default.</p>
<p>/SEQ, which is the default qualifier, expects a sequence of physical channels consisting of up to the number of channels
in the system. The sequence of channels will be mapped to the logical channels starting from 1. For example:</p>
<pre><code>CHN 31
</code></pre>
<p>will map logical channel 1 to physical channel 3 and logical channel 2 to physical channel 1. If the sequence is omitted
RNMR will prompt for it with the current mapping sequence as a default.</p>
<h3 id="clsarv">CLSARV</h3>
<p>Close archive</p>
<p>Category: Data Storage</p>
<p>Format: <code>CLSARV</code> archive</p>
<p>Defaults: 1</p>
<p>Description:
<code>CLSARV</code> closes an archive. If no <a href="../syntax/#archives">archive</a> is specified RNMR will prompt for it with 1 as a
default. An attempt to close an archive which is not open will result in an error.</p>
<h3 id="clsexp">CLSEXP</h3>
<p>Close export file</p>
<p>Category: Foreign</p>
<p>Format: <code>CLSEXP</code></p>
<p>Description:
Close export file opened with <code>OPNEXP</code>. <code>CLSEXP</code> will error if no export file is open.</p>
<h3 id="clsimp">CLSIMP</h3>
<p>Close import file</p>
<p>Category: Foreign</p>
<p>Format: <code>CLSIMP</code></p>
<p>Description:
Close import file opened with <code>OPNIMP</code>. <code>CLSIMP</code> will error if no import file is open.</p>
<h3 id="clsplt">CLSPLT</h3>
<p>Close plotter stream and print</p>
<p>Category: Plotting</p>
<p>Format: <code>CLSPLT</code></p>
<p>Description:
<code>CLSPLT</code> writes out the current plot buffer and submits the resulting file for printing or plotting, terminating the
plot sequence that began with <code>OPNPLT</code>. All plots between <code>OPNPLT</code> and <code>CLSPLT</code> will appear as one plot.
<code>CLSPLT</code> will error if no plot is currently open. Depending on the state of the plotter flag (as set and displayed by
<code>SET PL</code>) the plot will either be saved to the plotter file (as set and displayed by <code>PLFIL</code>) or printed by the plotting
device (as set and displayed by <code>PLDEV</code>).</p>
<h3 id="clsrd">CLSRD</h3>
<p>Close file opened for read</p>
<p>Category: File IO</p>
<p>Format: <code>CLSRD</code></p>
<p>Description:
<code>CLSRD</code> closes a file opened by <code>OPNRD</code> for reading with <code>RDWRT</code>. If <code>CLSRD</code> is entered when no file is open for read,
RNMR will display an error message.</p>
<h3 id="clswrt">CLSWRT</h3>
<p>Close file which has been opened for writing</p>
<p>Category: File IO</p>
<p>Format: <code>CLSWRT</code></p>
<p>Description:
<code>CLSWRT</code> closes a file opened by <code>OPNWRT</code> for writing with the <code>WRT</code> command. All output from <code>WRT</code> commands issued
between <code>OPNWRT</code> and <code>CLSWRT</code> will appear in one file. If <code>CLSWRT</code> is entered when no file is open for write, RNMR will
display an error message.</p>
<h3 id="cmul">CMUL</h3>
<p>Multiply buffer by complex constant</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>CMUL</code> mag phi buf</p>
<p>Defaults: 1.0 0.0 1</p>
<p>Description:
<code>CMUL</code> multiplies the contents of a <a href="../syntax/#buffers">processing buffer</a> by a complex constant, updating the buffer.
This constant is specified in polar form:</p>
<pre><code>REAL(CONST) = MAG*COS(PHI*PI/2)
IMAG(CONST) = MAG*SIN(PHI*PI/2)
</code></pre>
<p>If the magnitude is omitted RNMR will not prompt for it and will use 1.0. If the phase, phi, is omitted RNMR will not
prompt for it and will use 0.0. The phase is specified in degrees. If no buffer is specified RNMR will not prompt for it
and will operate on the visible processing buffer.</p>
<h3 id="cmulv">CMULV</h3>
<p>Complex multiply two buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>CMULV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>CMULV</code> complex multiplies the contents of <a href="../syntax/#buffers">processing buffers</a> src and dst and stores the result in
dst.</p>
<pre><code>DST = DST * SRC
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="cnd">CND</h3>
<p>Set condition flag</p>
<p>Category: Misc.</p>
<p>Format: <code>CND</code> cnd state</p>
<p>Defaults: 1 current</p>
<p>Description:
<code>CND</code> sets the state of the specified condition flag to ON or OFF. The first parameter, cnd specifies which of the 64
available condition flags is to be set. Accordingly, cnd may be any integer from 1 to 64. If cnd is omitted RNMR will
prompt for it with 1 as a default. If state is omitted,RNMR will prompt for it with the current state as a default.</p>
<h3 id="cnvfl">CNVFL</h3>
<p>Convolution filter spectrum</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>CNVFL</code> kmax</p>
<p>Qualifiers: /KRNL=(GAUSS,SINEB) /PASS=(HIGH,LOW) /END=(EXT,LP,ZER)</p>
<p>Qualifier Defaults: /KRNL=GAUSS /PASS=HIGH /END=EXT</p>
<p>Defaults: 8</p>
<p>Description:
<code>CNVFL</code> convolves the data in the visible processing buffer with a filter kernel. The argument kmax sets the maximum
filter component. The filter kernel will contain nkrnl=2*kmax+1 points. If kmax is omitted RNMR will prompt for it with
8 as a default. The value of kmax can range from 1 to 32 inclusive.</p>
<p>/KRNL selects either a gaussian or sinebell function to use for the filter kernel. A convolution filter cannot calculate
values at the edges of the data. /END determines what is done with these points. The minimum size of the buffer relative
to the kernel size also depends on /END. The following options area available:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Minimum Buffer Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXT</td>
<td>Extrapolate to fill in the points</td>
<td>4*kmax+1</td>
</tr>
<tr>
<td>LP</td>
<td>Apply linear prediction to fill in the points</td>
<td>2*kmax+128</td>
</tr>
<tr>
<td>ZER</td>
<td>Set the points to 0</td>
<td>2*kmax+1</td>
</tr>
</tbody>
</table>
<p>/PASS determines what is done with the result of the convolution. /PASS=HIGH subtracts the result from the buffer while
/PASS=LOW replaces the buffer with the result.</p>
<h3 id="color">COLOR</h3>
<p>Set data display colors</p>
<p>Category: Display Control</p>
<p>Format: <code>COLOR</code> red green blue</p>
<p>Qualifiers: /BG /CURSOR /IMAG /REAL</p>
<p>Qualifier defaults: /REAL</p>
<p>Defaults: current current current</p>
<p>Description:
<code>COLOR</code> sets the color of elements of the display. /BG sets the color of the background and /CURSOR sets the color of
all cursors. /REAL and /IMAG set the color of the real and imaginary data respectively.</p>
<p>The red/green/blue values may each range from 0 to 100. That is, to specify pure red, use 100 0 0.</p>
<p>The default colors are:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default Color</th>
</tr>
</thead>
<tbody>
<tr>
<td>/BG</td>
<td>0 0 0 (Black)</td>
</tr>
<tr>
<td>/CURSOR</td>
<td>100 100 100 (White)</td>
</tr>
<tr>
<td>/REAL</td>
<td>0 100 0 (Green)</td>
</tr>
<tr>
<td>/IMAG</td>
<td>100 0 0 (Red)</td>
</tr>
</tbody>
</table>
<h3 id="conjg">CONJG</h3>
<p>Complex conjugate data</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>CONJG</code></p>
<p>Description:
<code>CONJG</code> complex conjugates the data in the visible processing buffer updating the buffer.</p>
<h3 id="conlim">CONLIM</h3>
<p>Set contour plot height limits</p>
<p>Category: Contours</p>
<p>Format: <code>CONLIM</code> min max</p>
<p>Defaults: current current</p>
<p>Description:
<code>CONLIM</code> sets intensity limits for contour plotting. Contours will only be drawn for intensities between these limits.
If either min or max is omitted from the command line, RNMR will prompt for the contour limit with its current value as
the default. If both min and max are 0.0 RNMR sets max to 1.0; min remains 0.0. If min and max are not both zero, max
must be greater than min. When a contour plot is generated, the maximum contour level will be max while the minimum
contour level will approach but not equal min.</p>
<h3 id="conmd">CONMD</h3>
<p>Set contour plotting mode</p>
<p>Category: Contours</p>
<p>Format: <code>CONMD</code> mode</p>
<p>Defaults: current</p>
<p>Description:
<code>CONMD</code> sets the contour plotting mode. The argument mode may be entered as ABS, NEG, or POS. If mode is omitted RNMR
will prompt for a contour plotting mode with the current mode as a default.</p>
<h3 id="cossq">COSSQ</h3>
<p>Perform cosine squared apodization</p>
<p>Category: Apodization</p>
<p>Format: <code>COSSQ</code> time0</p>
<p>Defaults: (size+1)*step</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>COSSQ</code> multiplies the data in the visible processing buffer by a cosine squared function which goes to zero at time0
updating the buffer.</p>
<h3 id="cpxv">CPXV</h3>
<p>Complex merge two buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>CPXV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>CPXV</code> combines the real parts of <a href="../syntax/#buffers">processing buffers</a> src and dst to form the real and imaginary
parts of dst:</p>
<pre><code>DST = COMPLEX(REAL(DST),REAL(SRC))
</code></pre>
<p>or
    REAL(DST) = REAL(DST)
    IMAG(DST) = REAL(SRC)</p>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="cpy">CPY</h3>
<p>Copy record</p>
<p>Category: Data Storage</p>
<p>Format: <code>CPY</code> src dst</p>
<p>Defaults: rrec wrec</p>
<p>Description:
<code>CPY</code> copies <a href="../syntax/#records">record</a> src into record dst. <code>CPY</code> copies both parameters and data from source to
destination. If no source <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read
record pointer (as displayed and set by <code>PTRA</code>) as a default. If no destination record is specified RNMR will not prompt
for it and will use the write record pointer (as displayed and set by <code>PTRA</code>). If the specified destination record is
already in use RNMR will use the next available record. If RNMR selects the destination record for either of the above
reasons the record number will be printed as an informational message after copying is complete.</p>
<h3 id="cpymac">CPYMAC</h3>
<p>Copy macro</p>
<p>Category: Macros</p>
<p>Format: <code>CPYMAC</code> name1 name2</p>
<p>Defaults: temp temp</p>
<p>Description
<code>CPYMAC</code> copies the contents of macro name1 into a new macro name2. If either name is omitted RNMR will prompt for it
with temp as a default.</p>
<h3 id="crs">CRS</h3>
<p>Set cursor positions</p>
<p>Category: Display Control</p>
<p>Format: <code>CRS</code> pos1 pos2</p>
<p>Defaults: current current</p>
<p>Description:
<code>CRS</code> sets the positions of the two cursors for the visible processing buffer. If either position is omitted RNMR will
prompt for it with the current cursor position as a default. The positions are specified in the current units of the
buffer. The cursors will be set to the points closest to the specified position. Thus if the position is beyond the
range of the data in the buffer the cursor will be position at the edge of the buffer.</p>
<h3 id="crsa">CRSA</h3>
<p>Set acquisition cursor positions</p>
<p>Category: Display Control</p>
<p>Format: <code>CRSA</code> pos1 pos2</p>
<p>Defaults: current current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>CRSA</code> sets the positions of the two cursors for the acquisition buffer. If either position is omitted RNMR will prompt
for it with the current cursor position as a default. The positions are specified in the current units of the buffer.
The cursors will be set to the points closest to the specified position. Thus if the position is beyond the range of the
data in the buffer the cursor will be position at the edge of the buffer.</p>
<h3 id="crtarv">CRTARV</h3>
<p>Create archive</p>
<p>Category: Data Storage</p>
<p>Format: <code>CRTARV</code> archive name</p>
<p>Defaults: 1 TEMP</p>
<p>Description:
<code>CRTARV</code> creates and opens a new <a href="../syntax/#archives">archive</a> with read/write access. If no archive is specified RNMR
will prompt for it with 1 as a default. If no name is specified RNMR will prompt for it with temp as a default.</p>
<h3 id="crtfil">CRTFIL</h3>
<p>Create text file</p>
<p>Category: File IO</p>
<p>Format: <code>CRTFIL</code> fspec</p>
<p>Qualifiers: /END=&lt;end> /TTY</p>
<p>Qualifier Defaults: /END=''</p>
<p>Defaults: temp.dat</p>
<p>Description:
<code>CRTFIL</code> creates a text file with the name fspec. /END sets a string which marks the end of what is to be written to the
file. <code>CRTFIL</code> behaves slightly differently if called at the command line or in a macro. At the command line if no file
is specified RNMR will prompt for a file with temp.dat as a default. If the file does not already exist and RNMR
succeeds in creating it, RNMR will pop up a window where text can be entered to write to the file. Otherwise an error
will be thrown.</p>
<p>When called from a macro <code>CRTFIL</code> will not prompt for a file name. The lines to be written should be provided on the
lines following <code>CRTFIL</code> in the macro and should start with ;;. The first line will be interpreted as a file name if
none is provided as an argument. <code>CRTFIL</code> will stop writing lines when it either reaches a line that matches &lt;end> or
runs out of lines. /TTY will make RNMR pop up a window much like the behavior at the command line even when <code>CRTFIL</code> is
called from a macro. RNMR will still expect the file name to passed in the same way as when /TTY is not used. An example
of use in a macro is given here:</p>
<pre><code>CRTFIL TEMP.TXT
;;Write this to temp.txt
;;Also write this
</code></pre>
<p>Text written when <code>CRTFIL</code> is called from a macro will be all caps regardless of the capitalization in the macro.</p>
<h3 id="crtlst">CRTLST</h3>
<p>Create list</p>
<p>Category: Lists</p>
<p>Format: <code>CRTLST</code> nam maxval</p>
<p>Defaults: temp 32</p>
<p>Description:
<code>CRTLST</code> creates a new list named nam that can hold a maximum of maxval entries. If no name is specified RNMR will
prompt for it with temp as a default. If no max size is specified RNMR will prompt for it with 32 as a default. If a
list with the same name already exists <code>CRTLST</code> will error.</p>
<h3 id="crtmac">CRTMAC</h3>
<p>Create macro</p>
<p>Category: Macros</p>
<p>Format: <code>CRTMAC</code> nam</p>
<p>Qualifiers: /END=&lt;end> /TTY</p>
<p>Qualifier Defaults: /END=''</p>
<p>Defaults: temp</p>
<p>Description:
<code>CRTMAC</code> creates a macro with name nam. /END sets a string which marks the end of what is to be written to the macro.
<code>CRTMAC</code> behaves slightly differently if called at the command line or in a macro. At the command line if no name is
specified RNMR will prompt for a name with temp as a default. If the macro does not already exist and RNMR succeeds
in creating it, RNMR will pop up a window where text can be entered to write to the macro. Otherwise an error will be
thrown.</p>
<p>When called from a macro <code>CRTMAC</code> will not prompt for a macro name. The lines to be written should be provided on the
lines following <code>CRTMAC</code> in the macro and should start with ;;. The first line will be interpreted as a macro name if
none is provided as an argument. <code>CRTMAC</code> will stop writing lines when it either reaches a line that matches &lt;end> or
runs out of lines. /TTY will make RNMR pop up a window much like the behavior at the command line even when <code>CRTMAC</code> is
called from a macro. RNMR will still expect the macro name to passed in the same way as when /TTY is not used. An
example of use in a macro is given here:</p>
<pre><code>CRTmac TEMP
;;This will me in macro temp
;;so will this
</code></pre>
<p>Text written when <code>CRTMAC</code> is called from a macro will be all caps regardless of the capitalization in the macro.</p>
<h3 id="crttbl">CRTTBL</h3>
<p>Create name table</p>
<p>Category: Tables</p>
<p>Format: <code>CRTTBL</code> nam maxval</p>
<p>Defaults: temp 32</p>
<p>Description:
<code>CRTTBL</code> creates a new name table named nam that can hold a maximum of maxval entries. If no name is specified RNMR will
prompt for it with temp as a default. If no max size is specified RNMR will prompt for it with 32 as a default. If a
name table with the same name already exists <code>CRTTBL</code> will error.</p>
<h3 id="cvtmd">CVTMD</h3>
<p>Set modes for blocked record index conversion</p>
<p>Category: Blocked Records</p>
<p>Format: <code>CVTMD</code> sizmd blkmd</p>
<p>Defaults: current current</p>
<p>Description:
<code>CVTMD</code> sets modes for blocked record index conversion. The first parameter, sizmd is the record size conversion mode.
If sizmd is omitted, RNMR will prompt for a mode with the current size conversion mode as the default. The legal choices
for sizmd are SIZEA, SIZE, and CVTSZ. The second parameter, blkmd is the record blocking conversion mode. If blkmd is
omitted, RNMR will prompt for a mode with the current mode as the default. The legal values for blkmd are 0, 1, 2, 3, or
4.</p>
<h3 id="cvtsz">CVTSZ</h3>
<p>Set sizes for blocked record index conversion</p>
<p>Category: Blocked Records</p>
<p>Format: <code>CVTSZ</code> ndim size(1) size(2) size(3) size(4)</p>
<p>Defaults: 2 current current current current</p>
<p>Description:
<code>CVTSZ</code> sets the sizes for a blocked record index conversion. The first parameter, ndim is the number of dimensions for
the conversion. If ndim is not specified RNMR will prompt for its value with a default value of 2. The number of
dimensions may be from 1 to 4 inclusive. The remaining parameters are the sizes in each of the dimensions. If one or
more of these is omitted RNMR will prompt for its value with the current conversion size in the appropriate dimension as
a default.</p>
<h3 id="cvtunit">CVTUNIT</h3>
<p>Convert a value between units</p>
<p>Category: Misc.</p>
<p>Format: <code>CVTUNIT</code> srcunit dstunit val</p>
<p>Description:
<code>CVTUNIT</code> converts a value from srcunit to dstunit. If either unit is omitted RNMR will prompt for it with the current
unit of the visible processing buffer as a default. Both units must be the same domain. If no value is specified RNMR
will prompt for it with 0.0 as a default. The result of the conversion is printed as an informational message.</p>
<h2 id="d">D</h2>
<hr />
<h3 id="d_1">D</h3>
<p>Set pulse programmer delay</p>
<p>Category: Pulse Control</p>
<p>Format: <code>D</code> dly msec</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>D</code> is an old command for setting the length of pulse program delays. It has been replaced with the <code>DLY</code> command and is
currently simply an alias to it. As such <code>DLY</code> should be used in place of <code>D</code>.</p>
<h3 id="date">DATE</h3>
<p>Print the current date and time as an informational message</p>
<p>Category: Misc.</p>
<p>Format: <code>DATE</code></p>
<p>Qualifiers: /DATE /TIME /EPOCH</p>
<p>Qualifier Defaults: /DATE /TIME</p>
<p>Description:
<code>DATE</code> prints information about the current date and time as informational messages. The following pieces of information
are printed depending on the qualifiers that are used.</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>/DATE</td>
<td>The current date</td>
</tr>
<tr>
<td>/TIME</td>
<td>The current time of day</td>
</tr>
<tr>
<td>/EPOCH</td>
<td>The current Unix epoch time</td>
</tr>
</tbody>
</table>
<p>By default <code>DATE</code> prints the date and time of day.</p>
<h3 id="dbsz">DBSZ</h3>
<p>Set processing buffer partitioning</p>
<p>Category: Misc.</p>
<p>Format: <code>DBSZ</code> buf size nblk</p>
<p>Defaults: 1 current current</p>
<p>Description:
<code>DBSZ</code> sets up the partitioning of a <a href="../syntax/#buffers">processing buffer</a> into blocks. The number of blocks and the
block size for the specified buffer will be set. This allows loading and processing multiple data sets in the processing
buffer at once. This can reduce the overhead from interpreting RNMR commands when processing a large number of data
sets. The buffer will be zeroed after it is partitioned.</p>
<p>If no buffer is specified RNMR will prompt for it with 1 (the visible processing buffer) as a default. If the size or
number of blocks is omitted RNMR will prompt for them with their current values. If the specified size is not a power of
two the actual block size will be the next power of 2. The total combined size of all of the blocks must not exceed the
maximum buffer size of 32768. If the size is set to 0 RNMR will use the maximum possible block size of 32768. If the
number of blocks is set to 0 RNMR will use the largest possible number of blocks such that the total size does not
exceed the maximum buffer size.</p>
<h3 id="dcdb">DCDB</h3>
<p>Convert block indices to values</p>
<p>Category: Blocked Records</p>
<p>Format: <code>DCDB</code> rec ndim ind</p>
<p>Defaults: rrec 1 1</p>
<p>Description:
<code>DCDB</code> decodes a linear block index ind into a vector of actual values representing positions in each dimension of a
<a href="../syntax/#blocked_records">blocked record</a>. The conversion uses information about the block layout of a record to
perform this conversion. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current
read record pointer (as displayed and set by <code>PTRA</code>) as a default. For example when used on a dataset from a multi
dimensional experiment stored as a blocked record, <code>DCDB</code> will convert a linear block index into indirect dimension
time values. </p>
<p>The second parameter, ndim, specifies how many dimensions are accounted for before the linear index. For example in a 3D
data set ndim set to 1 will indicate that only the direct dimension is already accounted for and the linear index is
over the last two dimensions. The result will be two values corresponding to the positions in the other two dimensions.
A value of 2 on the other hand would consider the linear index to only be over the final dimension and only one value
will be printed. If ndim is omitted RNMR will prompt for it with 1 as a default. The value of ndim must be greater than
0 and less than the number of dimensions in the blocked record.</p>
<p>If no index is specified RNMR will prompt for it with 1 as a default. The value of ind must not exceed the product of
the sizes of the dimensions that the linear index is over. For example in a 3D data set with 32X64 blocks ind can be up
to 2048 when ndim is 1 but only up to 64 if ndim is 2.</p>
<h3 id="dcdbp">DCDBP</h3>
<p>Convert linear block index to vector indices</p>
<p>Category: Blocked Records</p>
<p>Format: <code>DCDBP</code> rec ndim ind</p>
<p>Defaults: last_read 1 1</p>
<p>Description:
<code>DCDBP</code> converts a linear block index ind into a vector of individual indices representing each blocked dimension in a
<a href="../syntax/#blocked_records">blocked record</a>. The conversion uses information about the block layout of a record to
perform this conversion. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current
read record pointer (as displayed and set by <code>PTRA</code>) as a default.</p>
<p>The second parameter, ndim, specifies how many dimensions are accounted for before the linear index. For example in a 3D
data set ndim set to 1 will indicate that only the direct dimension is already accounted for and the linear index is
over the last two dimensions. The result will be two values corresponding to the indexes in the other two dimensions. A
value of 2 on the other hand would consider the linear index to only be over the final dimension and only one index will
be printed. If ndim is omitted RNMR will prompt for it with 1 as a default. The value of ndim must be greater than 0 and
less than the number of dimensions in the blocked record.</p>
<p>If no index is specified RNMR will prompt for it with 1 as a default. The value of ind must not exceed the product of
the sizes of the dimensions that the linear index is over. For example in a 3D data set with 32X64 blocks ind can be up
to 2048 when ndim is 1 but only up to 64 if ndim is 2.</p>
<h3 id="dcdrec">DCDREC</h3>
<p>Convert record number into archive and archive record index</p>
<p>Category: Data Storage</p>
<p>Format: <code>DCDREC</code> rec</p>
<p>Defaults: 1</p>
<p>Description:
<code>DCDREC</code> prints the <a href="../syntax/#archives">archive</a> and <a href="../syntax/#records">record number</a> within that archive of a
specified record. If no record is specified RNMR will prompt for it with 1 as a default.</p>
<h3 id="dcl">DCL</h3>
<p>Execute a shell command in background</p>
<p>Category: Misc.</p>
<p>Format: <code>DCL</code> cmd</p>
<p>Defaults none</p>
<p>Description:
<code>DCL</code> spawns a subprocess to execute a single shell command. This command is useful for performing background tasks
which do not require a separate terminal session. <code>DCL</code> also allows a macro to compose and execute commands
transparently.</p>
<p>When <code>DCL</code> command is used at console level and the command is omitted RNMR will prompt for it with no default. When
<code>DCL</code> is used from within a macro RNMR expects the command to be delimited by two semicolons on the line following
<code>DCL</code>. The entire line after ;; constitutes the command string, as illustrated below:</p>
<pre><code>DCL
;;CP XYZ.DAT NEW_NAME.DAT
</code></pre>
<p>If no command is entered when prompted for, the double semicolon delimiter ;; is not found on the line after <code>DCL</code>, or
there are no characters on the line following ;;, <code>DCL</code> does not spawn a subprocess and does nothing.</p>
<p>The subprocess created by <code>DCL</code> is unable to either read from or write to the terminal. Consequently, any attempt by the
spawned process to read from the terminal will result in an immediate end of file during read condition, and any data
directed to the terminal will be lost. While the subprocess is executing the specified command, no new RNMR commands may
be entered. During execution, &lt;CTRL-Z> may not be used to cancel the subprocess, but any acquisition in progress
continues without interruption. If the subprocess exits on error, RNMR will display an error message indicating the
error condition returned. If <code>DCL</code> was called from within a macro, the current macro error handler (as set by <code>ONERR</code>)
is executed.</p>
<h3 id="depake">DEPAKE</h3>
<p>Perform depaking of powder pattern spectrum</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>DEPAKE</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>DEPAKE</code> applies a depaking routine to the visible processing buffer to remove the effects of a pake pattern from the
spectrum. The visible processing buffer must contain frequency domain data and its size must be a power of 2.</p>
<h3 id="df">DF</h3>
<p>Differentiate data</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>DF</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>DF</code> differentiates the data in the visible processing buffer. Differentiation of a spectrum is often useful in
resolving subtle features on broad lines since inflection points on the source spectrum become peaks in its derivative.</p>
<h3 id="dflgbl">DFLGBL</h3>
<p>Define global argument with default value</p>
<p>Category: Arguments</p>
<p>Format: <code>DFLGBL</code> nam val prompt</p>
<p>Qualifiers: /FLT /INT /NDEC /STR</p>
<p>Qualifier Defaults: /NDEC=1 /STR</p>
<p>Defaults: temp none none</p>
<p>Description:
If a global argument with name nam already exists <code>DFLGBL</code> will do nothing, otherwise it will create a global argument
named nam. If nam is omitted RNMR will prompt for it with TEMP as a default. If no prompt is provided then <code>DFLGBL</code> will
create the argument with value val, otherwise it will prompt the user to enter a value with val as the default.</p>
<p>The qualifiers influence how <code>DFLGBL</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/STR</td>
<td>Treat val as a string</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFLGBL /INT A 2*(2-1)
</code></pre>
<p>will create global argument a with a value of 2.</p>
<h3 id="dfllcl">DFLLCL</h3>
<p>Define local argument with default value</p>
<p>Category: Arguments</p>
<p>Format: <code>DFLLCL</code> nam val prompt</p>
<p>Qualifiers: /FLT /INT /NDEC /STR</p>
<p>Qualifier Defaults: /NDEC=1 /STR</p>
<p>Defaults: temp none none</p>
<p>Description:
If a local argument with name nam already exists <code>DFLLCL</code> will do nothing, otherwise it will create a local argument
named nam. If nam is omitted RNMR will prompt for it with TEMP as a default. If no prompt is provided then <code>DFLLCL</code> will
create the argument with value val, otherwise it will prompt the user to enter a value with val as the default.</p>
<p>The qualifiers influence how <code>DFLLCL</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/STR</td>
<td>Treat val as a string</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFLLCL /INT A 2*(2-1)
</code></pre>
<p>will create local argument a with a value of 2.</p>
<h3 id="dflt">DFLT</h3>
<p>Prompt for local variable with default</p>
<p>Category: Arguments</p>
<p>Format: <code>DFLT</code> lclnam lclval prompt</p>
<p>Defaults: TEMP none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>DFLT</code> is an old command for creating a local variable if one does not already exist with an optional prompt. It has
been replaced with the <code>DFLLCL</code> command and is currently simply an alias to it. As such <code>DFLLCL</code> should be use in place
of <code>DFLT</code>.</p>
<h3 id="dfltbl">DFLTBL</h3>
<p>Define name table argument with default value</p>
<p>Category: Tables</p>
<p>Format: <code>DFLTBL</code> tbl nam val prompt</p>
<p>Qualifiers: /FLT /INT /NDEC /STR</p>
<p>Qualifier Defaults: /NDEC=1 /STR</p>
<p>Defaults: temp temp none none</p>
<p>Description:
If name table tbl already has an argument with name nam <code>DFLTBL</code> will do nothing, otherwise it will create an argument
named nam in tbl. If tbl or nam is omitted RNMR will prompt for it with TEMP as a default. If no prompt is provided then
<code>DFLTBL</code> will create the argument with value val, otherwise it will prompt the user to enter a value with val as the
default.</p>
<p>The qualifiers influence how <code>DFLTBL</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/STR</td>
<td>Treat val as a string</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFLTBL /INT A B 2*(2-1)
</code></pre>
<p>will create argument a in name table b with a value of 2.</p>
<h3 id="dfngbl">DFNGBL</h3>
<p>Define global argument</p>
<p>Category: Arguments</p>
<p>Format: <code>DFNGBL</code> nam val</p>
<p>Qualifiers: /FLT /INT /NDEC /STR</p>
<p>Qualifier Defaults: /NDEC=1 /STR</p>
<p>Defaults: temp current</p>
<p>Description:
<code>DFNGBL</code> creates a global argument with name nam and value val. If nam is not provided RNMR will prompt for it with a
default of temp. If val is not provided RNMR will prompt for it with the current value of global argument nam as the
default.</p>
<p>The qualifiers influence how <code>DFNGBL</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/STR</td>
<td>Treat val as a string</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFNGBL /INT A 2*(2-1)
</code></pre>
<p>will create global argument a with a value of 2.</p>
<h3 id="dfnlcl">DFNLCL</h3>
<p>Define local argument</p>
<p>Category: Arguments</p>
<p>Format: <code>DFNLCL</code> nam val</p>
<p>Qualifiers: /FLT /INT /NDEC /STR</p>
<p>Qualifier Defaults: /NDEC=1 /STR</p>
<p>Defaults: temp current</p>
<p>Description:
<code>DFNLCL</code> creates a local argument with name nam and value val. If nam is not provided RNMR will prompt for it with a
default of temp. If val is not provided RNMR will prompt for it with the current value of local argument nam as the
default.</p>
<p>The qualifiers influence how <code>DFNLCL</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/STR</td>
<td>Treat val as a string</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFNLCL /INT A 2*(2-1)
</code></pre>
<p>will create local argument a with a value of 2.</p>
<h3 id="dfnlst">DFNLST</h3>
<p>Define list value</p>
<p>Category: Lists</p>
<p>Format: <code>DFNLST</code> nam pos val</p>
<p>Defaults: temp 1 current</p>
<p>Description:
<code>DFNLST</code> sets the value at position pos in list nam. If nam is not provided RNMR will prompt for it with a default of
temp. If pos is not provided RNMR will prompt for it with a default of 1. If val is not provided RNMR will prompt for it
with the current value at position pos in list nam as the default.</p>
<h3 id="dfnmac">DFNMAC</h3>
<p>Define macro table entry</p>
<p>Category: Macros</p>
<p>Format: <code>DFNMAC</code> nam eqvnam</p>
<p>Qualifiers: /FORCE /SYS /USR</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: temp none</p>
<p>Description:
<code>DFNMAC</code> defines an entry in the macro table. The parameter nam specifies the name of the macro. If nam is omitted RNMR
will prompt for it with temp as a default. The parameter eqvnam sets an equivalence name used for looking up the macro
file. The first time a macro is used in an RNMR session it is loaded from a file. When loading the macro RNMR will
search for a file as if it were named eqvnam. /FORCE purges the macro entry for nam if it already exists and then
defines a new entry in its place. This will force RNMR to reload the macro from its file. This makes any changes made to
the macro file by an external text editor available to RNMR.</p>
<p>/SYS and /USR can be used to manually set whether the macro is a system or user macro. If neither of these qualifiers is
used RNMR will first search for the macro file in the user macro folders. If the file is found the macro is a user
macro; otherwise it is a system macro. Note that <code>DFNMAC</code> does not actually search the system macro folders. No search
for the file occurs if the type is specified manually. Thus if the file does not exist an error will not occur until the
first time the macro is called.</p>
<h3 id="dfnsym">DFNSYM</h3>
<p>Define symbol</p>
<p>Category: Arguments</p>
<p>Format: <code>DFNSYM</code> nam val</p>
<p>Qualifiers: /FLT /INT /NDEC</p>
<p>Qualifier Defaults: /INT /NDEC=1</p>
<p>Defaults: temp current</p>
<p>Description:
<code>DFNSYM</code> creates a symbol with name nam and value val. If nam is not provided RNMR will prompt for it with a
default of temp. If val is not provided RNMR will prompt for it with the current value of symbol nam as the
default.</p>
<p>The qualifiers influence how <code>DFNSYM</code> interprets val as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Treat val as a floating point number</td>
</tr>
<tr>
<td>/INT</td>
<td>Treat val as an integer</td>
</tr>
<tr>
<td>/NDEC</td>
<td>Set the number of decimal places to keep in /FLT mode</td>
</tr>
</tbody>
</table>
<p>When using /FLT or /INT basic arithmetic operations may be performed (+, - , /, *). They will be performed in order
from left to right without regard for order of operations except for parentheses. For example:</p>
<pre><code>DFNSYM /INT A 2*(2-1)
</code></pre>
<p>will create symbol a with a value of 2.</p>
<h3 id="dfntbl">DFNTBL</h3>
<p>Define name table argument</p>
<p>Category: Tables</p>
<p>Format: <code>DFNTBL</code> tbl nam val</p>
<p>Defaults: temp temp current</p>
<p>Description:
<code>DFNTBL</code> sets the value of argument nam in table tbl. If tbl or nam is not provided RNMR will prompt for it with a
default of temp. If val is not provided RNMR will prompt for it with the current value of argument nam in table tbl as
the default.</p>
<h3 id="dfnpps">DFNPPS</h3>
<p>Define pulse programmer symbol table entry</p>
<p>Category: Pulse Program Symbols</p>
<p>Format: <code>DFNPPS</code> typ nam val</p>
<p>Defaults: temp temp current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>DFNPPS</code> sets the value of the pulse programmer symbol of type typ and name nam. If typ or nam is not provided RNMR will
prompt for it with a default of temp. If val is not provided RNMR will prompt for it with the current value of the pulse
programmer symbol of type typ and name nam as the default.</p>
<h3 id="dg">DG</h3>
<p>Start acquisition with delay shots</p>
<p>Category: Acquisition</p>
<p>Format: <code>DG</code> first_group last_group</p>
<p>Defaults: 1 0</p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>DG</code> zeroes the averager and shot counter then <a href="../syntax/#acquisition">starts acquisition</a> with dummy scans. The dummy
scans allow the initial magnetization to reach an equilibrium based on relaxation rates and the recycle delay before
averaging begins. The number of dummy scans is set by <code>NDLY</code>.</p>
<p>The arguments first_group and last_group specify the range of <a href="../syntax/#acqgrp">acquisition groups</a> to acquire. If
either parameter is omitted RNMR will not prompt for it and will use 1 and 0 as defaults respectively. If last_group is
set to 0 then only first_group will be acquired.</p>
<h3 id="dirb">DIRB</h3>
<p>Set blocked record access sequence</p>
<p>Category: Blocked Records</p>
<p>Format: <code>DIRB</code> ndim seq</p>
<p>Defaults: 2 current</p>
<p>Description:
<code>DIRB</code> sets the order in which the dimensions of a <a href="../syntax/#blocked_records">blocked record</a> are accessed. When
commands access a blocked record along some number of dimensions, they access the first n directions. These directions
are not necessarily the same as the first dimensions. The mapping of dimensions to directions is set independently for
each dimensionality by <code>DIRB</code>.</p>
<p>The first parameter, ndim, is the dimensionality to set the mappinng for. If ndim is omitted, RNMR will prompt for it
with 2 as a default.</p>
<p>The second parameter, seq, assigns each dimension a direction. If this parameter is omitted, RNMR will prompt for it
with the current sequence for ndim dimensions as the default. This sequence is a string of ndim integers from 1 to ndim
with no repeats. If seq fails to assign each dimension a direction, then RNMR completes the sequence with the missing
dimensions in ascending order.</p>
<h3 id="dl">DL</h3>
<p>Delete records</p>
<p>Category: Data Storage</p>
<p>Format: <code>DL</code> first-rec last-rec</p>
<p>Defaults: wrec none</p>
<p>Description:
<code>DL</code> deletes records from first-rec to last-rec within a single archive. <code>DL</code> takes two parameters, which are the first
and last <a href="../syntax/#records">record numbers</a> to be deleted. If first-rec is omitted RNMR will prompt for it with the
current write record pointer (as displayed and set by <code>PTRA</code>) as a default. If first-rec is set to record 0 (which does
not exist) in an archive, all of the records in that archive up to last-rec will be deleted. In this case if last-rec is
omitted all the records in the archive are deleted. If first-rec is set to any other value and last-rec is omitted only
that record will be deleted. The value of last-rec should be specified by the number within the archive even if it is
not in archive 1.</p>
<p>Deleting records marks the appropriate title records and blocks of the data file as available for reuse. Neither the
size of the title file nor the data file is reduced by <code>DL</code>; to compress the data file by eliminating deallocated
blocks use <code>SQZ</code>.</p>
<h3 id="dltfil">DLTFIL</h3>
<p>Delete file</p>
<p>Category: File IO</p>
<p>Format: <code>DLTFIL</code> file</p>
<p>Defaults: temp.dat</p>
<p>Description:
<code>DLTFIL</code> deletes a specified file. If no file is provided RNMR will prompt for a file to delete with temp.dat as a
default. Be cautious when using <code>DLTFIL</code> as RNMR will not prompt for confirmation and will permanently delete the
specified file.</p>
<h3 id="dltlst">DLTLST</h3>
<p>Delete list</p>
<p>Category: Lists</p>
<p>Format: <code>DLTLST</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>DLTLST</code> deletes a specified list. If no list is provided RNMR will prompt for a list to delete with temp as a default.</p>
<h3 id="dltmac">DLTMAC</h3>
<p>Delete list</p>
<p>Category: Macros</p>
<p>Format: <code>DLTMAC</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>DLTMAC</code> deletes a specified macro. If no macro is provided RNMR will prompt for a macro to delete with temp as a
default. <code>DLTMAC</code> will delete the file in which the macro is stored. To Remove the macro from RNMR without deleting the
file use <code>REMMAC</code>.</p>
<h3 id="dlttbl">DLTTBL</h3>
<p>Delete name table</p>
<p>Category: Tables</p>
<p>Format: <code>DLTTBL</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>DLTTBL</code> deletes a specified name table. If no table is provided RNMR will prompt for a table to delete with temp as a
default.</p>
<h3 id="dly">DLY</h3>
<p>Set pulse programmer delay</p>
<p>Category: Pulse Control</p>
<p>Format: <code>DLY</code> name time</p>
<p>Qualifiers: /DLY /PLS</p>
<p>Qualifier Defaults: /DLY</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>DLY</code> sets the length of a pulse program delay indicated by name. /DLY will interpret time in milliseconds while /PLS
will interpret time in microseconds. The length of a delay can range from 0 to 40 seconds. A pulse program must be
loaded using <code>PPEX</code> in order for <code>DLY</code> to be used to set the length of any delays.</p>
<p>Due to restrictions on the speed of the pulse programmer delays are rounded to the nearest 10 microseconds. Delays may
be entered with more precision than this limit, but the additional precision will have no effect on the actual length of
the delay.</p>
<h3 id="do">DO</h3>
<p>Begin macro <code>DO</code> loop</p>
<p>Category: Control Flow</p>
<p>Format: <code>DO</code>  beg end nam</p>
<p>Qualifiers: /GBL /LCL /SYM</p>
<p>Qualifier defaults: /LCL</p>
<p>Defaults: 1 <beg> none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>DO</code> begins a <code>DO</code> loop in a macro. All macro commands between <code>DO</code> and <code>ENDDO</code> will be repeated according to the
user's specifications for beg and end. The loop counter will have the value beg on the first pass through the do loop.
It will be incremented by one on each subsequent pass and will have the value of end on the final pass. Thus beg and end
specify how many time to execute the loop. If beg is omitted it will be set to 1. If end is omitted it will be set to
beg (i.e. one cycle will be done). If end is less than beg no pass through the <code>DO</code> loop will occur. Both beg and end
must be integers.</p>
<p>Optionally, <code>DO</code> may create and increment a local argument, global argument, or symbol to store the current iteration
count by specifying nam. The type of this loop counter is selected by the qualifiers and by default it will be a local
argument. If nam is omitted no loop counter variable will be created. Note that any modifications to this
variable by commands between <code>DO</code> and <code>ENDDO</code> will not affect the number of repetitions.</p>
<p><code>DO</code> loops may be nested up to a depth of 16. Jumps out of <code>DO</code> loops are permitted, but a jump into a <code>DO</code> loop is not
allowed except as part of an extended range. It is legal to jump out of a <code>DO</code>/<code>ENDDO</code> loop then jump back in again
after executing one or more statements. The range of the <code>DO</code>/<code>ENDDO</code> loop is thus extended to include all the
statements after the jump out and before the jump back in. Jumps into a <code>DO</code> loop are not allowed when that <code>DO</code>
command has not yet been processed, though the error will not be detected until the matching <code>ENDDO</code> statement is
executed.</p>
<h3 id="dw">DW</h3>
<p>Set dwell time for data sampling during acquisition</p>
<p>Category: Experiment</p>
<p>Format: <code>DW</code> time</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>DW</code> sets the dwell time for analog-to-digital conversion, in microseconds. The dwell time is defined to be the time
per point used in digitizing the FID. This time is related to the sweep width after Fourier transformation by:</p>
<pre><code>SW=1.0E+06/DW.
</code></pre>
<p>If no dwell time is specified RNMR will prompt for it with the current dwell time as a default. Note that although pulse
lengths are specified only to one decimal place in microseconds, dwell times are considered precise to 0.01 usec. The
dwell time may be adjusted to meet certain analog-to-digital converter (ADC) restrictions. If RNMR is forced to adjust
the dwell time, an informational message is displayed reporting the adjusted dwell time.</p>
<p>On spectrometers with audio filters under computer control via S-bus, changing the dwell time resets the filter cutoff
frequencies. The filter setting is identical for the real and imaginary channels. Since the filter frequencies are
digitally programmed, only discrete cutoff values (in increments of 200.0 Hz up to 50000.0 Hz) are allowed. Accordingly,
RNMR sets the filters to the closest available values given the new dwell time and the current filter factor (as
displayed and set by <code>FLF</code>). If the filter factor is 0.0, then the filters are disabled entirely. Otherwise, they are
set to the nearest cutoff setting at least as wide as FLF X (SW/2.0). If the calculated filter bandwidth exceeds
50000.0 Hz, then the filters are disabled entirely. Whenever the dwell time is changed, the shot counter and averager
are zeroed.</p>
<h2 id="e">E</h2>
<hr />
<h3 id="ecdb">ECDB</h3>
<p>Convert dimension values to linear block index</p>
<p>Category: Blocked Records</p>
<p>Format: <code>ECDB</code> rec ndim val...</p>
<p>Defaults: rrec 1 first...</p>
<p>Description:
<code>ECDB</code> encodes a series of values (val...) corresponding to positions in each block dimension of a
<a href="../syntax/#blocked_records">blocked record</a> into a linear block index. The conversion uses information about the block
layout of a record to perofrm the conversion. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt
for it with the current read record pointer (as displayed and set by <code>PTRA</code>) as a default. For example when used on a
dataset from an unprocessed multi dimensional experiment stored as a blocked record, <code>ECDB</code> will convert a set of
indirect dimension time values into a linear block index.</p>
<p>The second parameter, ndim, specifies how many dimensions are accounted for before the linear index. For example in a 3D
data set ndim set to 1 will indicate that only the direct dimension is already accounted for and the linear index is
over the last two dimensions. The arguments will be two values corresponding to the positions in the other two
dimensions. A value of 2 on the other hand would consider the linear index to only be over the final dimension and only
one value will be used. If ndim is omitted RNMR will prompt for it with 1 as a default. The value of ndim must be
greater than 0 and less than the number of dimensions in the blocked record.</p>
<p>If fewer values are provided than are needed for the conversion RNMR will prompt for the remaining values with the value
corresponding to the first point in the relevant dimension as the default. The values will be rounded to the nearest
point in the block grid for conversion. Values that are outside of the range of dataset will round to the point on the
edge of the dataset.</p>
<h3 id="ecdbp">ECDBP</h3>
<p>Convert vector indices to linear block index</p>
<p>Category: Blocked Records</p>
<p>Format: <code>ECDBP</code> rec ndim ind...</p>
<p>Defaults: rrec 1 1...</p>
<p>Description:
<code>ECDBP</code> encodes a series of indices (ind...) corresponding to positions in each block dimension of a
<a href="../syntax/#blocked_records">blocked record</a> into a linear block index. The conversion uses information about the block
layout of a record to perofrm the conversion. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt
for it with the current read record pointer (as displayed and set by <code>PTRA</code>) as a default.</p>
<p>The second parameter, ndim, specifies how many dimensions are accounted for before the linear index. For example in a 3D
data set ndim set to 1 will indicate that only the direct dimension is already accounted for and the linear index is
over the last two dimensions. The arguments will be two indices corresponding to the positions in the other two
dimensions. A value of 2 on the other hand would consider the linear index to only be over the final dimension and only
one index will be used. If ndim is omitted RNMR will prompt for it with 1 as a default. The value of ndim must be
greater than 0 and less than the number of dimensions in the blocked record.</p>
<p>If fewer indices are provided than are needed for the conversion RNMR will prompt for the remaining values with 1 as a
default. The indices must not exceed the size of the dataset.</p>
<h3 id="ecdrec">ECDREC</h3>
<p>Encode archive index</p>
<p>Category: Data Storage</p>
<p>Format: <code>ECDREC</code> arv rec</p>
<p>Defaults: 1 1</p>
<p>Description:
<code>ECDREC</code> takes an <a href="../syntax/#archives">archive</a> and a <a href="../syntax/#records">record number</a> within that archive and
encodes it in a form that can be used to access that record. For example:</p>
<pre><code>ECDREC 2 7
</code></pre>
<p>will print 2:7 as informational message. 2:7 can be used anywhere a record must be specified to refer to record 7 in
archive 2. RNMR will prompt for both the archive and record number with a default of 1 if they are not specified.</p>
<h3 id="echo">ECHO</h3>
<p>Rearrange buffer to simulate echo data</p>
<p>Category: Signal Generation</p>
<p>Format: <code>ECHO</code> time</p>
<p>Defaults: center</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>ECHO</code> takes an FID in the visible processing buffer it and simulates an echo signal from it. The original FID will be
shifted to the right by an amount specified by time. The portion of the buffer vacated by this shift is filled with the
complex conjugate of the reverse of the data that was in this region in the original FID. If time is not provided RNMR
will prompt for it with a time value corresponding to the center of the buffer.</p>
<h3 id="edtfil">EDTFIL</h3>
<p>Edit text file</p>
<p>Category: File IO</p>
<p>Format: <code>EDTFIL</code> fspec</p>
<p>Defaults: temp.dat</p>
<p>Description:
<code>EDTFIL</code> opens a pop up window to edit the text file specified by fspec. If no file is specified RNMR will prompt for
one with temp.dat as a default.</p>
<h3 id="edtlst">EDTLST</h3>
<p>Edit list</p>
<p>Category: Lists</p>
<p>Format: <code>EDTLST</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>EDTLST</code> opens a pop up window to edit the list specified by nam. If no list is specified RNMR will prompt for one with
temp as a default.</p>
<h3 id="edtmac">EDTMAC</h3>
<p>Edit macro</p>
<p>Category: Macros</p>
<p>Format: <code>EDTMAC</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>EDTMAC</code> opens a pop up window to edit the macro specified by nam. If no macro is specified RNMR will prompt for one
with temp as a default.</p>
<h3 id="elstst">ELSTST</h3>
<p>Separate the code blocks after a <code>TST</code> check</p>
<p>Category: Control Flow</p>
<p>Format: <code>ELSTST</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ELSTST</code> separates the two blocks of commands to be executed based upon the results of a conditional test using <code>TST</code>.
For usage details see the description of <code>TST</code>.</p>
<h3 id="em">EM</h3>
<p>Exponential multiply FID</p>
<p>Category: Apodization</p>
<p>Format: <code>EM</code> lb</p>
<p>Qualifiers: /PROMPT</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: current</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>EM</code> performs exponential multiplication apodization on an FID in the visible processing buffer. In this apodization,
the FID is multiplied by a decaying real exponential function. This results in a broadening of spectral lines after
Fourier transformation which masks noise at the expense of resolution. When a perfect, non-decaying complex sine wave
is exponentially multiplied and Fourier transformed, the result is a perfect Lorentzian line-shape. </p>
<p><code>EM</code> takes one argument, lb, which is the line broadening factor. This parameter is expressed in the current frequency
units (Hz, kHz, or MHz) unless that unit is ppm in which case it is in the default frequency units. The value of lb must
be between -1000 and 1000. If lb is omitted, RNMR will not prompt for a value unless the /PROMPT qualifier is used and
will perform the apodization with the global line broadening factor, as set and displayed by the command <code>LB</code>. If a
legal value of lb is specified, the global line broadening factor will be updated before exponential multiplication of
the data. <code>EM</code> multiplies each block of processing buffer 1 by the real function:</p>
<pre><code>F(I) = EXP(-PI*(I-1) * LB/SW)
</code></pre>
<p>where I is the index of the data point (I=1,2,...), LB is the line broadening factor, and SW is the buffer sweep width.</p>
<h3 id="enddo">ENDDO</h3>
<p>End a macro <code>DO</code> loop</p>
<p>Category: Control Flow</p>
<p>Format: <code>ENDDO</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ENDDO</code> marks the end of a macro <code>DO</code> loop. All commands between <code>DO</code> and <code>ENDDO</code> are executed repeatedly according to
the parameters of the <code>DO</code> command. For usage details see the description of <code>DO</code>.</p>
<h3 id="endsel">ENDSEL</h3>
<p>End a macro <code>SEL</code> block</p>
<p>Category: Control Flow</p>
<p>Format: <code>ENDSEL</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ENDSEL</code> marks the end of a macro <code>SEL</code> block. All <code>CASE</code> commands for the <code>SEL</code> block must precede <code>ENDSEL</code>. For usage
details see the description of <code>SEL</code>.</p>
<h3 id="endtst">ENDTST</h3>
<p>End a macro <code>TST</code> block</p>
<p>Category: Control Flow</p>
<p>Format: <code>ENDTST</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ENDTST</code> marks the end of a <code>TST</code> block used for conditional execution of commands. For usage details see the
description of <code>TST</code>.</p>
<h3 id="ex">EX</h3>
<p>Load a pulse program experiment</p>
<p>Category: Experiment</p>
<p>Format: <code>EX</code> nam</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT), RNMRA only</p>
<p>Description:
<code>EX</code> is an old command for loading a pulse program. It has been replaced with the <code>PPEX</code> command and is currently simply
an alias to it. As such <code>PPEX</code> should be used in place of <code>EX</code>.</p>
<h3 id="exit">EXIT</h3>
<p>Exit program</p>
<p>Category: Misc.</p>
<p>Format: <code>EXIT</code> resp</p>
<p>Qualifiers: /ERROR</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: no</p>
<p>Prerequisites: Command line only</p>
<p>Description
<code>EXIT</code> exits RNMR. the argument resp should be a yes/no (or y/n) to indicate whether to actually exit RNMR or not. If
resp is not provided RNMR will prompt for it with no as a default.</p>
<p>If /ERROR is used RNMR will return with a status of 2 to indicate an error. Otherwise it will exit with a status of 1.</p>
<h3 id="exp">EXP</h3>
<p>Export buffer to foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>EXP</code> format fspec</p>
<p>Defaults: ascii default_name</p>
<p>Description:
<code>EXP</code> exports the contents of the visible processing buffer to a disk file in a foreign (non-RNMR) format. This
exportation allows one-dimensional data to be transferred from RNMR to another processing program or from one RNMR
archive to another via <code>IMP</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of ASCII. The currently supported foreign formats are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>MESTRE</li>
<li>NV</li>
<li>PIPE</li>
<li>SIFT</li>
<li>UCSF</li>
<li>VNMR</li>
</ul>
<p>If the <code>EXP</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file to contain the exported data. The default file name in the prompt will depend upon the archive and record currently
being viewed in processing buffer 1. By default <code>EXP</code> will store data in the user's foreign directory.</p>
<p>If an export file has been opened with <code>OPNEXP</code> the data will be stored in that file and <code>EXP</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNEXP</code>.</p>
<p>Unlike <code>OPNWRT</code>, <code>EXP</code> will create a new version of the output file if there already exists a file in the current
directory with the name entered by the user. Note that if processing buffer 1 is divided into two or more blocks, <code>EXP</code>
writes out data from the first block only.</p>
<h3 id="exp1d">EXP1D</h3>
<p>Export 1D data to foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>EXP1D</code> format rec slice fspec</p>
<p>Defaults: pipe rrec 1 default_name</p>
<p>Description:
<code>EXP1D</code> exports a one-dimensional slice of a blocked record to a file in a foreign (non-RNMR) format. This
exportation allows one-dimensional data to be transferred from RNMR to another processing program or from one RNMR
archive to another via <code>IMP1D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of pipe. The currently supported foreign formats are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>NV</li>
<li>PIPE</li>
<li>SIFT</li>
<li>UCSF</li>
<li>VNMR</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will export the first 1D slice of the record.</p>
<p>If the <code>EXP1D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file to contain the exported data. The default file name in the prompt will depend upon the record number, slice and the
name of the archive the record is in. By default <code>EXP1D</code> will store data in the user's foreign directory.</p>
<p>If an export file has been opened with <code>OPNEXP</code> the data will be stored in that file and <code>EXP1D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNEXP</code>.</p>
<p>Unlike <code>OPNWRT</code>, <code>EXP1D</code> will create a new version of the output file if there already exists a file in the current
directory with the name entered by the user.</p>
<p>Upon completion, the current read block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
exported. In addition, the current read record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h3 id="exp2d">EXP2D</h3>
<p>Export 2D data to foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>EXP2D</code> format rec slice fspec</p>
<p>Defaults: pipe rrec 1 default_name</p>
<p>Description:
<code>EXP2D</code> exports a two-dimensional slice of a blocked archive record to a file in a foreign (non-RNMR) format. This
exportation allows two-dimensional data to be transferred from RNMR to another processing program or from one RNMR
archive to another via <code>IMP2D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of pipe. The currently supported foreign formats are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>NV</li>
<li>PIPE</li>
<li>SIFT</li>
<li>UCSF</li>
<li>VNMR</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will export the first 2D slice of the record.</p>
<p>If the <code>EXP2D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file to contain the exported data. The default file name in the prompt will depend upon the record number, slice and the
name of the archive the record is in. By default <code>EXP2D</code> will store data in the user's foreign directory.</p>
<p>If an export file has been opened with <code>OPNEXP</code> the data will be stored in that file and <code>EXP2D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNEXP</code>.</p>
<p>Unlike <code>OPNWRT</code>, <code>EXP2D</code> will create a new version of the output file if there already exists a file in the current
directory with the name entered by the user.</p>
<p>Upon completion, the current read block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
exported. In addition, the current read record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h3 id="exp3d">EXP3D</h3>
<p>Export 3D data to foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>EXP2D</code> format rec slice fspec</p>
<p>Defaults: pipe rrec 1 default_name</p>
<p>Description:
<code>EXP3D</code> exports a three-dimensional slice of a blocked archive record to a file in a foreign (non-RNMR) format. This
exportation allows three-dimensional data to be transferred from RNMR to another processing program or from one RNMR
archive to another via <code>IMP3D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of pipe. The currently supported foreign formats are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>NV</li>
<li>PIPE</li>
<li>SIFT</li>
<li>UCSF</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will export the first 3D slice of the record.</p>
<p>If the <code>EXP3D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file to contain the exported data. The default file name in the prompt will depend upon the record number, slice and the
name of the archive the record is in. By default <code>EXP3D</code> will store data in the user's foreign directory.</p>
<p>If an export file has been opened with <code>OPNEXP</code> the data will be stored in that file and <code>EXP2D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNEXP</code>.</p>
<p>Unlike <code>OPNWRT</code>, <code>EXP3D</code> will create a new version of the output file if there already exists a file in the current
directory with the name entered by the user.</p>
<p>Upon completion, the current read block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
exported. In addition, the current read record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h2 id="f">F</h2>
<hr />
<h3 id="f_1">F</h3>
<p>Set synthesizer offset frequency</p>
<p>Category: Frequency Control</p>
<p>Format: <code>F</code> chan freq</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: For RNMRA: Acquisition stopped (HALT). For RNMRP: no restrictions</p>
<p>Description:
<code>F</code> sets the frequency offset for a logical channel. When <code>F</code> is used in RNMRA it sets the actual output frequency as
well as the offset in the processing buffers. In RNMRP, the <code>F</code> command only affects the processing buffer offset.</p>
<p>If no channel is specified RNMR will prompt for it with 1 as a default. The channel must have a nucleus assigned to it
by <code>NUC</code>. If the frequency offset is omitted RNMR will prompt for it with the current offset as a default. The offset is
in the current frequency unit, and takes into account the reference frequency for the nucleus assigned to the channel.
The frequency offset precise to 0.1 Hz, regardless of the current frequency units.</p>
<p>The actual frequency output by the spectrometer is a function of freq, the reference frequency (fref), and the PPM to Hz
conversion factor (fppm) of the assigned nucleus:</p>
<pre><code>Factual(Hz) = 1.0E+06*FPPM(MHz) + FREQ(Hz) + FREF(Hz)
</code></pre>
<h3 id="flag">FLAG</h3>
<p>Set pulse program flag on or off</p>
<p>Category: Experiment</p>
<p>Format: <code>FLAG</code> ind val</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>FLAG</code> sets the pulse program flag specified by ind either on or off based on val. If ind is not provided RNMR will
prompt for it with a default of 1. If val is not provided RNMR will prompt for it with the current value of the flag as
the default. The legal values of val are on and off.</p>
<h3 id="flf">FLF</h3>
<p>Set filter factor</p>
<p>Category: Experiment</p>
<p>Format: <code>FLF</code> factor</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
On spectrometers with S-bus interfaced acquisition filters, <code>FLF</code> sets the filter bandwidth factor. This factor is used
to compute the cutoff frequencies for both the real and imaginary channel filters. <code>FLF</code> takes one parameter, factor
which specifies the filter cutoff scaling factor. If this parameter is omitted, RNMR will prompt for a factor with the
current filter factor as the default. The allowable values for factor are real numbers from 0.0 to 5.0, inclusive. Since
the filter frequencies are digitally programmed, only discrete cutoff values (in increments of 200.0 Hz up to 50000.0
Hz) are allowed. Accordingly, RNMR sets the filter cutoffs to the closest available value given the current dwell time
(as displayed and set by <code>DW</code>) and the filter factor (as displayed and set by <code>FLF</code>). If the filter factor is 0.0, then
the filters are disabled entirely. Otherwise, they are set to the nearest cutoff setting at least as wide as
FLF X (SW/2.0). If the calculated filter bandwidth exceeds 50000.0 Hz, then the filters are disabled entirely. Note that
larger values of factor give wider filter cutoffs. The filter factor is saved to archive records by the commands <code>SA</code>,
<code>SB</code>, and <code>SS</code> and is reported for those records by <code>LP</code>, even if S-bus filter control is not implemented in the
spectrometer running RNMR.</p>
<h3 id="fmx">FMX</h3>
<p>Set frequency modulation value</p>
<p>Category: Pulse Control</p>
<p>Format: <code>FMX</code> chan ind val</p>
<p>Defaults: 1 1 current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
The transmitter frequency can be changed between different values during a pulse sequence by using the <code>SETFMX</code> command
in the pulse sequence. The offset value that is switched to is set using <code>FMX</code>. The chan and ind parameters are used to
specify which frequency offset is being set. <code>SETFMX</code> has an index as a parameter and that index corresponds to ind. The
offsets are set separately for each channel and chan specifies the logical channel. If chan or ind is not specified RNMR
will prompt for it with 1 as a default. The offset value to be set is specified by val. If val is not provided RNMR will
prompt for it with the current offset as the default.</p>
<h3 id="fmxex">FMXEX</h3>
<p>Load frequency modulation program</p>
<p>Category: Pulse Control</p>
<p>Format: <code>FMXEX</code></p>
<p>Defaults:</p>
<h3 id="fold">FOLD</h3>
<p>Fold data buffer</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>FOLD</code> nsect</p>
<p>Defaults: 1</p>
<p>Description:
<code>FOLD</code> divides the visible processing buffer into nsect evenly spaced sections and then averages the sections. If nsect
is not specified RNMR will prompt for it with a default of 1. If nsect is equal to 1 then <code>FOLD</code> has no effect. The
active size of the buffer will be reduced by a factor of nsect.</p>
<h3 id="fsys">FSYS</h3>
<p>Set spectrometer system frequency</p>
<p>Category: Frequency Control</p>
<p>Format: <code>FSYS</code> nuc hi lo</p>
<p>Defaults: current current current</p>
<p>Description:
<code>FSYS</code> sets the spectrometer system frequency by setting the PPM to Hz conversion factor (hi) and reference frequency
(lo) in Hz for a particular nucleus (nuc). The system frequency depends only on the strength of the magnetic field for
the spectrometer running RNMR. All nucleus table entries are referenced to the system frequency so that when <code>FSYS</code> is
called, the PPM to Hz conversion factors and reference frequencies of all known nuclei are modified appropriately.</p>
<p>If nuc is not provided RNMR will prompt for it with the curent reference nucleus as the default. If hi or lo is not
provided RNMR will prompt for them with the current values for the specified nucleus. The hi frequency must be between
1.0 and 1000.0 inclusive while lo must be between -1E6 and 1E6 inclusive.</p>
<p><code>FSYS</code> stores the new system frequency and updates the nucleus table. Both the reference frequency and PPM to Hz
conversion factor of each nucleus are updated. While <code>FSYS</code> changes the frequency values of each nucleus, the
synthesizers are not updated with these new frequencies until the user issues a <code>NUC</code> or <code>F</code> command for each
synthesizer.</p>
<h3 id="ft">FT</h3>
<p>Fourier transform FID</p>
<p>Category: Data Transforms</p>
<p>Format: <code>FT</code> size fctr1</p>
<p>Qualifiers: /REAL /SCALE</p>
<p>Qualifier Defaults: /SCALE=NORM</p>
<p>Defaults: next_power_2 0.5</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>FT</code> performs a Fourier transform on time domain data in the visible processing buffer. Prior to the transformation the
time domain data is zero filled to size and the first point is scaled by fctr1.</p>
<p>If size is provided it must be a power of 2. If size is not provided then RNMR will not prompt for it and will use the
next power of 2 that is larger than the size of the buffer. If fctr1 is not provided RNMR will not prompt for it and
will use 0.5. The value of fctr1 must be greater than 0.</p>
<p>The /REAL qualifier will cause <code>FT</code> to perform a real Fourier transform using only the real part of the buffer.
Otherwise a complex Fourier transform will be applied. /SCALE determines how the result of the transform will be scaled
as follows:</p>
<table>
<thead>
<tr>
<th>/SCALE</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>NORM</td>
<td>Normalizes buffer</td>
</tr>
<tr>
<td>ABS</td>
<td>Scales to absolute scale factor</td>
</tr>
<tr>
<td>NONE</td>
<td>Does not scale</td>
</tr>
</tbody>
</table>
<p>Since time domain data is presented with minimum time on the left while frequency data is presented with maximum
frequency on the left (by long standing NMR convention), the default action of <code>FT</code> is to reverse the order of the data
after transformation. This is done by conjugating the FID before the Fourier transform is calculated. <code>FT</code> also negates
every other point in the FID.</p>
<h2 id="g">G</h2>
<hr />
<h3 id="ga">GA</h3>
<p>Get archive record data</p>
<p>Category: Data Storage</p>
<p>Format: <code>GA</code> rec buf</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>GA</code> reads data from an <a href="../syntax/#record_type">archive record</a> to a <a href="../syntax/#buffers">processing buffer</a>. The
parameters and data of the buffer are replaced with corresponding values read from the disk record. Most RNMR commands
require that data stored in an archive file be read into a buffer before further processing may be performed.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. <code>GA</code> cannot be used to read scratch records which must be accessed with <code>GS</code>
or blocked records which must be accessed with <code>GB</code>. If no buffer is specified RNMR will not prompt for it and will read
the record into the visible processing buffer.</p>
<p>In order to read the record into the buffer, the allocated size of the buffer must be greater than or equal to the size
of the archive record. To check and, if necessary, modify the allocated buffer size, use the command <code>DBSZ</code>. The active
size of the buffer will change to the size of the data read from the record.</p>
<h3 id="gain">GAIN</h3>
<p>Set receiver gain</p>
<p>Category: Experiment</p>
<p>Format: <code>GAIN</code> gain</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>GAIN</code> sets the observe channel receiver gain. If no gain is specified RNMR will prompt for it with the current receiver
gain as a default. The receiver gain must be between 0.0 and 100.0 inclusive and is considered precise to 0.1.</p>
<h3 id="gainl">GAINL</h3>
<p>Set lock receiver gain</p>
<p>Category: Lock</p>
<p>Format: <code>GAINL</code> gain</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>GAINL</code> sets the lock channel receiver relative gain. If no gain is specified RNMR will prompt for it with the current
lock channel receiver gain as a default. The receiver gain must be between 0.0 and 100.0 inclusive and is considered
precise to 1.0.</p>
<h3 id="gav">GAV</h3>
<p>Get data from averager</p>
<p>Category: Acquisition</p>
<p>Format: <code>GAV</code> blk buf</p>
<p>Defaults: 1 1</p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>GAV</code> transfers data and parameters from the averager to a <a href="../syntax/#buffers">processing buffer</a>. <code>GAV</code> must be used in
order to process data acquired by the spectrometer hardware. The averager memory may be logically partitioned into two
or more blocks by <code>NABLK</code> so that multiple FID's with different experimental parameters can be acquired at once, without
the need to start and stop acquisition many times. <code>GAV</code> transfers one of these blocks to a processing buffer. If no
block is specified RNMR will not prompt for it and will transfer block 1. If no buffer is specified RNMR will not prompt
for it and will transfer to the visible processing buffer.</p>
<p>Because <code>GAV</code> transfers all the acquisition buffer parameters to a processing buffer after spectrometer data has been
acquired, setting an acquisition parameter before collecting data ensures that it will be inherited by the processing
buffer upon completion of the experiment. For example, one may ensure that data to be collected will be saved to disk
with a given title by using <code>TITLEA</code> to set the acquisition buffer title before starting an experiment.</p>
<p>In order to read the data into the buffer, the allocated size of the buffer must be greater than or equal to the size of
the data. To check and, if necessary, modify the allocated buffer size, use the command <code>DBSZ</code>. The active size of the
buffer will change to the size of the data transferred from the averager.</p>
<h3 id="gb">GB</h3>
<p>Get blocked record data</p>
<p>Category: Data Storage</p>
<p>Format: <code>GB</code> rec slice buf nslice</p>
<p>Defaults: rrec next 1 1</p>
<p>Description:
<code>GB</code> reads 1D slices from a <a href="../syntax/#blocked_records">blocked record</a> to a <a href="../syntax/#buffers">processing buffer</a>. The
parameters and data of the buffer are replaced with corresponding values read from the disk record. Most RNMR commands
require that data stored in a blocked record be read into a buffer before further processing may be performed.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. <code>GB</code> can only be used on <a href="../syntax/#record_type">blocked records</a> and cannot
be used to read scratch records which must be accessed with <code>GS</code> or archive records which must be accessed with <code>GA</code>.</p>
<p>Since processing buffers are one-dimensional, the user must specify which one-dimensional <a href="../syntax/#slice">slice(s)</a> of
the blocked record to read into the buffer. If no slice is specified RNMR will not prompt for it and will get the next
slice after the current read blocked record pointer (as displayed and set by <code>PTRB</code>).</p>
<p>If no buffer is specified RNMR will not prompt for it and will read the data into the visible processing buffer.
Multiple slices from a blocked record may be read into multiple blocks of the buffer. The final parameter, nslice,
specifies how many slices to read starting from the specified slice. If nslice is omitted RNMR will not prompt for it
and will read only a single slice. The value of nslice may not exceed the number of blocks the processing buffer is
partitioned into (as displayed and set by <code>DBSZ</code>). Additionally the size of each slice must not exceed the size of each
block of the buffer. In order for a slice to be read it must not exceed the size of the blocked record and it must have
been used (data stored in it). If a requested slice cannot be read for the above reasons all of the requested slices
that come before it will still be successfully read. The read blocked record pointer (as displayed and set by <code>PTRB</code>)
will be updated to point to the last slice read.</p>
<h3 id="gblarg">GBLARG</h3>
<p>Set value of global argument</p>
<p>Category: Arguments</p>
<p>Format: <code>GBLARG</code> nam val</p>
<p>Defaults: temp current</p>
<p>Description:
<code>GBLARG</code> is an old command for defining global arguments. It has been replaced with the <code>DFNGBL</code> command and is
currently simply an alias to it. As such <code>DFNGBL</code> should be used in place of <code>GBLARG</code>.</p>
<h3 id="gbldl">GBLDL</h3>
<p>Delete global argument</p>
<p>Category: Arguments</p>
<p>Format: <code>GBLDL</code> first last</p>
<p>Defaults: temp first</p>
<p>Description:
<code>GBLDL</code> is an old command for deleting global arguments. It has been replaced with the <code>REMGBL</code> command and is currently
simply an alias to it. As such <code>REMGBL</code> should be used in place of <code>GBLDL</code>.</p>
<h3 id="gencs">GENCS</h3>
<p>Generate complex sine wave</p>
<p>Category: Signal Generation</p>
<p>Format: <code>GENCS</code> freq phase sw</p>
<p>Defaults: 1.0 0.0 current</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>GENCS</code> generates a complex sine wave of specified frequency and phase. This sine wave has unit amplitude and replaces
any data currently in the visible processing buffer (buffer 1). Using <code>GENCS</code> to create a complex sine and applying
<code>SC</code>, <code>EM</code>, and <code>GM</code> to scale and broaden the data, one may produce a simulated FID with any desired frequency, phase,
amplitude, and Gaussian and Lorentzian line widths. These simulated FID's may be added together to give a waveform
corresponding to a multiline spectrum.</p>
<p>The frequency of the sine wave should be specified in the current frequency units (as displayed and set by
<code>UNIT /FREQ</code>). If freq is omitted RNMR will prompt for it with a default of 1. The phase of the sine wave should be
specified in degrees. If the phase is omitted RNMR will not prompt for it and will use a phase of 0.0. The final
parameter, sw, is the sweep width of the generated signal. If sw is not specified RNMR will not prompt for it and will
use the current sweep width of the visible processing buffer. If a value of sw is entered then the time step in the
buffer will be altered to match the requested sweep width.</p>
<h3 id="genpwdr">GENPWDR</h3>
<p>Generate complex powder pattern</p>
<p>Category: Signal Generation</p>
<p>Format: <code>GENPWDR</code> freq phase sw fctr</p>
<p>Defaults: 1.0 0.0 current 1.0</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>GENPWDR</code> generates a complex time domain signal corresponding to a powder pattern. This signal has unit amplitude and
replaces any data currently in the visible processing buffer. The parameter freq sets the width of the powder pattern in
the current frequency units (as displayed and set by <code>UNIT /FREQ</code>). If freq is omitted RNMR will prompt for it with a
default of 1. The phase of the sine wave should be specified in degrees. If the phase is omitted RNMR will not prompt
for it and will use a phase of 0.0. The  parameter sw is the sweep width of the generated signal. If sw is not specified
RNMR will not prompt for it and will use the current sweep width of the visible processing buffer. If a value of sw is
entered then the time step in the buffer will be altered to match the requested sweep width. The final parameter, fctr,
is a factor controlling the number of orientations that are considered when generating the signal. The number of
orientations is equal to 3<em>freq</em>dstep<em>1e-3</em>fctr*size or 1 whichever is larger. Values of fctr must be between 0.5 and
2.0 inclusive.</p>
<h3 id="gm">GM</h3>
<p>Gaussian multiply FID</p>
<p>Category: Apodization</p>
<p>Format: <code>GM</code> lb</p>
<p>Qualifiers: /PROMPT</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: current</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>GM</code> performs a Gaussian multiplication apodization on an FID in the visible processing buffer. In this  apodization,
the FID is multiplied by a decaying real Gaussian function. This results in a broadening of spectral lines after
Fourier transformation which masks noise at the expense of resolution. When Gaussian multiplication is applied to a
perfect, non-decaying complex sine wave and a Fourier transform is performed, the result will be a perfect Gaussian line shape. </p>
<p><code>GM</code> takes one argument, lb, which is the line broadening factor. This parameter is expressed in the current frequency
units (Hz, kHz, or MHz) unless that unit is ppm in which case it is in the default frequency units. The value of lb must
be between -1000 and 1000. If lb is omitted, RNMR will not prompt for a value unless the /PROMPT qualifier is used and
will perform the apodization with the global line broadening factor, as set and displayed by the command <code>LB</code>. If a
legal value of lb is specified, the global line broadening factor will be updated before gaussian multiplication of the
data. <code>GM</code> multiplies each block of processing buffer 1 by the real function:</p>
<pre><code>F(I) = EXP-(0.5*PI*(I-1)* LB/SW)^2)
</code></pre>
<p>where I is the index of the data point (I=1,2,...), LB is the line broadening factor, and SW is buffer sweep width.</p>
<h3 id="gmv">GMV</h3>
<p>Calculate geometric mean</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>GMV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>GMV</code> computes the geometric mean of <a href="../syntax/#buffers">processing buffers</a> src and dst and stores the result in dst.</p>
<pre><code>DST = SIGN(DST) * SQRT(ABS(DST*SRC))
</code></pre>
<p>The geometric means of the real and imaginary parts of the data are computed separately. If either argument is omitted,
RNMR will prompt for a buffer number. The default source is buffer 2 while the default destination is buffer 1. The src
and dst buffers must have the same domain and active size (though not necessarily the same allocated size).</p>
<h3 id="go">GO</h3>
<p>Start or resume acquisition</p>
<p>Category: Acquisition</p>
<p>Format: <code>GO</code> first_group last_group</p>
<p>Defaults: 1 0</p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>GO</code> <a href="../syntax/#acquisition">starts acquisition</a> without zeroing the shot counter or averager and without performing
dummy scans. This permits continued averaging of existing data. This can be used to resume acquisition that was halted.
If the number of shots to acquire, na, (as displayed and set by <code>NA</code>) is not -1 the number of shots already acquired
must be less than na. If the current shot counter is at 0 then <code>GO</code> will behave like <code>ZG</code> instead of its normal
behavior. </p>
<p>The arguments first_group and last_group specify the range of <a href="../syntax/#acqgrp">acquisition groups</a> to acquire. If
either parameter is omitted RNMR will not prompt for it and will use 1 and 0 as defaults respectively. If last_group is
set to 0 then only first_group will be acquired.</p>
<h3 id="gosub">GOSUB</h3>
<p>Perform call within macro</p>
<p>Category: Control Flow</p>
<p>Format: <code>GOSUB</code> label</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>GOSUB</code> jumps to a label within a macro much like <code>GOTO</code>. When <code>MEXIT</code> is encountered after the jump execution will
return to the line following the <code>GOSUB</code> call instead of exiting the macro. This allows for setting up and calling
subroutines within a macro.</p>
<p>The parameter label is the name of the macro label to which execution should jump. If label is not specified, execution
will continue at the next line of the current macro. Note that execution will still return to the line after the <code>GOSUB</code>
call at the next <code>MEXIT</code> even if no label was provided.</p>
<h3 id="goto">GOTO</h3>
<p>Go to statement label in macro</p>
<p>Category: Control Flow</p>
<p>Format: <code>GOTO</code> label</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>GOTO</code> performs an unconditional jump within a macro. The parameter label is the name of the macro label to which
execution should jump. If label is not specified, execution will continue at the next line of the current macro.</p>
<h3 id="gotst">GOTST</h3>
<p>Perform a conditional jump within a macro based on a test</p>
<p>Category: Control Flow</p>
<p>Format: <code>GOTST</code> name args... label1 label2</p>
<p>Qualifiers: /TRUE /FALSE</p>
<p>Qualifier defaults: /TRUE</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>GOTST</code> jumps to a label within a macro based upon the results of a conditional test. The available qualifiers and
arguments for <code>GOTST</code> tests are the same as those detailed in the description of <code>TST</code>. While <code>TST</code> executes different
blocks of commands based upon the test result, <code>GOTST</code> jumps to macro labels. Tests which would cause <code>TST</code> to execute
the commands between <code>TST</code> and <code>ELSTST</code> cause <code>GOTST</code> to jump to label1. Tests which would cause <code>TST</code> to execute the
commands between <code>ELSTST</code> and <code>ENDTST</code> cause <code>GOTST</code> to jump to label2.</p>
<p><code>GOTST</code> is the most direct replacement for the behavior of the old if commands such as <code>IFEQ</code>. <code>GOTST</code> should only be
used when there is a need to jump to labels in different parts of a macro. <code>TST</code> should be used for conditional
execution of blocks of commands.</p>
<h3 id="gref">GREF</h3>
<p>Restore processing buffer reference from nucleus table</p>
<p>Category: Frequency Control</p>
<p>Format: <code>GREF</code> nuc</p>
<p>Defaults: *</p>
<p>Description:
<code>GREF</code> changes the reference frequency (or frequencies) in a processing buffer to match what is stored in the nucleus
table. If nuc is * <code>GREF</code> changes the frequency for every channel. Otherwise a valid nucleus must be passed. If nuc is
omitted RNMR will prompt for it with a default of *. <code>GREF</code> only changes the reference frequency parameter for the
processing buffers and does not update the synthesizers.</p>
<h3 id="grefa">GREFA</h3>
<p>Restore acquisition buffer reference from nucleus table</p>
<p>Category: Frequency Control</p>
<p>Format: <code>GREFA</code> nuc</p>
<p>Qualifiers: /RESET</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: *</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>GREFA</code> changes the reference frequency (or frequencies) in the acquisition buffer to match what is stored in the
nucleus table. If nuc is * <code>GREFA</code> changes the frequency for every channel. Otherwise a valid nucleus must be passed. If
nuc is omitted RNMR will prompt for it with a default of *. <code>GREFA</code> only changes the reference frequency parameter for
the acquisition buffer. If /RESET is used <code>GREFA</code> will also change the synthesizer frequency and FMU frequency.</p>
<h3 id="gs">GS</h3>
<p>Get data from scratch record</p>
<p>Category: Data Storage</p>
<p>Format: <code>GS</code> rec buf</p>
<p>Defaults: 1 1</p>
<p>Description:
<code>GS</code> reads data from a <a href="../syntax/#record_type">scratch record</a> to a <a href="../syntax/#buffers">processing buffer</a>. The
parameters and data of the buffer are replaced with corresponding values read from the disk record. Most RNMR commands
require that data stored in an archive file be read into a buffer before further processing may be performed.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will not prompt for it and will read data from record 1. <code>GS</code>
cannot be used to read archive records which must be accessed with <code>GA</code> or blocked records which must be accessed with
<code>GB</code>. If no buffer is specified RNMR will not prompt for it and will read the record into the visible processing buffer.</p>
<p>In order to read the record into the buffer, the allocated size of the buffer must be greater than or equal to the size
of the scratch record. To check and, if necessary, modify the allocated buffer size, use the command <code>DBSZ</code>. The active
size of the buffer will change to the size of the data read from the record. <code>GS</code> does not update the record read
pointer (as displayed and set by <code>PTRA</code>).</p>
<h2 id="h">H</h2>
<hr />
<h3 id="hilb">HILB</h3>
<p>Perform Hilbert transform on spectrum</p>
<p>Category: Data Transforms</p>
<p>Format: <code>HILB</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>HILB</code> performs a Hilbert transform on a spectrum in the visible processing buffer. As a consequence of Fourier
transformation, the real and imaginary parts of a complex spectrum are Hilbert transform pairs. Thus, it should be
possible to discard the imaginary channel and then recreate it by performing a Hilbert transform on the real part of the
data. Typically, this is done after a spectrum has received linear phase correction, cubic spline baseline correction,
or any other manipulation that results in the real and imaginary channels no longer being Hilbert transform pairs.
Without correction by <code>HILB</code>, the inverse Fourier transform of this data would be incorrect, as evidenced by divergence
of the data at long times. <code>HILB</code> replaces the imaginary part of the buffer data with the Hilbert transform of the real
part, and leaves the real part of the buffer unchanged. The active size of the visible processing buffer must be a power
of two greater than or equal to 4.</p>
<h3 id="hilbz">HILBZ</h3>
<p>Perform Hilbert transform on zero-filled spectrum</p>
<p>Category: Data Transforms</p>
<p>Format: <code>HILBZ</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>HILBZ</code> performs a Hilbert transform on a zero filled spectrum in the visible processing buffer. As a consequence of
Fourier transformation, the real and imaginary parts of a complex spectrum are Hilbert transform pairs. Thus, it should
be possible to discard the imaginary channel and then recreate it by performing a Hilbert transform on the real part of
the data. Typically, this is done after a spectrum has received linear phase correction, cubic spline baseline
correction, or any other manipulation that results in the real and imaginary channels no longer being Hilbert transform
pairs. Without correction by <code>HILBZ</code>, the inverse Fourier transform of this data would be incorrect, as evidenced by
divergence of the data at long times. <code>HILBZ</code> replaces the imaginary part of the buffer data with the Hilbert transform
of the real part, and leaves the real part of the buffer unchanged. The active size of the visible processing buffer
must be a power of two greater than or equal to 4.</p>
<h3 id="htr">HTR</h3>
<p>Enable or disable probe heater</p>
<p>Category: Heater</p>
<p>Format: <code>HTR</code> state</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>HTR</code> sets the heater enable flag on or off. This flag enables or disables computer control of the probe temperature.
<code>HTR</code>  checks the current status of the probe heater. If the heater is in ERROR status, RNMR reports the error and
resets the heater status. If state is not specified RNMR will prompt for the heater enable state with the current
state as the default. The legal values of state are ON and OFF only.</p>
<h3 id="htrsts">HTRSTS</h3>
<p>Return probe heater status</p>
<p>Category: Heater</p>
<p>Format: <code>HTRSTS</code></p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>HTRSTS</code> returns the current probe heater status in an informational message. If the status returned by the temperature
controller indicates an error, RNMR will reset the heater status without printing an error message. The heater status
value read from the hardware is displayed via an informational message as a two-character hexadecimal string.</p>
<h2 id="i">I</h2>
<hr />
<h3 id="ibox">IBOX</h3>
<p>Set volume parameters for nD volume integration</p>
<p>Category: Data Analysis</p>
<p>Format: <code>IBOX</code> dim size</p>
<p>Defaults: 1 current</p>
<p>Description:
<code>IBOX</code> sets the integration block size for a dimension dim to size. If dim is omitted RNMR will prompt for it with a
default of 1. If size is omitted RNMR will prompt for it with a default of the current integration block size for dim.</p>
<h3 id="idn">IDN</h3>
<p>Set processing buffer identification fields</p>
<p>Category: Data Storage</p>
<p>Format: <code>IDN</code> idn val prompt</p>
<p>Defaults: 1 current 'Enter identifier value:'</p>
<p>Description:
<code>IDN</code> sets the value of an identifier field for the visible processing buffer. These values are saved in the title
record when the data is saved and may be used to store any desired ancillary information about an experiment, such as
pH, temperature, or sample spinning speed. Currently, there are four identifiers available.</p>
<p>The first parameter, idn, selects which identifier field is to be modified. If idn is not specified, RNMR will prompt
for an identifier with 1 as a default. If the value to set the identifier to is omitted RNMR will prompt for it with the
current value as a default and the third parameter, prompt, as the prompt string. If prompt is omitted the default
prompt string is 'Enter identifier value:'. The value may be not be longer than eight characters.</p>
<h3 id="idna">IDNA</h3>
<p>Set acquisition buffer identification fields</p>
<p>Category: Acquisition</p>
<p>Format: <code>IDNA</code> idn val prompt</p>
<p>Defaults: 1 current 'Enter identifier value:'</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>IDNA</code> sets the value of an identifier field for the acquisition buffer. These values are transferred to a processing
buffer along with the data in the acquisition buffer by <code>GAV</code>. They are then saved in the title record when the data is
saved and may be used to store any desired ancillary information about an experiment, such as pH, temperature, or MAS
spinning speed. Currently, there are four identifiers available.</p>
<p>The first parameter, idn, selects which identifier field is to be modified. If idn is not specified, RNMR will prompt
for an identifier with 1 as a default. If the value to set the identifier to is omitted RNMR will prompt for it with the
current value as a default and the third parameter, prompt, as the prompt string. If prompt is omitted the default
prompt string is 'Enter identifier value:'. The value may be not be longer than eight characters.</p>
<h3 id="ifcnd">IFCND</h3>
<p>Branch on condition flag</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFCND</code> icnd labelt labelf</p>
<p>Defaults: 1 none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFCND</code> is one of the old if commands. It jumps to labelt if the specified condition flag is ON and to labelf if it is
OFF. As with all of the old if commands, if the label to jump to is not specified execution continues to the next line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="ifeq">IFEQ</h3>
<p>Branch on equal</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFEQ</code> arg1 arg2 labelt labelf</p>
<p>Defaults: none none none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFEQ</code> is one of the old if commands. It jumps to labelt if arg1 and arg2 are the same string and to labelf if they are
not. As with all of the old if commands, if the label to jump to is not specified execution continues to the next line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="ifgbl">IFGBL</h3>
<p>Check for global argument and branch</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFGBL</code> gblnam labelt labelf</p>
<p>Defaults: TEMP none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFGBL</code> is one of the old if commands. It jumps to labelt if the specified global argument exists and to labelf if it
does not. As with all of the old if commands, if the label to jump to is not specified execution continues to the next
line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="iflcl">IFLCL</h3>
<p>Check for local argument and branch</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFLCL</code> lclnam labelt labelf</p>
<p>Defaults: TEMP none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFLCL</code> is one of the old if commands. It jumps to labelt if the specified local argument exists and to labelf if it
does not. As with all of the old if commands, if the label to jump to is not specified execution continues to the next
line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="ifmac">IFMAC</h3>
<p>Check for macro and branch</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFMAC</code> macnam labelt labelf</p>
<p>Defaults: TEMP none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFMAC</code> is one of the old if commands. It jumps to labelt if the specified macro exists and to labelf if it does not. As
with all of the old if commands, if the label to jump to is not specified execution continues to the next line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="ifrec">IFREC</h3>
<p>Check for record and branch</p>
<p>Category: Control Flow</p>
<p>Format: <code>IFREC</code> rec. labelt labelf</p>
<p>Defaults: current none none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>IFREC</code> is one of the old if commands. It jumps to labelt if the specified record exists and to labelf if it does not.
As with all of the old if commands, if the label to jump to is not specified execution continues to the next line.</p>
<p>The old if commands have been replaced. Instead use <code>TST</code> to conditionally execute commands or <code>GOTST</code> to make
conditional jumps.</p>
<h3 id="ift">IFT</h3>
<p>Inverse Fourier transform spectrum</p>
<p>Category: Data Transforms</p>
<p>Format: <code>IFT</code> size fctr1</p>
<p>Qualifiers: /REAL /SCALE</p>
<p>Qualifier Defaults: /SCALE=NORM</p>
<p>Defaults: next_power_2 0.5</p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>IFT</code> performs an inverse Fourier transform on frequency domain data in the visible processing buffer. Prior to the
transformation the frequency domain data is zero filled to size and after the transformation the first point is divided
by fctr1.</p>
<p>If size is provided it must be a power of 2. If size is not provided then RNMR will not prompt for it and will use the
next power of 2 that is larger than the size of the buffer. If fctr1 is not provided RNMR will not prompt for it and
will use 0.5. The value of fctr1 must be greater than 0.</p>
<p>The /REAL qualifier will cause <code>IFT</code> to perform a real inverse Fourier transform using only the real part of the buffer.
Otherwise a complex inverse Fourier transform will be applied. /SCALE determines how the result of the transform will
be scaled as follows:</p>
<table>
<thead>
<tr>
<th>/SCALE</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>NORM</td>
<td>Normalizes buffer</td>
</tr>
<tr>
<td>ABS</td>
<td>Scales to absolute scale factor</td>
</tr>
<tr>
<td>NONE</td>
<td>Does not scale</td>
</tr>
</tbody>
</table>
<p>Since time domain data is presented with minimum time on the left while frequency data is presented with maximum
frequency on the left (by long standing NMR convention), the default action of <code>IFT</code> is to conjugate the data after
transformation. This ensures that performing an <code>IFT</code> followed by an <code>FT</code> will give the same frequency data order.</p>
<h3 id="imp">IMP</h3>
<p>Import data from foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>IMP</code> format fspec</p>
<p>Defaults: ASCII</p>
<p>Description:
<code>IMP</code> imports the contents of a disk file in a foreign (non-RNMR) format to the visible processing buffer. This
importation allows one-dimensional data to be transferred to RNMR from another processing program or from one RNMR
archive to another via <code>EXP</code>.  Since the foreign data is only read into memory by <code>IMP</code>, the user must use <code>SA</code>, <code>SB</code>,
or <code>SS</code> to store the imported data permanently.</p>
<p>If no format is specified RNMR will prompt for it with a default of ASCII. The currently supported foreign formats are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>SIFT</li>
<li>VNMR</li>
</ul>
<p>If the <code>IMP</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file containing the data to be imported. The default file name in the prompt will be temp with an extension based upon
the format. By default <code>IMP</code> will search for data in the user's foreign directory.</p>
<p>If an import file has been opened with <code>OPNIMP</code> the data will be stored in that file and <code>IMP</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNIMP</code>.</p>
<h3 id="imp1d">IMP1D</h3>
<p>Import data from foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>IMP1D</code> format rec slice fspec</p>
<p>Defaults: sift rrec 1 default_name</p>
<p>Description:
<code>IMP1D</code> imports the contents of a disk file in a foreign (non-RNMR) format and saves it in a specified one-dimensional
slice of a <a href="../syntax/#blocked_records">blocked record</a>. This importation allows one-dimensional data to be transferred
to RNMR from another processing program or from one RNMR archive to another via <code>EXP1D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of sift. The currently supported foreign formats are:</p>
<ul>
<li>SIFT</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will import data to the first 1D slice of the record.</p>
<p>If the <code>IMP1D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file containing the data to be imported. The default file name in the prompt will depend upon the record number, slice
and the name of the archive the record is in. By default <code>IMP1D</code> will search for data in the user's foreign directory.</p>
<p>If an import file has been opened with <code>OPNIMP</code> the data will be stored in that file and <code>IMP1D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNIMP</code>.</p>
<p>Upon completion, the current write block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
imported. In addition, the current write record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h3 id="imp2d">IMP2D</h3>
<p>Import data from foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>IMP2D</code> format rec slice fspec</p>
<p>Defaults: sift rrec 1 default_name</p>
<p>Description:
<code>IMP2D</code> imports the contents of a disk file in a foreign (non-RNMR) format and saves it in a specified two-dimensional
slice of a <a href="../syntax/#blocked_records">blocked record</a>. This importation allows two-dimensional data to be transferred
to RNMR from another processing program or from one RNMR archive to another via <code>EXP2D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of sift. The currently supported foreign formats are:</p>
<ul>
<li>SIFT</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will import data to the first 2D slice of the record.</p>
<p>If the <code>IMP2D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file containing the data to be imported. The default file name in the prompt will depend upon the record number, slice
and the name of the archive the record is in. By default <code>IMP2D</code> will search for data in the user's foreign directory.</p>
<p>If an import file has been opened with <code>OPNIMP</code> the data will be stored in that file and <code>IMP2D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNIMP</code>.</p>
<p>Upon completion, the current write block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
imported. In addition, the current write record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h3 id="imp3d">IMP3D</h3>
<p>Import data from foreign format</p>
<p>Category: Foreign</p>
<p>Format: <code>IMP3D</code> format rec slice fspec</p>
<p>Defaults: sift rrec 1 default_name</p>
<p>Description:
<code>IMP3D</code> imports the contents of a disk file in a foreign (non-RNMR) format and saves it in a specified three-dimensional
slice of a <a href="../syntax/#blocked_records">blocked record</a>. This importation allows two-dimensional data to be transferred
to RNMR from another processing program or from one RNMR archive to another via <code>EXP3D</code>.</p>
<p>If no format is specified RNMR will prompt for it with a default of sift. The currently supported foreign formats are:</p>
<ul>
<li>SIFT</li>
</ul>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will import data to the first 3D slice of the record.</p>
<p>If the <code>IMP3D</code> command is used at console level and fspec is not provided, RNMR will prompt the user for the name of the
file containing the data to be imported. The default file name in the prompt will depend upon the record number, slice
and the name of the archive the record is in. By default <code>IMP3D</code> will search for data in the user's foreign directory.</p>
<p>If an import file has been opened with <code>OPNIMP</code> the data will be stored in that file and <code>IMP3D</code> will neither use nor
prompt for fspec. The format must match the format specified in <code>OPNIMP</code>.</p>
<p>Upon completion, the current write block of the record, as set and displayed by <code>PTRB</code>, is set to the slice that was
imported. In addition, the current write record, as set and displayed by <code>PTRA</code>, is set to rec.</p>
<h3 id="inflvl">INFLVL</h3>
<p>Set info level</p>
<p>Category: Misc.</p>
<p>Format: <code>INFLVL</code> nam lev</p>
<p>Defaults: none current</p>
<p>Description:
<code>INFLVL</code> sets info levels that are then used by other RNMR commands to decide how much information to print to the
console. The first parameter, nam, specifies which info level to set. If nam is omitted RNMR will prompt for it with no
default. The second parameter, lev, is the level to set and should be an integer that is 0 or greater. If lev is omitted
RNMR will prompt for it with the current value as a default.</p>
<h3 id="intg">INTG</h3>
<p>Compute integral of spectrum</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>INTG</code></p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>INTG</code> calculates and displays the indefinite integral (antiderivative) of the data in the visible processing buffer
within the current display limits (as displayed and set by <code>LIM</code>). By integrating a spectrum, one may measure
the total intensity of each peak. For calculating the integrated intensity of individual peaks, one may compute the
definite integral within specified frequency limits using the command <code>INTRG</code>.</p>
<p>A baseline fix apodization (<code>BF</code>) is performed prior to integration to eliminate any constant offset after integration.
Then each point between the display limits is replaced with the sum of all the points from the left display limit to
that data point, including the endpoints. After the integration is complete the buffer is normalized (<code>NORM</code>).</p>
<h3 id="intrg">INTRG</h3>
<p>Integrate region of spectrum</p>
<p>Category: Data Analysis</p>
<p>Format: <code>INTRG</code> llim rlim</p>
<p>Qualifiers: /COMPLEX,/IMAG,/REAL</p>
<p>Qualifier Defaults: current_display</p>
<p>Defaults: current_display_limits</p>
<p>Description:
<code>INTRG</code> calculates the definite integral of the data in the visible processing buffer within specified limits. To
calculate and display the indefinite integral of a spectrum within the current display limits, use the command <code>INTG</code>.</p>
<p>The parameters of the <code>INTRG</code> command are llim and rlim, the left and right integration limits. These limits are
specified in the current buffer units (as displayed and set by <code>UNIT</code>). If either or both of these limits are omitted
RNMR will not prompt for them and will use the current display limits. If either limit is beyond the size of the
dataset, the first/last point in the data set will be the integration limit instead.</p>
<p>If the integration limits are within the range of the data buffer but do not correspond to a specific data point, RNMR
will set that limit to the time or frequency of the closest data point to the right of the value specified. <code>INTRG</code>
calculates the definite integral between the adjusted left and right limits in the first block of the visible processing
buffer. This integral is defined as the sum of each data point between llim and rlim, inclusive. The integral is
reported as an informational message with a maximum of two decimal places. If the integral cannot be reported as a
floating point number in an eight character field, it is reported in scientific notation.</p>
<p>The qualifiers determine which part of a complex buffer is integrated as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Integrand</th>
</tr>
</thead>
<tbody>
<tr>
<td>/COMPLEX</td>
<td>Complex magnitude</td>
</tr>
<tr>
<td>/IMAG</td>
<td>Imaginary part</td>
</tr>
<tr>
<td>/REAL</td>
<td>Real part</td>
</tr>
</tbody>
</table>
<p>The default integrand is the same as the current display mode (as displayed and set by <code>BUF</code>).</p>
<h3 id="inslst">INSLST</h3>
<p>Insert value into list</p>
<p>Category: Lists</p>
<p>Format: <code>INSLST</code> nam pos val</p>
<p>Defaults: temp 1 current</p>
<p>Description:
<code>INSLST</code> inserts the value val at position pos in list nam. All of the values in the list from position pos onward are
moved by one element and val is stored at pos. The parameter pos cannot exceed the largest filled position in the list.
If nam is omitted RNMR will prompt for it with temp as a default. If pos is omitted RNMR will prompt for it with 1 as a
default. If val is omitted RNMR will prompt for it with the current value at position pos in list nam.</p>
<h3 id="ixval">IXVAL</h3>
<p>Convert from unit value to point index</p>
<p>Category: Data Analysis</p>
<p>Format: <code>IXVAL</code> pos</p>
<p>Default : current_cursor_position</p>
<p>Description:
<code>IXVAL</code> returns the index of the data point nearest to a position specified in the current units of the visible
processing buffer. If no position is specified RNMR will prompt for it with the current cursor position as a default.
If the specified position is outside of the actual data in the visible processing buffer <code>XVAL</code> will return the index of
the closest point (the leftmost or rightmost point). The converted value is printed as an informational message.</p>
<h2 id="k">K</h2>
<hr />
<h3 id="keyarg">KEYARG</h3>
<p>Declare names of macro keyword arguments</p>
<p>Category: Arguments</p>
<p>Format: <code>KEYARG</code> nam...</p>
<p>Defaults: none</p>
<p>Description:
<code>KEYARG</code> is used to declare the names of the keyword arguments passed to a macro. Keywords are passed to macros much
like qualifiers are passed to RNMR commands. For example:</p>
<pre><code>TEMP /A=2 /B
</code></pre>
<p>calls macro TEMP and passes two keyword arguments A and B and a value of 2 for argument A. This will create the
following local arguments within macro TEMP.</p>
<ul>
<li>A=2</li>
<li>B=''</li>
<li>KEY$1='/VAR=2'</li>
<li>KEY$2='/B'</li>
</ul>
<p>Calling <code>KEYARG A B</code> within TEMP will delete KEY$1 and KEY$2 and leave A and B untouched.</p>
<h2 id="l">L</h2>
<hr />
<h3 id="lb">LB</h3>
<p>Set line broadening factor</p>
<p>Category: Apodization</p>
<p>Format: <code>LB</code> lb</p>
<p>Defaults: current</p>
<p>Description:
<code>LB</code> sets the line broadening factor used for exponential and Gaussian multiplication apodizations (<code>EM</code> and <code>GM</code>). This
factor can either be set with the <code>LB</code> command or by entering the line broadening factor as a parameter with the <code>EM</code> or
<code>GM</code> commands. Thus, <code>EM 1</code>, <code>GM 1</code>, and <code>LB 1</code> all set the line broadening factor to 1.0 for subsequent apodizations.</p>
<p><code>LB</code> has one parameter, lb, which is the line broadening factor, expressed in the current frequency units unless that
unit is ppm in which case it is in the default frequency units. If lb is omitted, RNMR will prompt for it with the
current line broadening factor as the default. the line broadening factor must be between -1000 and 1000.</p>
<h3 id="lck">LCK</h3>
<p>Enable or disable lock feedback loop</p>
<p>Category: Lock</p>
<p>Format: <code>LCK</code> state</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>LCK</code> enables or disables the magnetic field-frequency lock on spectrometers with software lock control enabled. <code>LCK</code>
takes one parameter, state, which may be specified as either ON or OFF to enable or disable the lock, respectively.
If state is omitted RNMR will prompt for it with the current lock state as the default.</p>
<h3 id="lckctl">LCKCTL</h3>
<p>Open lock control pop up menu</p>
<p>Category: Lock</p>
<p>Format: <code>LCKCTL</code></p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>LCKCTL</code> opens a pop-up menu containing lock controls.</p>
<h3 id="lckmtr">LCKMTR</h3>
<p>Enable lock meter</p>
<p>Category: Lock</p>
<p>Format: <code>LCKMTR</code></p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>LCKMTR</code> enables the lock meter.</p>
<h3 id="lckval">LCKVAL</h3>
<p>Read lock value</p>
<p>Category: Lock</p>
<p>Format: <code>LCKVAL</code></p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>LCKVAL</code> displays the real and imaginary components of the current lock value as informational messages.</p>
<h3 id="lclarg">LCLARG</h3>
<p>Set local argument value</p>
<p>Category: Arguments</p>
<p>Format: <code>LCLARG</code> nam val</p>
<p>Defaults: temp current</p>
<p>Description:
<code>LCLARG</code> is an old command for defining local arguments. It has been replaced with the <code>DFNLCL</code> command and is
currently simply an alias to it. As such <code>DFNLCL</code> should be used in place of <code>LCLARG</code>.</p>
<h3 id="lcldl">LCLDL</h3>
<p>Delete local argument</p>
<p>Category: Arguments</p>
<p>Format: <code>LCLDL</code> first last</p>
<p>Defaults: temp first</p>
<p>Description:
<code>LCLDL</code> is an old command for deleting global arguments. It has been replaced with the <code>REMLCL</code> command and is currently
simply an alias to it. As such <code>REMLCL</code> should be used in place of <code>LCLDL</code>.</p>
<h3 id="li">LI</h3>
<p>Increment pulse programmer loop value</p>
<p>Category: Experiment</p>
<p>Format: <code>LI</code> loop incr</p>
<p>Defaults: 1 1</p>
<p>Prerequisites: Pulse program loaded (LOAD), RNMRA Only</p>
<p>Description:
<code>LI</code> is an old command for incrementing a loop value by an integer incr. It has been replaced with the <code>LOOP /INCR</code>
command and is currently simply an alias to it. As such <code>LOOP /INCR</code> should be used in place of <code>LI</code>.</p>
<h3 id="lim">LIM</h3>
<p>Set processing buffer display limits</p>
<p>Category: Display Control</p>
<p>Format: <code>LIM</code> llim rlim</p>
<p>Defaults: current current</p>
<p>Description:
<code>LIM</code> sets the display limits for the visible processing buffer. <code>LIM</code> takes two parameters, llim and rlim, which are
the left and right display limits, respectively. These limits are expressed in the current unit for the visible
processing buffer. If llim or rlim is omitted RNMR will prompt for it with the current left or right display limit as a
default. A value outside of the dataset or "*" will use the leftmost or rightmost point in the buffer. Values that are
within the range of the dataset but that do not correspond exactly to a point will use the closest point to the right of
the specified value.</p>
<h3 id="lima">LIMA</h3>
<p>Set acquisition buffer display limits</p>
<p>Category: Display Control</p>
<p>Format: <code>LIMA</code> llim rlim</p>
<p>Defaults: current current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>LIMA</code> sets the display limits for the acquisition buffer. <code>LIMA</code> takes two parameters, llim and rlim, which are the
left and right display limits, respectively. These limits are expressed in the current unit for the acquisition buffer.
If llim or rlim is omitted RNMR will prompt for it with the current left or right display limit as a default. A value
outside of the dataset or "*" will use the leftmost or rightmost point in the buffer. Values that are within the range
of the dataset but that do not correspond exactly to a point will use the closest point to the right of the specified
value.</p>
<h3 id="limb">LIMB</h3>
<p>Set blocked record display limits</p>
<p>Category: Display Control</p>
<p>Format: <code>LIMB</code> rec dim llim rlim</p>
<p>Defaults: rrec 1 current current</p>
<p>Description:
<code>LIMB</code> sets display limits for a <a href="../syntax/#blocked_records">blocked record</a> along a specified dimension. The parameters
llim and rlim are the left and right display limits. If no <a href="../syntax/#records">record number</a> is specified RNMR will
prompt for it with the current read record pointer (as displayed and set by <code>PTRA</code>) as the default. <code>LIMB</code> may only be
used on blocked records. If dim is omitted RNMR will prompt for it with 1 as a default. The value of dim cannot exceed
the number of dimensions in the blocked record. If llim or rlim is omitted RNMR will prompt for it with the current
left or right display limit as a default. A value outside of the dataset or "*" will use the leftmost or rightmost
point available. Values that are within the range of the dataset but that do not correspond exactly to a point will use
the closest point to the right of the specified value.</p>
<h3 id="log">LOG</h3>
<p>Write line to log</p>
<p>Category: Misc.</p>
<p>Format: <code>LOG</code> line</p>
<p>Defaults: none</p>
<p>Prerequisites: Logging enabled</p>
<p>Description:
<code>LOG</code> writes a line to the logging window. If no line is specified RNMR will prompt for it. <code>LOG</code> cannot be used unless
logging is enabled (<code>SET LOG ON</code>).</p>
<h3 id="loop">LOOP</h3>
<p>Set or increment pulse program loop counter</p>
<p>Category: Experiment</p>
<p>Format: <code>LOOP</code> loop val</p>
<p>Qualifiers: /INCR</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: 1 current/1</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA Only</p>
<p>Description:
<code>LOOP</code> either sets a pulse program loop to val or if /INCR is used increments it by val. If loop is omitted RNMR will
prompt for it with 1 as a default. If val is omitted RNMR will prompt for it with the current loop value as the default
unless /INCR is used in which case RNMR will not prompt for val and will increment the loop by 1.</p>
<p>The final loop value must be between 0 and 65,535 inclusive. If /INCR is used <code>LOOP</code> will display the final loop value
as an informational message.</p>
<h3 id="lp">LP</h3>
<p>List processing buffer parameters</p>
<p>Category: Misc.</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Format: <code>LP</code> buf</p>
<p>Defaults: 1</p>
<p>Description:
<code>LP</code> displays a summary of processing buffer parameter values. When processing spectrometer data offline, many
experimental parameters can only be determined from the <code>LP</code> summary since RNMRP lacks commands to display and set many
acquisition parameters. The exact format of the <code>LP</code> summary varies from spectrometer to spectrometer due to differences
in implementation of RNMR-controlled hardware. <code>LP</code> takes one parameter, buf, which is the number of the processing
buffer whose parameters will be listed. Processing buffer 1 is the visible buffer while the contents of the other
processing buffers are not visible on the display. If buf is omitted from the command line, RNMR will list the
parameters of buffer 1; RNMR does not prompt the user for buf.</p>
<p>The following buffer parameters are listed in the <code>LP</code> display:</p>
<p>CURRENT BUFFER TITLE</p>
<p>ARCHIVE, RECORD, BLOCK NUMBER, OWNER, AND DATE:
Direction 1 is always indicated by "*" in the block number display and corresponds to the dimension visible on the
screen for one-dimensional displays. For example, if record 5 is a two-dimensional blocked record and <code>DIRB</code> 2 is
currently 12, the <code>LP</code> summary will include the line:</p>
<pre><code>TEMP     5     (*    ,   1)
</code></pre>
<p>when listing block 1 of record 5 in archive TEMP. Conversely, if <code>DIRB</code> 2 is set to 21, the summary will include:</p>
<pre><code>TEMP     5     (1    ,   * )
</code></pre>
<p>to indicate that direction 1 is mapped to dimension 2. If the record containing the data in buffer buf is one
dimensional, no block numbers will be reported.</p>
<p>SYNTHESIZER PARAMETERS:
For each synthesizer, RNMR lists its nucleus, its Hertz-to-PPM multiplicative factor (nominal NMR frequency), PPM
reference frequency, and offset (as set by the <code>F</code> command). Both the offset and the PPM reference frequency are
reported in Hz to a maximum of one decimal place. The PPM reference frequency is defined as the frequency in Hz of zero
PPM. RNMR also indicates the mapping between physical and logical channels (as set by the <code>CHN</code> command) and which
synthesizer is mapped to dimension 1 (the observe dimension).</p>
<p>TRANSMITTER PARAMETERS:
A series of parameters are listed for each transmitter. Three categories of parameters (FMX, PSX, and PWX) are presented
in a similar format. First the name of the program (the last loaded by <code>FMXEX</code> etc) is listed. Then the value of 64
FMX/PSWX/PWX values are listed. Finally the low and high coarse power levels as set by <code>PWR</code> are listed. These
parameters are listed separately for each transmitter.</p>
<p>RECEIVER PARAMETERS:
The following set of receiver parameters will be listed:</p>
<ul>
<li>Gain</li>
<li>Spectral width</li>
<li>Filter factor</li>
<li>Size</li>
<li>Acquisition time</li>
</ul>
<p>PULSE PROGRAMMER PARAMETERS:
The pulse program name will be listed followed by 64 pulse values, 64 delay values, 64 loop values, and 64 flag states.
The recycle delay is also listed.</p>
<p>ACQUISITION MODES:
The averager acquisition modes (<code>AMD /ACQ</code>, or simply <code>AMD</code>) are listed so that the number of modes is equal to the
buffer <code>NAMD /ACQ</code> value. That is, regardless of how the <code>AMD</code> modes were entered by the user, <code>NAMD</code> modes will be
displayed. These modes represent the receiver phase cycle sequence.</p>
<p>BLOCKED ACQUISITION MODES:
The blocked acquisition modes (<code>AMD /BLK</code>) are listed so that the number of modes is equal to the buffer <code>NAMD /BLK</code>
value. That is, regardless of how the <code>AMD /BLK</code> modes were entered by the user, <code>NAMD /BLK</code> modes will be displayed.
These modes represent the hypercomplex acquisition receiver phase cycling sequence.</p>
<p>PULSE PROGRAMMER MODES:
The ppmd values for each step of the phase cycle are listed. There will be 16 lists of values.</p>
<p>BLOCKED ACQUISITION PULSE PROGRAMMER MODES:
The block ppmd values for each step of the phase cycle are listed. There will be 16 lists of values.</p>
<p>NAMD PARAMETERS:
The following set of receiver parameters will be listed:</p>
<ul>
<li>Number of acquisition phase cycle modes</li>
<li>Number of block phase cycle modes</li>
<li>Number of TPPI modes</li>
<li>Number of incr modes</li>
</ul>
<p>ACCUMULATION PARAMETERS:
The following set of accumulation parameters will be listed:</p>
<ul>
<li>Number of dummy scans performed</li>
<li>Number of scans averaged</li>
</ul>
<p>PROCESSING PARAMETERS:
The following set of processing parameters will be listed:</p>
<ul>
<li>Number of dimensions</li>
<li>Domain,</li>
<li>Size</li>
<li>Display limits</li>
<li>Phase correction factors</li>
<li>Scale factor</li>
</ul>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lpa">LPA</h3>
<p>List acquisition buffer parameters</p>
<p>Category: Acquisition</p>
<p>Format: <code>LPA</code></p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>LPA</code> displays a summary of processing buffer parameter values. These parameters are the latest settings of the pulse
programmer, averager, and other spectrometer hardware.  The exact format of the <code>LPA</code> summary varies from spectrometer
to spectrometer due to differences in implementation of RNMR-controlled hardware.</p>
<p>The following buffer parameters are listed in the <code>LPA</code> printout:</p>
<p>CURRENT BUFFER TITLE</p>
<p>USER AND DATE</p>
<p>SYNTHESIZER PARAMETERS:
For each synthesizer, RNMR lists its nucleus, its Hertz-to-PPM multiplicative factor (nominal NMR frequency), PPM
reference frequency, and offset (as set by the <code>F</code> command). Both the offset and the PPM reference frequency are
reported in Hz to a maximum of one decimal place. The PPM reference frequency is defined as the frequency in Hz of zero
PPM. RNMR also indicates the mapping between physical and logical channels (as set by the <code>CHN</code> command) and which
synthesizer is mapped to dimension 1 (the observe dimension).</p>
<p>TRANSMITTER PARAMETERS:
A series of parameters are listed for each transmitter. Three categories of parameters (FMX, PSX, and PWX) are presented
in a similar format. First the name of the program (the last loaded by <code>FMXEX</code> etc) is listed. Then the value of 64
FMX/PSWX/PWX values are listed. Finally the low and high coarse power levels as set by <code>PWR</code> are listed. These
parameters are listed separately for each transmitter.</p>
<p>RECEIVER PARAMETERS:
The following set of receiver parameters will be listed:</p>
<ul>
<li>Gain</li>
<li>Spectral width</li>
<li>Filter factor</li>
<li>Size</li>
<li>Acquisition time</li>
</ul>
<p>LOCK PARAMETERS:
The following set of lock parameters will be listed:</p>
<ul>
<li>Status (ON/OFF)</li>
<li>Sweep (ON/OFF)</li>
<li>Power</li>
<li>Gain</li>
<li>Sweep width</li>
<li>Position</li>
<li>Receiver phase</li>
<li>TC</li>
<li>PID values</li>
<li>Meter values (min and max)</li>
</ul>
<p>PULSE PROGRAMMER PARAMETERS:
The pulse program name will be listed followed by 64 pulse values, 64 delay values, 64 loop values, and 64 flag states.
The recycle delay is also listed.</p>
<p>WAVEFORM GENERATOR PARAMETERS:
The WRF program as set by <code>WRFEX</code> is listed followed by the 64 WRF values for each WFG. Then the WWF program as set by
<code>WWFEX</code> is listed followed by the 64 WWF values for each WFG.</p>
<p>ACQUISITION MODES:
The averager acquisition modes (<code>AMD /ACQ</code>, or simply <code>AMD</code>) are listed so that the number of modes is equal to the
buffer <code>NAMD /ACQ</code> value. That is, regardless of how the <code>AMD</code> modes were entered by the user, <code>NAMD</code> modes will be
displayed. These modes represent the receiver phase cycle sequence.</p>
<p>BLOCKED ACQUISITION MODES:
The blocked acquisition modes (<code>AMD /BLK</code>) are listed so that the number of modes is equal to the buffer <code>NAMD /BLK</code>
value. That is, regardless of how the <code>AMD /BLK</code> modes were entered by the user, <code>NAMD /BLK</code> modes will be displayed.
These modes represent the hypercomplex acquisition receiver phase cycling sequence.</p>
<p>PULSE PROGRAMMER MODES:
The ppmd values for each step of the phase cycle are listed. There will be 16 lists of values.</p>
<p>BLOCKED ACQUISITION PULSE PROGRAMMER MODES:
The block ppmd values for each step of the phase cycle are listed. There will be 16 lists of values.</p>
<p>NAMD PARAMETERS:
The following set of receiver parameters will be listed:</p>
<ul>
<li>Number of acquisition phase cycle modes</li>
<li>Number of block phase cycle modes</li>
<li>Number of TPPI modes</li>
<li>Number of incr modes</li>
</ul>
<p>ACCUMULATION PARAMETERS:
The following set of accumulation parameters will be listed:</p>
<ul>
<li>Number of shots between display update</li>
<li>Number of dummy scans performed</li>
<li>Number of scans to wait with <code>WAIT</code> command</li>
<li>Number of scans to acquire (<code>NA</code>)</li>
<li>Number of scans acquired</li>
</ul>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lpb">LPB</h3>
<p>Perform backward linear prediction on FID</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>LPB</code> rlim m n</p>
<p>Defaults: 1 MIN((SIZE-RLIM)/4,8) Min((SIZE-RLIM)-M,512)</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>LPB</code> performs backwards linear prediction on an FID in the visible processing buffer. Based on the specified number of
current data points, <code>LPB</code> calculates the values of the FID at earlier times. In a linear prediction calculation the
points in the FID are modelled as a linear combination of an adjacent series of points in the FID. In the case of
backwards linear prediction these points come after the point to be predicted. A set of coefficients used in this
linear combination is fit such that this linear combination is accurate for a set of known good points in the FID and
then in the case of backward linear prediction, they are used to replace points at the beginning of the FID.</p>
<p>The first parameter, rlim, is the number of points to replace at the beginning of the FID. If rlim is omitted RNMR will
not prompt for it and will replace only the first point in the FID. The value of rlim cannot exceed an eighth of the
size of the FID.</p>
<p>The second parameter, m, specifies how many known points are used for fitting the linear prediction coefficients. If m
is omitted RNMR will not prompt for it and will use either a quarter of the points that are not to be replaced or 8
whichever is smaller. The value of m may not exceed 32 or the number of points that are not being replaced.</p>
<p>The third parameter, n, is the number of points to take a linear combination of and therefore the number of coefficients
to fit. For example if rlim is 1 then the first point will be replaced with a linear combination of points 2 to m+1. If
n is not specified RNMR will not prompt for it and will use either the number of points that are not to be replaced
minus m or 512 whichever is smaller.</p>
<p>The linear prediction process is based around the following linear equation:</p>
<pre><code>X*COEF=DATA(RLIM+1:RLIM+M)
</code></pre>
<p>X is a M by N matrix where X(I,J)=DATA(I+J+RLIM). COEF is a N element vector of unknown coefficients. This models each
of the M points after rlim as a linear combination of the N points that follow it. The COEFF values are solved for using
a singular value decomposition (SVD) of X. Once the coefficients are known RNMR fills in the points from rlim back to
the beginning of the FID. That is the point rlim is predicted using the N points after it and then the point to the left
of rlim is predicted using the N points after it (including the predicted value of point rlim) and so on until all the
points are predicted.</p>
<h3 id="lpc">LPC</h3>
<p>Perform long pulse phase and amplitude correction</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>LPC</code> flip fnyq fnull</p>
<p>Defaults: 90.0 first -fnyq</p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>LPC</code> performs a long pulse correction apodization, correcting both the amplitude and phase of a spectrum in the visible
processing buffer. This apodization is intended to alleviate distortions caused by incomplete excitation of the spectrum
by weak pulses.</p>
<p>The first argument of <code>LPC</code> is flip, the on-resonance flip angle of the pulse used to excite the spectrum. If this
parameter is not specified on the command line, RNMR will prompt for a flip angle with a default of 90 degrees. The
value of flip must be between 0.0 and 90.0 degrees.</p>
<p>The second parameter, fnyq, is the frequency of the point in the spectrum that corresponds to the Nyquist frequency. If
fnyq is omitted, RNMR will prompt for it with the frequency of the first point in the buffer as a default. The value of
fnyq must be greater than the carrier frequency.</p>
<p>The third parameter, fnull, is the frequency within the spectrum of the first null in the RF excitation, which is also a
measure of the RF field strength. If fnull is omitted RNMR will prompt for it with the fnyq mirrored across the carrier
as a default. The value of fnull is restricted such that the following relationship holds:</p>
<pre><code>0.1 ≤ ABS(FNULL-OFFSET)/(FNYQ-OFFSET) ≤ 2.0
</code></pre>
<p>Both fnyq and fnull are specified in the current frequency unit (as set and displayed by <code>UNIT /FREQ</code>).</p>
<h3 id="lpca">LPCA</h3>
<p>Perform long pulse amplitude correction</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>LPCA</code> flip fnyq fnull</p>
<p>Defaults: 90.0 first -fnyq</p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>LPCA</code> performs the amplitude portion of long pulse correction apodization on a spectrum in the visible processing
buffer. This apodization is intended to alleviate distortions caused by incomplete excitation of the spectrum by weak
pulses.</p>
<p>The first argument of <code>LPCA</code> is flip, the on-resonance flip angle of the pulse used to excite the spectrum. If this
parameter is not specified on the command line, RNMR will prompt for a flip angle with a default of 90 degrees. The
value of flip must be between 0.0 and 90.0 degrees.</p>
<p>The second parameter, fnyq, is the frequency of the point in the spectrum that corresponds to the Nyquist frequency. If
fnyq is omitted, RNMR will prompt for it with the frequency of the first point in the buffer as a default. The value of
fnyq must be greater than the carrier frequency.</p>
<p>The third parameter, fnull, is the frequency within the spectrum of the first null in the RF excitation, which is also a
measure of the RF field strength. If fnull is omitted RNMR will prompt for it with the fnyq mirrored across the carrier
as a default. The value of fnull is restricted such that the following relationship holds:</p>
<pre><code>0.1 ≤ ABS(FNULL-OFFSET)/(FNYQ-OFFSET) ≤ 2.0
</code></pre>
<p>Both fnyq and fnull are specified in the current frequency unit (as set and displayed by <code>UNIT /FREQ</code>).</p>
<h3 id="lpcp">LPCP</h3>
<p>Perform long pulse phase correction</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>LPCP</code> flip fnyq fnull</p>
<p>Defaults: 90.0 first -fnyq</p>
<p>Prerequisites: Frequency domain data in processing buffer 1 (FREQ)</p>
<p>Description:
<code>LPCP</code> performs the phase portion of long pulse correction apodization on a spectrum in the visible processing buffer.
This apodization is intended to alleviate distortions caused by incomplete excitation of the spectrum by weak pulses.</p>
<p>The first argument of <code>LPCP</code> is flip, the on-resonance flip angle of the pulse used to excite the spectrum. If this
parameter is not specified on the command line, RNMR will prompt for a flip angle with a default of 90 degrees. The
value of flip must be between 0.0 and 90.0 degrees.</p>
<p>The second parameter, fnyq, is the frequency of the point in the spectrum that corresponds to the Nyquist frequency. If
fnyq is omitted, RNMR will prompt for it with the frequency of the first point in the buffer as a default. The value of
fnyq must be greater than the carrier frequency.</p>
<p>The third parameter, fnull, is the frequency within the spectrum of the first null in the RF excitation, which is also a
measure of the RF field strength. If fnull is omitted RNMR will prompt for it with the fnyq mirrored across the carrier
as a default. The value of fnull is restricted such that the following relationship holds:</p>
<pre><code>0.1 ≤ ABS(FNULL-OFFSET)/(FNYQ-OFFSET) ≤ 2.0
</code></pre>
<p>Both fnyq and fnull are specified in the current frequency unit (as set and displayed by <code>UNIT /FREQ</code>).</p>
<h3 id="lpdev">LPDEV</h3>
<p>Select text printer device</p>
<p>Category: Printing</p>
<p>Format: <code>LPDEV</code> device</p>
<p>Defaults: current</p>
<p>Description:
<code>LPDEV</code> sets the device to use for text printing. The currently available printing devices are:</p>
<ul>
<li>E460A</li>
<li>E460B</li>
<li>LJ2430</li>
<li>LJ2430B</li>
<li>LJ4050</li>
<li>LJ5</li>
</ul>
<p>If no device is specified RNMR will prompt for it with the current text printing device as a default. If the text
printing device is changed (device is not the current device) RNMR will set the text printing flag (as set and displayed
by <code>SET LP</code>) on, indicating that text should be physically printed by the printing device rather than saved to the text
printing file (as set and displayed by <code>LPFIL</code>).</p>
<h3 id="lpf">LPF</h3>
<p>Perform forward linear prediction on FID</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>LPF</code> rlim m n</p>
<p>Defaults: ISIZE+1 MIN(SIZE/4,8) MIN(SIZE-M,512)</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>LPF</code> performs forward linear prediction on an fid in the visible processing buffer. Based on the specified number of
current data points, <code>LPF</code> calculates values to extend the FID. In a linear prediction calculation the points in the FID
are modelled as a linear combination of an adjacent series of points in the FID. In the case of forward linear
prediction these points come before the point to be predicted. A set of coefficients used in this linear combination is
fit such that this linear combination is accurate for a set of known good points in the FID and then in the case of
forward linear prediction, they are used to extend the FID.</p>
<p>By using forward linear prediction, one may decrease the number of data points in a given dimension that must be
acquired to avoid truncation errors. This ability is particularly useful in obtaining multidimensional data sets since
the number of slices that must be physically acquired, and thus the spectrometer time required, is reduced. For
well-behaved FID's, the number of data points may often be doubled with forward linear prediction.</p>
<p>The first parameter, rlim, is the number of points desired after linear prediction. <code>LPF</code> will calculate points SIZE+1
through rlim based on a specified number of points in the original FID. if rlim is omitted only one point will be
predicted. The value of rlim cannot be smaller than the current size of the FID (as shown by <code>SHOW BUF SIZE</code>) or larger
than the allocated size of the buffer (as displayed and set by <code>DBSZ</code>).</p>
<p>The second parameter, m, specifies how many known points are used for fitting the linear prediction coefficients. If m
is omitted RNMR will not prompt for it and will use either a quarter of the FID or 8 whichever is smaller. The value of
m may not exceed 32 or the number of points in the FID.</p>
<p>The third parameter, n, is the number of points to take a linear combination of and therefore the number of coefficients
to fit. If n is not specified RNMR will not prompt for it and will use either the size of the FID minus m or 512
whichever is smaller.</p>
<p>The linear prediction process is based around the following linear equation:</p>
<pre><code>X*COEF=DATA(N+1:N+M)
</code></pre>
<p>X is a M by N matrix where X(I,J)=DATA(I+J-1). COEF is a N element vector of unknown coefficients. This models each of
the M points after point N as a linear combination of the N points that precede it. The COEFF values are solved for
using a singular value decomposition (SVD) of X. Once the coefficients are known RNMR fills in the points from SIZE+1 to
rlim. That is the point just after the FID is predicted using the N before after it and then point SIZE+2 is predicted
using the N points before it (including the predicted value of point SIZE+1) and so on until all the points out to rlim
are predicted. This process will change the active size of the buffer to rlim.</p>
<h3 id="lpfil">LPFIL</h3>
<p>Set text printer file</p>
<p>Category: Printing</p>
<p>Format: <code>LPFIL</code> fspec</p>
<p>Defaults: current</p>
<p>Description:
<code>LPFIL</code> selects a file to use as the destination for printing text. Commands that would print text can write to the file
instead of sending the text to a printer. Subsequent text printing commands will overwrite the file. If no file is
specified RNMR will prompt for it with the current text printer file as a default.</p>
<p>If the text printer file is changed (fspec is not the current fspec) RNMR will set the text printer flag (as set and
displayed by <code>SET LP</code>) off, indicating that text should be saved to the text printing file rather than physically
printed by the printer device (as set and displayed by <code>LPDEV</code>).</p>
<h3 id="lpk">LPK</h3>
<p>List Peaks</p>
<p>Category: Data Analysis</p>
<p>Format: <code>LPK</code></p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Description:
<code>LPK</code> displays a list of peak positions and intensities for the first 50 peaks in the visible processing buffer within
the current display limits (<code>LIM</code>) above the current peak pick threshold (<code>TH</code>).</p>
<p>The first line displayed by <code>LPK</code> will be the current buffer title. The following line will contain the archive, record,
block number, owner, and date. Direction 1 is always indicated by "*" in the block number display and corresponds to
the dimension visible on the screen for one-dimensional displays. For example, if record 5 is a two-dimensional blocked
record and <code>DIRB</code> 2 is currently 12, the <code>LPK</code> display will include the line:</p>
<pre><code>TEMP     5     (*    ,   1)
</code></pre>
<p>when listing block 1 of record 5 in archive TEMP. Conversely, if <code>DIRB</code> 2 is set to 21, the display will include:</p>
<pre><code>TEMP     5     (1    ,   * )
</code></pre>
<p>to indicate that direction 1 is mapped to dimension 2. If the record containing the data in the buffer is one
dimensional, no block numbers will be reported.</p>
<p><code>LPK</code> lists peaks in the real part of the buffer unless viewing the imaginary part (<code>BUF IMAG</code>). Peaks are located and
listed only for the first block of the visible processing buffer between the current display limits (as set and
displayed by <code>LIM</code>). The peaks will be listed in order from left to right in the display. For each peak a line will be
displayed with four values (peak number, position in current frequency units, position in default frequency units,
intensity). A point is considered a peak if its magnitude is greater than the peak picking threshold (as set and
displayed by <code>TH</code>) and it is either a local maximum or minimum if its intensity is greater or less than zero
respectively.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lpk2d">LPK2D</h3>
<p>List peaks in two dimensions</p>
<p>Category: Data Analysis</p>
<p>Format: <code>LPK2D</code> rec slice</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>LPK2D</code> displays a list of peak positions and intensities for the first 250 peaks found within a 2D slice of a
<a href="../syntax/#blocked_records">blocked record</a> above the current peak pick threshold (<code>TH</code>). Only peaks within the current
display limits (as set and shown by the command <code>LIMB</code>) will be listed by <code>LPK2D</code>.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will list peaks from the first 2D slice of the record.</p>
<p>Each <code>LPK2D</code> display begins with a header which includes the buffer title, record and block numbers, record owner, and
date, as well as titles for each column specifying the domain (time or frequency) in each direction and units for the
peak data to follow.  When reading the record and block number at the top of the <code>LPK2D</code> display, note that directions
1 and 2 are always indicated by "*" in the block number display and correspond to the dimensions searched for peaks by
<code>LPK2D</code>. For example, if record 5 has three dimensions and <code>DIRB 3</code> is currently 123, the <code>LPK2D</code> summary will include
the line:</p>
<pre><code>REC     5       (*    ,*    ,1)
</code></pre>
<p>when listing the peaks in block 1 of record 5. Conversely, if <code>DIRB 3</code> is set  to 321, the summary will include:</p>
<pre><code>REC     5       (1    ,*    ,* )
</code></pre>
<p>to indicate that direction 3 is mapped to dimension 1. If rec has only two dimensions, RNMR will not display any block
numbers.</p>
<p>RNMR limits the number of points in direction 1 to a maximum of 4096. This size can be checked using <code>SIZEB</code>. <code>LPK2D</code>
lists 2D peaks in the real part of the record unless currently viewing the imaginary part of the visible processing
buffer (<code>BUF IMAG</code>). A point is considered a peak if its magnitude is greater than the peak picking threshold (as set
and displayed by <code>TH</code>) and it is either a local maximum or minimum if its intensity is greater or less than zero
respectively. By setting <code>CONMD</code> to POS, NEG, or ABS beforehand, the user may modify the selection of 2D peaks for a
given threshold value. For each peak a line will be displayed containing the peak number, the position in each dimension
in the current and default frequency units and the peak intensity.</p>
<p>The qualifiers specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="ls">LS</h3>
<p>Set pulse programmer loop value</p>
<p>Category: Experiment</p>
<p>Format: <code>LS</code> loop val</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD) RNMR only</p>
<p>Description:
<code>LS</code> is an old command for setting a pulse programmer loop value. It has been replaced with the <code>LOOP</code> command and is
currently simply an alias to it. As such <code>LOOP</code> should be used in place of <code>LS</code>.</p>
<h3 id="lstdp">LSTDP</h3>
<p>Define list from display</p>
<p>Category: Lists</p>
<p>Format: <code>LSTDP</code> nam</p>
<p>Defaults: temp</p>
<p>Prerequisites: Processing buffer visible (VIEW PRO)</p>
<p>Description:
<code>LSTDP</code> is used to fill a list nam with time or frequency values specified interactively via the display. If nam is
omitted RNMR will prompt for it with temp as a default. The contents of the specified list will be overwritten. The
following subcommands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>Move to bottom of list</td>
</tr>
<tr>
<td>D</td>
<td>Delete entry</td>
</tr>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>I</td>
<td>Insert current cursor position into list</td>
</tr>
<tr>
<td>L</td>
<td>Move up one entry</td>
</tr>
<tr>
<td>N</td>
<td>Move down one entry</td>
</tr>
<tr>
<td>T</td>
<td>Move to top of list</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>Z</td>
<td>Call <code>ZO</code> to enable moving the cursor</td>
</tr>
</tbody>
</table>
<p>The list cannot exceed ten entries and attempts to add more values to it will fail.</p>
<h3 id="lstfil">LSTFIL</h3>
<p>List contents of a text file</p>
<p>Category: File IO</p>
<p>Format: <code>LSTFIL</code> fspec</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: temp.dat</p>
<p>Description:
<code>LSTFIL</code> lists the contents of a text file fspec. If fspec is omitted RNMR will prompt for it with temp.dat as a
default. <code>LSTFIL</code> displays the contents of a file in a read only fashion; the file cannot be changed. The qualifiers
specify how the list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lstlst">LSTLST</h3>
<p>List contents of a list</p>
<p>Category: Lists</p>
<p>Format: <code>LSTLST</code> nam</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: temp</p>
<p>Description:
<code>LSTLST</code> lists the contents of a list nam. If nam is omitted RNMR will prompt for it with temp as a default. <code>LSTLST</code>
displays the contents of a list in a read only fashion; the list cannot be changed. The qualifiers specify how the list
is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lstmac">LSTMAC</h3>
<p>List contents of a macro</p>
<p>Category: Macros</p>
<p>Format: <code>LSTMAC</code> nam</p>
<p>Qualifiers: /PRT /TTY /WND /WRT</p>
<p>Qualifier Defaults: /WND</p>
<p>Defaults: temp</p>
<p>Description:
<code>LSTMAC</code> lists the contents of a macro nam. If nam is omitted RNMR will prompt for it with temp as a default. <code>LSTMAC</code>
displays the contents of a macro in a read only fashion; the macro cannot be changed. The qualifiers specify how the
list is output as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>/PRT</td>
<td>Print the list to the printer device as specified by <code>LPDEV</code></td>
</tr>
<tr>
<td>/TTY</td>
<td>Print the list to the RNMR command line, one line at a time. Press &lt;RETURN> or &lt;SPACE> to print the next line. Press "Q" or &lt;CTRL-Z> to quit.</td>
</tr>
<tr>
<td>/WND</td>
<td>Display the list in a pop-up window. This is the default behavior.</td>
</tr>
<tr>
<td>/WRT</td>
<td>Write the list to a <code>WRT</code> file. Errors if no file is open to write to.</td>
</tr>
</tbody>
</table>
<h3 id="lw">LW</h3>
<p>Calculate line width</p>
<p>Category: Data Analysis</p>
<p>Format: <code>LW</code> llim rlim pcnt_ht</p>
<p>Defaults: lcursor rcursor 50</p>
<p>Description:
<code>LW</code> calculates the width of a peak. <code>LW</code> will search from left to right between llim and rlim and selects the first
peak above the peak picking threshold as set and displayed by <code>TH</code>. If llim or rlim is not specified RNMR will not
prompt for it and will use the current cursor positions. The third parameter pcnt_ht is a the percentage of the peak
height at which the linewidth is measured. If pcnt_ht is omitted RNMR will not prompt for it and will use 50 percent.</p>
<h2 id="m">M</h2>
<hr />
<h3 id="macarg">MACARG</h3>
<p>Redefine names of positional macro arguments</p>
<p>Category: Arguments</p>
<p>Format: <code>MACARG</code> nam...</p>
<p>Defaults: none</p>
<p>Description:
<code>MACARG</code> renames local arguments created to hold the positional arguments passed into a macro. By default when a macro
is called with positional arguments they are stored in local arguments 1, 2, 3, etc. <code>MACARG</code> accepts a series of names
as arguments. The default argument names are replaced with the names passed to <code>MACARG</code>. The number of names need not
match the number of numbered arguments. Any names with no corresponding number local will be ignored.</p>
<h3 id="mag">MAG</h3>
<p>Calculate magnitude of data</p>
<p>Category: Data Transforms</p>
<p>Format: <code>MAG</code></p>
<p>Description:
<code>MAG</code> calculates the magnitude of the data in the visible processing buffer. The magnitude is placed in the real part of
the buffer and the imaginary part of the buffer is set to 0. The magnitude is defined as follows:</p>
<pre><code>MAG = SQRT(REAL^2 + IMAG^2)
</code></pre>
<h3 id="mapn">MAPN</h3>
<p>Append text to macro</p>
<p>Category: Macros</p>
<p>Format: <code>MAPN</code> nam</p>
<p>Defaults: TEMP</p>
<p>Description:
<code>MAPN</code> is an old command for appending lines of text to a macro. It has been replaced with the <code>APNMAC</code> command and is
currently simply an alias to it. As such <code>APNMAC</code> should be used in place of <code>MAPN</code>.</p>
<h3 id="mascmd">MASCMD</h3>
<p>Send command to MAS controller</p>
<p>Category: Hardware</p>
<p>Format: <code>MASCMD</code> cmd arg</p>
<p>Defaults: test</p>
<p>Description:
<code>MASCMD</code> sends a command to the MAS controller and for some commands prints the response as an informational message.
Some commands require additional arguments to be sent to the MAS controller. If no command is specified RNMR will prompt
for one with test as a default. The following commands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
<th>Args</th>
<th>Responses</th>
</tr>
</thead>
<tbody>
<tr>
<td>AUTO</td>
<td>Switch to auto mode</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>BEAR</td>
<td>Set bearing pressure</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>BEAR_A</td>
<td>Get bearing pressure</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>BEAR_D</td>
<td>Get bearing set point</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>BEARS_A</td>
<td>Get bearing sense pressure</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>DRIVE</td>
<td>Set drive pressure</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>DRIVE_A</td>
<td>Get drive pressure</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>DRIVE_D</td>
<td>Get drive set point</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>GOSET</td>
<td>Go to the set spin rate</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>MAIN_A</td>
<td>Get main pressure</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>MANUAL</td>
<td>Switch to manual mode</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>MINMAIN</td>
<td>Set minimum main pressure</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>SPIN</td>
<td>Set spin rate</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>SPIN_A</td>
<td>Get spin rate</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>SPIN_D</td>
<td>Get set spin rate</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>TEST</td>
<td>Test connection</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="maxv">MAXV</h3>
<p>Calculate maximum</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>MAXV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>MAXV</code> replaces the contents of <a href="../syntax/#buffers">processing buffer</a> dst with the maximum of buffers src and dst.</p>
<pre><code>DST = MAX(DST,SRC)
</code></pre>
<p>The comparison is pointwise and based on magnitudes. If either argument is omitted, RNMR will prompt for a buffer
number. The default source is buffer 2 while the default destination is buffer 1. The src and dst buffers must have the
same domain and active size (though not necessarily the same allocated size).</p>
<h3 id="mcpy">MCPY</h3>
<p>Copy macro</p>
<p>Category: Macros</p>
<p>Format: <code>MCPY</code> name1 name2</p>
<p>Defaults: temp temp</p>
<p>Description:
<code>MCPY</code> is an old command for copying a macro. It has been replaced with the <code>CPYMAC</code> command and is currently simply an
alias to it. As such <code>CPYMAC</code> should be used in place of <code>MCPY</code>.</p>
<h3 id="md">MD</h3>
<p>Define macro</p>
<p>Category: Macros</p>
<p>Format: <code>MD</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>MD</code> is an old command for defining to a macro. It has been replaced with the <code>CRTMAC</code> command and is currently simply
an alias to it. As such <code>CRTMAC</code> should be used in place of <code>MD</code>.</p>
<h3 id="mdl">MDL</h3>
<p>Delete macro</p>
<p>Category: Macros</p>
<p>Format: <code>MDL</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>MDL</code> is an old command for deleting a macro. It has been replaced with the <code>REMMAC</code> command and is currently simply an
alias to it. As such <code>REMMAC</code> should be used in place of <code>MDL</code>.</p>
<h3 id="me">ME</h3>
<p>Edit macro</p>
<p>Category: Macros</p>
<p>Format: <code>ME</code> macnam</p>
<p>Defaults: temp</p>
<p>Description:
<code>ME</code> is an old command for editing a macro. It has been replaced with the <code>EDTMAC</code> command and is currently simply an
alias to it. As such <code>EDTMAC</code> should be used in place of <code>ME</code>.</p>
<h3 id="medbf">MEDBF</h3>
<p>Median baseline fix spectrum</p>
<p>Category: Baseline</p>
<p>Format: <code>MEDBF</code> window std_dev</p>
<p>Defaults: 70 5.0</p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>MEDBF</code> performs a baseline fix on a spectrum in the visible processing buffer using on algorithm presented by M.
Friedrichs, J. Biomol. NMR 5 147-153 (1995). The algorithm tracks the baseline by calculating, at each point, the median
of the extrema within a certain window size set by the argument window. This set of median values is then convoluted
with a Gaussian of standard deviation given by the argument std_dev. These final values are then subtracted from the
data values. The values of the window and the standard deviation are both in terms of points, rather than the current
units. If the window size is omitted RNMR will prompt for it with 70 as a default. If no std_dev is supplied RNMR will
prompt for it with 5.0 as a default.</p>
<p>The success of this method depends on proper choice of the window size. The window should be chosen such that the
number of local extrema arising from noise dominates the median statistic. If the window is too small and the number of
signal peaks in a given window is comparable to the number of noise peaks, the algorithm will be biased upwards and
attempt to bring the signals down to the baseline. On the other hand, if the window is too large, the baseline will not
reflect the local baseline structure. Likewise, the standard deviation should be chosen such that it is not too large
and thus broadening out the local correction over too wide a region. The user should be careful in the use of this
algorithm in cases where zero filling before Fourier transformation has taken place, since such a procedure in effect
increases the number of points between noise extrema. Zero filling to sizes 4 or more times the acquired FID are cause
for caution.</p>
<h3 id="mexit">MEXIT</h3>
<p>Exit macro</p>
<p>Category: Control Flow</p>
<p>Format: <code>MEXIT</code> vals...</p>
<p>Qualifiers: /ERROR</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>MEXIT</code> performs unconditional exit from current macro. All remaining repeats are cancelled. The values provided as
arguments to <code>MEXIT</code> will be stored as local variables at the site where the macro was called. They will be named RTN$1,
RTN$2, RT$3 etc. <code>RTNARG</code> can be used to easily rename these local variables. The /ERROR causes the macro to return as
an error causing the calling site to jump to the label set by <code>ONERR</code>.</p>
<h3 id="minv">MINV</h3>
<p>Calculates minimum</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>MINV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>MINV</code> replaces the contents of <a href="../syntax/#buffers">processing buffer</a> dst with the minimum of buffers src and dst.</p>
<pre><code>DST = MIN(DST,SRC)
</code></pre>
<p>The comparison is pointwise and based on magnitudes. If either argument is omitted, RNMR will prompt for a buffer
number. The default source is buffer 2 while the default destination is buffer 1. The src and dst buffers must have the
same domain and active size (though not necessarily the same allocated size).</p>
<h3 id="ml">ML</h3>
<p>List contents of a macro</p>
<p>Category: Macros</p>
<p>Format: <code>ML</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>ML</code> is an old command for listing the contents a macro. It has been replaced with the <code>LSTMAC</code> command and is currently
simply an alias to it. As such <code>LSTMAC</code> should be used in place of <code>ML</code>.</p>
<h3 id="mnmx">MNMX</h3>
<p>Calculate minimum and maximum in buffer region</p>
<p>Category: Data Analysis</p>
<p>Format: <code>MNMX</code> llim rlim</p>
<p>Qualifiers: /COMPLEX,/IMAG,/REAL</p>
<p>Qualifier Defaults: current_display</p>
<p>Defaults: current_display_limits</p>
<p>Description:
<code>MNMX</code> calculates the minimum and maximum of the data in the visible processing buffer within specified time or
frequency limits.</p>
<p>The parameters of the <code>MNMX</code> command are llim and rlim, the left and right data limits. These limits are specified in
the current time or frequency unit, as set and displayed by the <code>UNIT</code> command. If either or both of these limits are
omitted RNMR will not prompt for them and will use the current display limits. If either limit is beyond the size of the
dataset, the first/last point in the data set will be the limit instead.</p>
<p>If the limits are within the range of the data buffer but do not correspond to a specific data point, RNMR will set that
limit to the time or frequency of the closest data point to the right of the value specified. <code>MNMX</code> calculates the
maximum and minimum values between the adjusted limits. The values are reported as informational messages with a maximum
of two decimal places. If the values cannot be reported as floating point numbers in an eight character field, they are
reported in scientific notation.</p>
<p>The qualifiers determine which part of a complex buffer is considered as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Integrand</th>
</tr>
</thead>
<tbody>
<tr>
<td>/COMPLEX</td>
<td>Complex magnitude</td>
</tr>
<tr>
<td>/IMAG</td>
<td>Imaginary part</td>
</tr>
<tr>
<td>/REAL</td>
<td>Real part</td>
</tr>
</tbody>
</table>
<p>The default part of the buffer is the same as the current display mode as displayed and set by the <code>BUF</code> command.</p>
<h3 id="mo">MO</h3>
<p>Exit program</p>
<p>Category: Misc.</p>
<p>Format: <code>MO</code> resp</p>
<p>Defaults: no</p>
<p>Description:
<code>MO</code> is an old command for exiting RNMR. It has been replaced with the <code>EXIT</code> command and is currently simply an alias
to it. As such <code>EXIT</code> should be used in place of <code>MO</code>.</p>
<h3 id="mov">MOV</h3>
<p>Move record</p>
<p>Category: Data Storage</p>
<p>Format: <code>MOV</code> src dst</p>
<p>Defaults: rrec wrec</p>
<p>Description:
<code>MOV</code> moves data from one <a href="../syntax/#records">record</a> to another within the same archive. If no source record is
specified RNMR will prompt for it with the current read record pointer (as displayed and set by <code>PTRA</code>) as a default.
If no destination record is specified RNMR prompt will not prompt for it and will use the current write record pointer
(as displayed and set by <code>PTRA</code>) as a default. If the destination record is not free the record will be moved to the
next available record and the actual destination record will be printed as an informational message.</p>
<h3 id="movv">MOVV</h3>
<p>Move buffer</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>MOVV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>MOVV</code> replaces the contents of <a href="../syntax/#buffers">processing buffer</a> dst with the contents of buffer src.</p>
<pre><code>DST = SRC
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="mrgfs">MRGFS</h3>
<p>Merge default file with file</p>
<p>Category: File IO</p>
<p>Format <code>MRGFS</code> fspecd fspec</p>
<p>Defaults: none</p>
<p>Description:
<code>MRGFS</code> merges a default file specification fspecd with fspec. A file consists of a name and extension (separated by the
last period). The parts of the merged file specification are obtained by preferentially selecting the parts from fspec.
If a part is not present in fspec, the part in fspecd is used. If the part is not present in either input it is omitted.
The merged file specification is printed as an informational message.</p>
<h3 id="mrn">MRN</h3>
<p>Rename macro</p>
<p>Category: Macros</p>
<p>Format: <code>MRN</code> nam1 nam2</p>
<p>Defaults: temp temp</p>
<p>Description:
<code>MRN</code> is an old command for renaming a macro. It has been replaced with the <code>RENMAC</code> command and is currently
simply an alias to it. As such <code>RENMAC</code> should be used in place of <code>MRN</code>.</p>
<h3 id="msg">MSG</h3>
<p>Write message line to console</p>
<p>Category: Misc.</p>
<p>Format: <code>MSG</code> msgln</p>
<p>Defaults: None</p>
<p>Description:
<code>MSG</code> writes the contents of msgln to the console. If msgln is omitted RNMR will prompt for it.</p>
<h3 id="mulv">MULV</h3>
<p>Multiply buffer</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>MULV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>MULV</code> separately multiplies the real and imaginary contents of <a href="../syntax/#buffers">processing buffers</a> src and dst and
stores the result in dst.</p>
<pre><code>REAL(DST) = REAL(DST) * REAL(SRC)
IMAG(DST) = IMAG(DST) * IMAG(SRC)
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h2 id="n">N</h2>
<hr />
<h3 id="na">NA</h3>
<p>Set number of shots to acquire</p>
<p>Category: Experiment</p>
<p>Format: <code>NA</code> na</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>NA</code> sets the number of shots to <a href="../syntax/#acquisition">acquire</a> to na. If na is not provided RNMR will prompt for it
with the current value as a default. If na is -1 an indefinite number of scans will be collected until the user halts
the acquisition.</p>
<h3 id="nablk">NABLK</h3>
<p>Set number of acquisition blocks</p>
<p>Category: Acquisition</p>
<p>Format: <code>NABLK</code> nablk</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>NABLK</code> sets the number of blocks into which the acquisition buffer is partitioned. If nablk is not provided RNMR will
prompt for it with the current value as a default. If nablk is 0 the maximum possible number of acquisition blocks will
be used.</p>
<h3 id="namd">NAMD</h3>
<p>Set number of acquisition modes</p>
<p>Category: Pulse Control</p>
<p>Format: <code>NAMD</code> namd</p>
<p>Qualifiers: /ACQ /BLK /TPPI</p>
<p>Qualifier Defaults: /ACQ</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>NAMD</code> sets the number of acquisition and pulse program modes to use, i.e. the length of the phase cycle. If nablk is
not provided RNMR will prompt for it with the current value as a default. The /BLK qualifier is used to set the number
of block acquisition modes and is typically used to set the number of steps in hypercomplex acquisition of
multidimensional spectra. The /TPPI qualifier is used to set the number of modes for TPPI acquisition.</p>
<h3 id="nchn">NCHN</h3>
<p>Set number of channels</p>
<p>Category: Experiment</p>
<p>Format: <code>NCHN</code> nchn</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>NCHN</code> sets the number of channels to be used. If nchn is not provided RNMR will prompt for it with the current value as
a default. Note that the number of channels is also set implicitly by the <code>CHN</code> command.</p>
<h3 id="ncon">NCON</h3>
<p>Set number of contour levels</p>
<p>Category: Contours</p>
<p>Format: <code>NCON</code> ncon</p>
<p>Qualifiers: /LIN /LOG</p>
<p>Qualifier defaults: current</p>
<p>Defaults: current</p>
<p>Description:
<code>NCON</code> sets the number of contour levels to use. If ncon is omitted RNMR will prompt for it with the current value as a
default. /LIN is used for linearly spaced contours while /LOG is used for logarithmically spaced contours.</p>
<h3 id="ndec">NDEC</h3>
<p>Set number of decimal places</p>
<p>Category: Display Control</p>
<p>Format: <code>NDEC</code> unit ndec</p>
<p>Defaults: current current</p>
<p>Description:
<code>NDEC</code> sets the number of decimal places to use when displaying values with a given unit. If unit is omitted then RNMR
will prompt for it with the current time unit as a default. If ndec is omitted RNMR will prompt for it with the current
value as a default.</p>
<h3 id="ndly">NDLY</h3>
<p>Set number of dummy scans</p>
<p>Category: Experiment</p>
<p>Format: <code>NDLY</code> ndly</p>
<p>Qualifiers: /FIRST</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>NDLY</code> sets the number of dummy scans to run before starting acquisition. If ndly is omitted RNMR will prompt for it
with the current value as a default. The /FIRST qualifier allows for setting up a different number of dummy scans to be
used for the first <a href="../syntax/#acqgrp">acquisition group</a> collected by a given acquisition command. This /FIRST number of
dummy scans is only used when multiple groups are to be collected by an acquisition command.</p>
<h3 id="ndsp">NDSP</h3>
<p>Set number of shots between display update</p>
<p>Category: Acquisition</p>
<p>Format: <code>NDSP</code> ndsp</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>NDSP</code> sets the number of shots to acquire between display updates. If ndsp is omitted RNMR will prompt for it with the
current value as a default.</p>
<h3 id="neg">NEG</h3>
<p>Negates buffer</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>NEG</code></p>
<p>Description:
<code>NEG</code> replaces the contents of the visible processing buffer with itself multiplied by -1.</p>
<h3 id="ng">NG</h3>
<p>Start or resume acquisition with dummy scans</p>
<p>Category: Acquisition</p>
<p>Format: <code>NG</code> first_group last_group</p>
<p>Defaults: 1 0</p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>NG</code> <a href="../syntax/#acquisition">starts acquisition</a> without zeroing the shot counter or averager with dummy scans. This
permits continued averaging of existing data. This can be used to resume acquisition that was halted. The dummy scans
allow the initial magnetization to reach an equilibrium based on relaxation rates and the recycle delay before averaging
begins. The number of dummy scans is set by <code>NDLY</code>. If the number of shots to acquire, na, (as displayed and set by
<code>NA</code>) is not -1 the number of shots already acquired must be less than na. If the current shot counter is at 0 then <code>NG</code>
will behave like <code>DG</code> instead of its normal behavior.</p>
<p>The arguments first_group and last_group specify the range of <a href="../syntax/#acqgrp">acquisition groups</a> to acquire. If
either parameter is omitted RNMR will not prompt for it and will use 1 and 0 as defaults respectively. If last_group is
set to 0 then only first_group will be acquired.</p>
<h3 id="noise">NOISE</h3>
<p>Generate complex random noise</p>
<p>Category: Signal Generation</p>
<p>Format: <code>NOISE</code> sf</p>
<p>Defaults: 1.0</p>
<p>Description:
<code>NOISE</code> fills the visible processing buffer with randomly generated noise. The parameter sf is a scaling factor that is
applied to the noise. If sf is omitted RNMR will not prompt for it and will use 1.0 as the scaling factor.</p>
<h3 id="nop">NOP</h3>
<p>Null operation</p>
<p>Category: Misc.</p>
<p>Format: <code>NOP</code></p>
<p>Description:
<code>NOP</code> performs no operation.</p>
<h3 id="norm">NORM</h3>
<p>Set scale to normalize display</p>
<p>Category: Display Control</p>
<p>Format: <code>NORM</code></p>
<p>Description:
<code>NORM</code> rescales the data in the visible processing buffer such that the point within the display limits that has the
largest magnitude has magnitude 1.0.</p>
<h3 id="nuc">NUC</h3>
<p>Set synthesizer nucleus</p>
<p>Category: Experiment</p>
<p>Format: <code>NUC</code> chan nuc</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: For RNMRA: Acquisition stopped (HALT). For RNMRP: no restrictions</p>
<p>Description:
<code>NUC</code> assigns a nucleus to a logical. If chan is omitted, RNMR will prompt for it with 1 as a default. If no nucleus is
specified RNMR will prompt for it with the current nucleus assigned to the specified channel as a default. The nucleus
is used to look up the parameters used for tasks such as converting Hz to ppm. In RNMRA this includes determining the
frequency used for the pulses.</p>
<h3 id="nucd">NUCD</h3>
<p>Define nucleus table entry</p>
<p>Category: Frequency Control</p>
<p>Format: <code>NUCD</code> nuc hi lo</p>
<p>Defaults: unkn current(1.0) current(0.0)</p>
<p>Description:
<code>NUCD</code> defines or modifies a nucleus table entry. If no nucleus is specified RNMR will prompt for it with UNKN as a
default. The PPM to Hz conversion factor in MHz for the nucleus is set by hi. If hi is omitted RNMR will prompt for it
with a default of either the current value if the nucleus already exists or 1.0 if it does not. The reference frequency
in Hz for the nucleus is set by lo. If lo is omitted RNMR will prompt for it with a default of either the current value
if the nucleus already exists or 0.0 if it does not.</p>
<h3 id="nucdl">NUCDL</h3>
<p>Delete nucleus table entry</p>
<p>Category: Frequency Control</p>
<p>Format: <code>NUCDL</code> nuc</p>
<p>Defaults: none</p>
<p>Description:
<code>NUCDL</code> deletes the nucleus entry table for a nucleus. If nuc is not specified RNMR will prompt for it.</p>
<h3 id="nwait">NWAIT</h3>
<p>Set number of shots to wait</p>
<p>Category: Experiment</p>
<p>Format: <code>NWAIT</code> nwait</p>
<p>Defaults: current</p>
<p>Description:
<code>NWAIT</code> sets the number of shots to <a href="../syntax/#acquisition">acquire</a> when starting acquisition from a macro. If nwait is
omitted RNMR will prompt for it with the current value as a default.</p>
<h3 id="nxtdo">NXTDO</h3>
<p>Cycle macro <code>DO</code> loop</p>
<p>Category: Control Flow</p>
<p>Format: <code>NXTDO</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>NXTDO</code> skips to the beginning of the next iteration of a macro <code>DO</code> loop without executing the rest of the commands in
the loop. <code>NXTDO</code> must fall between an instance of <code>DO</code> and its matching <code>ENDDO</code>.</p>
<h2 id="o">O</h2>
<hr />
<h3 id="off">OFF</h3>
<p>Set offset from reference frequency</p>
<p>Category: Frequency Control</p>
<p>Format: <code>OFF</code> syn off</p>
<p>Defaults: current current</p>
<p>Description:
Defines nucleus reference frequency by assigning value to synthesizer offset frequency. The nucleus reference frequency
modified is that associated with the processing buffer synthesizer.</p>
<h3 id="offa">OFFA</h3>
<p>Set offset from reference frequency</p>
<p>Category: Frequency Control</p>
<p>Format: <code>OFFA</code> syn off</p>
<p>Defaults: current current</p>
<p>Description:
Defines nucleus reference frequency by assigning value to synthesizer offset frequency. The nucleus reference frequency
modified is that associated with the acquisition buffer synthesizer.</p>
<h3 id="onerr">ONERR</h3>
<p>Set macro error handler</p>
<p>Category: Control Flow</p>
<p>Format: <code>ONERR</code> label</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>ONERR</code> specifies a statement label to jump to in the event of an error condition or control-z. If no label is provided
RNMR will not prompt for it and any previous error label set using <code>ONERR</code> will be unset.</p>
<h3 id="opnarv">OPNARV</h3>
<p>Open archive</p>
<p>Category: Data Storage</p>
<p>Format: <code>OPNARV</code> arv name</p>
<p>Qualifiers: /RD /WRT /FORCE</p>
<p>Qualifier Defaults: /WRT for arv 1; /RD for others</p>
<p>Defaults: 1 TEMP</p>
<p>Description:
<code>OPNARV</code> opens an archive for access by RNMR. If no <a href="../syntax/#archives">archive number</a> is specified RNMR will prompt
for it with a default of 1. The parameter name specifies the name of the archive file that is to be opened. If no name
is specified RNMR will prompt for it with a default of temp. The /RD and /WRT qualifiers alter the
<a href="../syntax/#archive_access">access</a> to the archive. /RD will cause the archive to be opened with read access. /WRT will
cause the archive to be opened with read and write access. If neither /RD or /WRT is specified then <code>OPNARV</code> will use
/WRT for archive 1 and /RD for all other archive numbers.</p>
<p>/FORCE will allow RNMR to open an archive with write access even if there is already a lock file present for it. These
lock files are intended to prevent multiple instances of RNMR from trying to write to the same archive simultaneously.
Use of /FORCE might be necessary if RNMR crashed and was unable to delete the lock file. This option should be used
carefully as opening an archive with write access in multiple instances of RNMR at the same time can lead to corruption
of data.</p>
<h3 id="opnexp">OPNEXP</h3>
<p>Open export file</p>
<p>Category: Foreign</p>
<p>Format: <code>OPNEXP</code> format fspec</p>
<p>Defaults: ascii temp.<format></p>
<p>Description:
<code>OPNEXP</code> opens a file for data export. All export commands (<code>EXP</code>, <code>EXP1D</code>, etc.) between <code>OPNEXP</code> and <code>CLSEXP</code> will
export to this file. If no format is specified RNMR will prompt for it with a default of ASCII. The foreign formats
currently supported by <code>OPNEXP</code> are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>PIPE</li>
<li>SIFT</li>
</ul>
<p>All export commands using this file must use the same format as specified in <code>OPNEXP</code>. If no fspec is provided RNMR will
prompt for a file name with temp.<format> as the default. The file extension of this default is determined by the
format.</p>
<h3 id="opnimp">OPNIMP</h3>
<p>Open import file</p>
<p>Category: Foreign</p>
<p>Format: <code>OPNIMP</code> format fspec</p>
<p>Defaults: ascii temp.<format></p>
<p>Description:
<code>OPNIMP</code> opens a file for data import. All import commands (<code>IMP</code>, <code>IMP1D</code>, etc.) between <code>OPNIMP</code> and <code>CLSIMP</code> will
import from this file. If no format is specified RNMR will prompt for it with a default of ASCII. The foreign formats
currently supported by <code>OPNIMP</code> are:</p>
<ul>
<li>ASCII</li>
<li>BINARY</li>
<li>BRUKER</li>
<li>SIFT</li>
</ul>
<p>All import commands using this file must use the same format as specified in <code>OPNIMP</code>. If no fspec is provided RNMR will
prompt for a file name with temp.<format> as the default. The file extension of this default is determined by the
format.</p>
<h3 id="opnplt">OPNPLT</h3>
<p>Open plot stream    </p>
<p>Category: Plotting</p>
<p>Format: <code>OPNPLT</code></p>
<p>Description:
<code>OPNPLT</code> opens a plot stream. All plots between <code>OPNPLT</code> and <code>CLSPLT</code> will appear on one sheet of paper.</p>
<h3 id="opnrd">OPNRD</h3>
<p>Open file for reading</p>
<p>Category: File IO</p>
<p>Format: <code>OPNRD</code> filename</p>
<p>Default: temp.wrt</p>
<p>Description:
<code>OPNRD</code> opens an ASCII file for read-only access by the command <code>RDWRT</code>. If no file is specified RNMR will prompt for it
with a default of temp.wrt.</p>
<h3 id="opnwrt">OPNWRT</h3>
<p>Open file stream for writing</p>
<p>Category: File IO</p>
<p>Format: <code>OPNWRT</code> filename</p>
<p>Qualifiers: /APPEND</p>
<p>Qualifier Defaults: none</p>
<p>Defaults: temp.wrt</p>
<p>Description:
<code>OPNWRT</code> opens a an ASCII file with write access. All write commands between <code>OPNWRT</code> and <code>CLSWRT</code> will appear in one
file. By default the file will be overridden if it already exists, but the /APPEND qualifier can be used to make write
commands append to the file instead.</p>
<h2 id="p">P</h2>
<hr />
<h3 id="p_1">P</h3>
<p>Set pulse length</p>
<p>Category: Pulse Control</p>
<p>Format: <code>P</code> pls usec</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>P</code> is an old command for setting the length of pulses. It has been replaced with the <code>PLS</code> command and is currently
simply an alias to it. As such <code>PLS</code> should be used in place of <code>P</code>.</p>
<h3 id="parb">PARB</h3>
<p>Set blocked record parameters</p>
<p>Category: Blocked Records</p>
<p>Format: <code>PARB</code> rec dir dim dom syn first step</p>
<p>Defaults: wrec 1 current current current current current</p>
<p>Description:
<code>PARB</code> sets parameters for interpreting a <a href="../syntax/#blocked_records">blocked record</a>. This command works essentially
the same as <code>SET REC</code> but sets many parameters for a specified direction at once. If no
<a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current write record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no direction is specified RNMR will prompt for it with 1 as a default. If
any other argument is omitted RNMR will prompt for it with the current value as a default.</p>
<h3 id="pc">PC</h3>
<p>Incremental phase correction</p>
<p>Category: Phasing</p>
<p>Format: <code>PC</code> dphi0 dphi1</p>
<p>Defaults: 0 0</p>
<p>Description:
<code>PC</code> performs an incremental phase correction using the provided zero order (dphi0) and first order (dphi1) phase
factors. The correction is incremental in the sense that it alters the current phase parameters by these values. RNMR
will not prompt for either of the arguments and will use 0 if they are omitted.</p>
<h3 id="pen">PEN</h3>
<p>Select plot pen</p>
<p>Category: Plotting</p>
<p>Format: <code>PEN</code> pen</p>
<p>Defaults: current</p>
<p>Qualifiers: /DATA /LABEL</p>
<p>Qualifier Defaults: /DATA</p>
<p>Description:
<code>PEN</code> selects a pen for plotting. For laser plotters, pen#=1 selects a thin line and pen#=2 selects a thick line. /DATA
and /LABEL can be used to separately set the pen for the data and the labels in a plot. If no pen parameter is provided
RNMR will prompt for it with the current value as a default.</p>
<h3 id="pgsize">PGSIZE</h3>
<p>Set page size for plot</p>
<p>Category: Plotting</p>
<p>Format: <code>PGSIZE</code> xsiz ysiz</p>
<p>Defaults: current current</p>
<p>Description:
<code>PGSIZE</code> sets the size of a plot page in inches. If either xsiz or ysiz are not provided RNMR will prompt for them with
the current value as a default.</p>
<h3 id="ph">PH</h3>
<p>Interactive phase correction</p>
<p>Category: Phasing</p>
<p>Format: <code>PH</code></p>
<p>Description:
<code>PH</code> performs interactive phase correction. While <code>PH</code> is active the following subcommands can be used to manipulate the
phase of the spectrum.</p>
<p>Subcommands:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enter</td>
<td>Terminate with current phase values</td>
</tr>
<tr>
<td>C</td>
<td>Select constant phase value for change</td>
</tr>
<tr>
<td>D</td>
<td>Select decrement direction</td>
</tr>
<tr>
<td>I</td>
<td>Select increment direction</td>
</tr>
<tr>
<td>L</td>
<td>Select linear phase value for change</td>
</tr>
<tr>
<td>P</td>
<td>Select current cursor position as pivot for linear value</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate with original phase values</td>
</tr>
<tr>
<td>V</td>
<td>Change phase value after prompt</td>
</tr>
<tr>
<td>Z</td>
<td>Call <code>ZO</code> to enable moving the cursor</td>
</tr>
<tr>
<td>0-2</td>
<td>Change current value by 10^N degrees</td>
</tr>
</tbody>
</table>
<p>Either the zero or first order phase parameter can be changed up or down in steps of 1, 10, or 100. To move the pivot
point, use Z to call <code>ZO</code>, then move the cursor and press enter to exit <code>ZO</code>. Finally press P to move the pivot to the
cursor.</p>
<h3 id="pidl">PIDL</h3>
<p>Set lock PID gain factors</p>
<p>Category: Lock</p>
<p>Format: <code>PIDL</code> fctrp fctri</p>
<p>Qualifiers: /P /I</p>
<p>Qualifier Defaults: /P /I</p>
<p>Defaults: current current</p>
<p>Prerequisites: RNMR lock control. RNMRA only.</p>
<p>Description:
<code>PIDL</code> sets the proportional and integral gain factors for the lock PID. /P and /I can be used to select which parameter
to update. If no qualifier is supplied RNMR will set both parameters. If a gain factor to be set is not provided RNMR
will prompt for it with the current value as a default.</p>
<h3 id="pldev">PLDEV</h3>
<p>Select plotting device</p>
<p>Category: Plotting</p>
<p>Format: <code>PLDEV</code> device</p>
<p>Defaults: current</p>
<p>Description:
<code>PLDEV</code> sets the device to use for plotting. The currently available plotting devices are:</p>
<ul>
<li>E460A</li>
<li>E460B</li>
<li>LJ2430</li>
<li>LJ2430B</li>
<li>LJ4050</li>
<li>LJ5</li>
</ul>
<p>If no device is specified RNMR will prompt for it with the current plotting device as a default. If the plotting device
is changed (device is not the current device) RNMR will set the plotter flag (as set and displayed by <code>SET PL</code>) on,
indicating that plots should be physically printed by the plotting device rather than saved to the plot file (as set and
displayed by <code>PLFIL</code>).</p>
<h3 id="plfil">PLFIL</h3>
<p>Set plot file</p>
<p>Category: Plotting</p>
<p>Format: <code>PLFIL</code> fspec</p>
<p>Defaults: current</p>
<p>Description:
<code>PLFIL</code> selects a file to use as the destination for plotting. Plotting commands can write plots to the file in a
postscript format instead of sending the plots to a printer. Subsequent plotting commands that are not between <code>OPNPLT</code>
and <code>CLSPLT</code> will overwrite the plot file. If no file is specified RNMR will prompt for it with the last plot file as a
default.</p>
<p>If the plot file is changed (fspec is not the current fspec) RNMR will set the plotter flag (as set and displayed by
<code>SET PL</code>) off, indicating that plots should be saved to the plot file rather than physically printed by the plotting
device (as set and displayed by <code>PLDEV</code>).</p>
<h3 id="plot">PLOT</h3>
<p>Plot current 1D display</p>
<p>Category: Plotting</p>
<p>Format: <code>PLOT</code></p>
<p>Description:
<code>PLOT</code> plots the current one dimensional display to either the plotting device specified by <code>PLDEV</code> or the file
specified by <code>PLFIL</code>.</p>
<h3 id="plotc">PLOTC</h3>
<p>Plot 2D contours</p>
<p>Category: Plotting</p>
<p>Format: <code>PLOTC</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>PLOTC</code> plots a contour plot of a two-dimensional slice of a blocked record to either the plotting device specified by
<code>PLDEV</code> or the file specified by <code>PLFIL</code>. The number of contours is set by <code>NCON</code>, the contour height limits by
<code>CONLIM</code>, the type of contours by <code>CONMD</code>, and the plot limits by <code>LIMB</code>.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will plot the first 2D slice of the record.</p>
<h3 id="pls">PLS</h3>
<p>Set pulse length</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PLS</code> name time</p>
<p>Qualifiers: /DLY /PLS</p>
<p>Qualifier Defaults: /PLS</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>PLS</code> sets the length of a pulse indicated by name. /DLY will interpret time in milliseconds while /PLS will interpret
time in microseconds. The length of a pulse can range from 0 to 1200 microseconds. A pulse program must be loaded using
<code>PPEX</code> in order for <code>PLS</code> to be used to set the length of any pulses.</p>
<h3 id="plsize">PLSIZE</h3>
<p>Set plot size</p>
<p>Category: Plotting</p>
<p>Format: <code>PLSIZE</code> xsiz ysiz</p>
<p>Defaults: current current</p>
<p>Description:
<code>PLSIZE</code> sets the size of a plot in inches. If either xsiz or ysiz are not provided RNMR will prompt for them with
the current value as a default.</p>
<h3 id="polar">POLAR</h3>
<p>Convert buffer to polar coordinates</p>
<p>Category: Data Transforms</p>
<p>Format: <code>POLAR</code></p>
<p>Description:
<code>POLAR</code> converts the data in the visible processing buffer into polar coordinates. The magnitude of the data is placed
in the real part of the buffer and the phase in the imaginary part of the buffer.</p>
<h3 id="poplst">POPLST</h3>
<p>Pop a value from a list</p>
<p>Category: Lists</p>
<p>Format: <code>POPLST</code> nam</p>
<p>Qualifiers: /HEAD /TAIL</p>
<p>Qualifier Defaults: /TAIL</p>
<p>Defaults: temp</p>
<p>Description:
<code>POPLST</code> pops a value from the end of a list specified by nam. If no list is specified RNMR will prompt for it with temp
as a default. /HEAD or /TAIL may be used to determine which end of the list to pop a value from. By default RNMR pops
from the tail of the list. The value is removed from the list and printed as an informational message.</p>
<h3 id="posl">POSL</h3>
<p>Set lock channel center position</p>
<p>Category: Lock</p>
<p>Format: <code>POSL</code> pos</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>POSL</code> sets the position of the center of the lock. The value must be between -50.0 and 50.0 inclusive. If no position
is specified RNMR will prompt for it with the current position as a default.</p>
<h3 id="pp">PP</h3>
<p>Interactive peak picking</p>
<p>Category: Data Analysis</p>
<p>Format: <code>PP</code></p>
<p>Description:
<code>PP</code> performs interactive peak picking. While <code>PP</code> is active the following subcommands can be used to manipulate the
spectrum.</p>
<p>Subcommands:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>L</td>
<td>Move left one peak</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>R</td>
<td>Move right one peak</td>
</tr>
<tr>
<td>T</td>
<td>Set peak picking threshold</td>
</tr>
<tr>
<td>Z</td>
<td>Call <code>ZO</code></td>
</tr>
</tbody>
</table>
<p>A point is considered a peak if its magnitude is greater than the peak picking threshold (as set and displayed by <code>TH</code>)
and it is either a local maximum or minimum if its intensity is greater or less than zero respectively.</p>
<h3 id="ppex">PPEX</h3>
<p>Load a pulse program experiment</p>
<p>Category: Experiment</p>
<p>Format: <code>PPEX</code> nam</p>
<p>Qualifiers: /INIT /NOINIT</p>
<p>Qualifier Defaults: /INIT</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>PPEX</code> loads a pulse program named nam into the pulse programmer. If nam is omitted, RNMR will prompt for it with the
currently loaded pulse program (if any) as the default. Once <code>PPEX</code> has read the pulse program header, the title of the
program (as specified in the PP source code using the <code>TITLE</code> statement) is displayed as an informational message. This
title is usually a brief description of the function of the pulse program.</p>
<p>The /INIT qualifier causes the pulse program to be initialized by loading default values into the pulse programmer and
is active by default.</p>
<h3 id="ppflg">PPFLG</h3>
<p>Set state of pulse program flag</p>
<p>Category: Experiment</p>
<p>Format: <code>PPFLG</code> ind val</p>
<p>Defaults: 1 current</p>
<p>Prerequisites: Pulse program loaded (LOAD); RNMRA only</p>
<p>Description:
<code>PPFLG</code> is an old command for setting the state of pulse program flags. It has been replaced with the <code>FLAG</code> command and
is currently simply an alias to it. As such <code>FLAG</code> should be used in place of <code>PPFLG</code>.</p>
<h3 id="ppmd">PPMD</h3>
<p>Set pulse program phase mode</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PPMD</code> nam spec1 spec2 ... spec8</p>
<p>Qualifiers: /ACQ /BLK /MOD=MODMD</p>
<p>Qualifier Defaults: /ACQ /MOD=4</p>
<p>Defaults: 1 none none ... none</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>PPMD</code> sets pulse program phase cycling. The parameter nam specifies which phase cycle to set. These phase cycles are
mapped to pulses in the pulse program. If no name is provided RNMR will prompt for it with 1 as a default. /MOD defines
the number of different phase values to be used. These phase values will be equally spaced so the default value of 4
yields 90° phase steps while for example 6 would yield 60° steps. Each element or mode of the <code>PPMD</code> sequence is a
number from 1 to the value specified by /MOD. With the default qualifier /ACQ these modes indicate a sequence of phase
shifts to apply on sequential shots.</p>
<p>The default value is /MOD=4, which yields phase values of (0°, 90°, 180°, 270°) corresponding to the numbers 1
through 4. The maximum number of acquisition modes in a sequence is 64. If the number of modes entered is less than 64,
the specified modes will be replicated to a 64 mode sequence. For example, if the user specifies:</p>
<pre><code>    PPMD 1111 3333
</code></pre>
<p>the eight modes specified are replicated by RNMR to give a full 64 step phase cycle:</p>
<pre><code> 11113333 11113333 11113333 11113333
 11113333 11113333 11113333 11113333
</code></pre>
<p>While all sequences are replicated to 64 modes internally, only a number of steps equal to the active phase cycle length
(set by <code>NAMD</code>) are actually used. The sequence of modes may be broken up across multiple command line arguments as
shown in the example above. This can help improve readability.</p>
<p>If <code>PPMD</code> is called with no modes specifiers RNMR will not prompt for modes. Instead it will print the current phase
cycle out to the active phase cycle length with 16 modes per line.</p>
<p>The /BLK qualifier is used to setup additional phase shifts for different blocks of acquisition. The number of blocks
can be set using <code>NAMD /BLK</code>. This capability is typically used to set up phase differences used for the different steps
in hypercomplex acquisition of multi-dimensional spectra.</p>
<h3 id="prglst">PRGLST</h3>
<p>Purge list</p>
<p>Category: Lists</p>
<p>Format: <code>PRGLST</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>PRGLST</code> removes all of the values from list nam. If nam is not specified RNMR will prompt for it with a default of
temp.</p>
<h3 id="prgtbl">PRGTBL</h3>
<p>Purge name table</p>
<p>Category: Tables</p>
<p>Format: <code>PRGTBL</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>PRGTBL</code> removes all of the entries from name table nam. If nam is not specified RNMR will prompt for it with a default
of temp.</p>
<h3 id="prof">PROF</h3>
<p>Calculate profile of 2D data</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>PROF</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>PROF</code> calculates a one dimensional profile of a two dimensional slice of a <a href="synatx#blocked_records">blocked record</a>.
Each point in the profile will be set to the maximum value at that point along direction 2.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will calculate the profile of the first 2D slice of the record.</p>
<h3 id="profb">PROFB</h3>
<p>Calculate profile of blocked record along a dimension</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>PROFB</code> src dst dim</p>
<p>Defaults: rrec iwrec last</p>
<p>Defaults:
<code>PROFB</code> calculates the profile of a <a href="sybtax#blocked_records">blocked record</a> src along dimension dim and stores the
result in blocked record dst. If no source <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with
the current read record pointer (as displayed and set by <code>PTRA</code>) as a default. If no destination
<a href="../syntax/#records">record number</a> is specified RNMR will not prompt for it and will use the current write record
pointer (as displayed and set by <code>PTRA</code>) as a default. The dimension to calculate the profile along is a dimension and
not a direction and is not affected by <code>DIRB</code>. The source record must be <a href="../syntax/#ndimx">accessible</a> along the
specified dimension. If no dimension is specified RNMR will prompt for it with the last accessible dimension of the
source record as a default.</p>
<p>If the specified destination record is not free the next available record will be used and the actual destination record
will be printed as an informational message. The destination record will have the same dimensionality and size as the
source record except that the profile dimension will have size 1. Each point in the destination record will be set to
the maximum value at that point across all of the blocks along the specified dimension in the source record.</p>
<h3 id="prog">PROG</h3>
<p>Identify program</p>
<p>Category: Misc.</p>
<p>Format: <code>PROG</code></p>
<p>Description:
<code>PROG</code> prints the identity of the program (RNMRA or RNMRP) and the modification time of the corresponding file to the
console.</p>
<h3 id="proj">PROJ</h3>
<p>Calculate projection of 2D data</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>PROJ</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>PROJ</code> calculates a one dimensional projection of a two dimensional slice of a <a href="synatx#blocked_records">blocked record</a>.
Each point in the projection will be set to the sum of the values at that point along direction 2.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will calculate the profile of the first 2D slice of the record.</p>
<h3 id="projb">PROJB</h3>
<p>Calculate projection of blocked record along a dimension</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>PROJB</code> src dst dim</p>
<p>Defaults: rrec wrec last</p>
<p>Defaults:
<code>PROJB</code> calculates the projection of a <a href="sybtax#blocked_records">blocked record</a> src along dimension dim and stores the
result in blocked record dst. If no source <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with
the current read record pointer (as displayed and set by <code>PTRA</code>) as a default. If no destination
<a href="../syntax/#records">record number</a> is specified RNMR will not prompt for it and will use the current write record
pointer (as displayed and set by <code>PTRA</code>) as a default. The dimension to calculate the projection along is a dimension
and not a direction and is not affected by <code>DIRB</code>. The source record must be <a href="../syntax/#ndimx">accessible</a> along the
specified dimension. If no dimension is specified RNMR will prompt for it with the last accessible dimension of the
source record as a default.</p>
<p>If the specified destination record is not free the next available record will be used and the actual destination record
will be printed as an informational message. The destination record will have the same dimensionality and size as the
source record except that the projection dimension will have size 1. Each point in the destination record will be set to
the sum of the values at that point across all of the blocks along the specified dimension in the source record.
of the blocks.</p>
<h3 id="prtarg">PRTARG</h3>
<p>Print arguments</p>
<p>Category: Misc.</p>
<p>Format: <code>PRTARG</code> arg1 arg2 ... arg10</p>
<p>Defaults: none none none</p>
<p>Description:
<code>PRTARG</code> prints its arguments to standard out.</p>
<h3 id="ps">PS</h3>
<p>Set phase</p>
<p>Category: Phasing</p>
<p>Format: <code>PS</code> phi0 phi1</p>
<p>Defaults: cur_gbl cur_gbl</p>
<p>Description:
<code>PS</code> phases the spectrum to the specified absolute phase values. If either phase parameter is omitted RNMR will not
prompt for them and will use the current global values. The global values are updated anytime a spectrum is phased. Thus
<code>PS</code> with no arguments can be used to phase a new data set after <code>FT</code> to the same phase values as the last thing that
was phased.</p>
<h3 id="pshlst">PSHLST</h3>
<p>Push a value to a list</p>
<p>Category: Lists</p>
<p>Format: <code>PSHLST</code> nam val</p>
<p>Qualifiers: /HEAD /TAIL</p>
<p>Qualifier Defaults: /TAIL</p>
<p>Defaults: temp none</p>
<p>Description:
<code>PSHLST</code> pushes a value to the end of a list specified by nam. If no list is specified RNMR will prompt for it with temp
as a default. If the value is omitted RNMR will prompt for it with no default. /HEAD or /TAIL may be used to determine
which end of the list to push a value to. By default RNMR pushes to the tail of the list.</p>
<h3 id="psubv">PSUBV</h3>
<p>Subtract polar buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>PSUBV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>PSUBV</code> subtracts a the polar contents of <a href="../syntax/#buffers">processing buffer</a> src from dst and stores the result in
dst.</p>
<pre><code>REAL(DST)=SQRT(REAL(DST) * REAL(SRC))
IMAG(DST)=IMAG(DST) - IMAG(SRC)
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="psx">PSX</h3>
<p>Set transmitter phase</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PSX</code> chan psx phase</p>
<p>Defaults: 1 1 current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>PSX</code> sets a transmitter phase. If chan or psx are omitted RNMR will prompt for them with a default of 1. If phase is
omitted RNMR will prompt for it with the current phase of that psx on that channel as a default.</p>
<h3 id="psxex">PSXEX</h3>
<p>Load transmitter phase program from PAM memory.</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PSXEX</code></p>
<p>Defaults:</p>
<h3 id="ptra">PTRA</h3>
<p>Set read and write archive pointers</p>
<p>Category: Data Storage</p>
<p>Format: <code>PTRA</code> rrec wrec</p>
<p>Defaults: current current</p>
<p>Description:
<code>PTRA</code> sets the read and write archive pointers. These pointers are <a href="../syntax/#records">record numbers</a> that provide the
default values for most commands involving records. If either pointer is omitted RNMR will prompt for it with the
current value as a default. The read and write archive pointers are also set by most commands that read from or write to
a record respectively.</p>
<h3 id="ptrb">PTRB</h3>
<p>Set read and write blocked record pointers</p>
<p>Category: Blocked Records</p>
<p>Format: <code>PTRB</code> rec rblk wblk</p>
<p>Defaults: rrec current current</p>
<p>Description:
<code>PTRB</code> sets the read and write pointers for a <a href="../syntax/#blocked_records">blocked record</a>. These pointers are used to
determine the default values for most commands involving loading from or saving to blocked records. If no
<a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. The record must be a blocked record. If either pointer is omitted RNMR will
prompt for it with the current value as a default. The read and write blocked record pointers are also set by most
commands that read from or write to the blocked record respectively. Most commands that rely on these pointers will
increment them before use, so entering 0 for either pointer indicates to start from the beginning of the blocked record.</p>
<h3 id="pwr">PWR</h3>
<p>Set transmitter coarse power level</p>
<p>Category: Experiment</p>
<p>Format: <code>PWR</code> chan index pwr</p>
<p>Defaults: 1 1 current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>PWR</code> sets a coarse power level for a transmitter. If no channel is specified RNMR will prompt for it with a default
value of 1. Each transmitter has two coarse power levels that can be used in a pulse sequence. An index of 1 corresponds
to pwrh and an index of 2 indicates pwrl. If no index is specified RNMR will prompt for it with a default of 1. The
power level must be between 0.0 and 100.0 inclusive. If no power level is provided RNMR will prompt for it with the
current value as a default.</p>
<h3 id="pwrl">PWRL</h3>
<p>Set lock channel power level</p>
<p>Category: Lock</p>
<p>Format: <code>PWRL</code> pwr</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>PWRL</code> sets the lock channel power level. The power level must be between 0.0 and 100.0 inclusive. If no power level is
provided RNMR will prompt for it with the current value as a default.</p>
<h3 id="pwx">PWX</h3>
<p>Set transmitter fine power level</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PWR</code> chan nam pwr</p>
<p>Defaults: 1 1 current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>PWX</code> sets the fine power level for a pulse on a given channel. If either the channel or the name of the power level to
set is omitted RNMR will prompt for them with a default of 1. The power level must be between 0.0 and 100.0 inclusive.
If no power level is provided RNMR will prompt for it with the current value as a default.</p>
<h3 id="pwxex">PWXEX</h3>
<p>Load power program</p>
<p>Category: Pulse Control</p>
<p>Format: <code>PWXEX</code></p>
<p>Defaults:</p>
<h2 id="q">Q</h2>
<hr />
<h3 id="qc">QC</h3>
<p>Perform software quadrature phase correction</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>QC</code></p>
<p>Prerequisites: Time domain only (TIME)</p>
<p>Description:
<code>QC</code> performs software quadrature phase correction on an FID in the visible processing buffer. The cross correlation
coefficient between the real and imaginary parts of the buffer is obtained and the appropriate fraction of the imaginary
part subtracted from the real part.</p>
<h3 id="quit">QUIT</h3>
<p>Quit acquisition</p>
<p>Category: Acquisition</p>
<p>Format: <code>QUIT</code></p>
<p>Description:
<code>QUIT</code> Halts acquisition after the next complete phase cycle. Pressing Q while <code>QUIT</code> is waiting to finish a phase cycle
causes RNMR to halt immediately after the next shot.</p>
<h2 id="r">R</h2>
<hr />
<h3 id="rcvmix">RCVMIX</h3>
<p>Set receiver quadrature mixing</p>
<p>Category: Experiment</p>
<p>Format: <code>RCVMIX</code> valr vali</p>
<p>Qualifiers: /REAL /IMAG</p>
<p>Qualifier Defaults: /REAL /IMAG</p>
<p>Defaults: current current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RCVMIX</code> sets the receiver mix correction values for the real and imaginary channels. This operation should generally
only be performed by the staff. /REAL and /IMAG determine whether to set the real or imaginary value. If no qualifier is
used both will be set.</p>
<h3 id="rcvoff">RCVOFF</h3>
<p>Set receiver offset</p>
<p>Category: Experiment</p>
<p>Format: <code>RCVOFF</code> valr vali</p>
<p>Qualifiers: /REAL /IMAG</p>
<p>Qualifier Defaults: /REAL /IMAG</p>
<p>Defaults: current current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RCVOFF</code> sets the receiver offset correction values for the real and imaginary channels. This operation should generally
only be performed by the staff. /REAL and /IMAG determine whether to set the real or imaginary value. If no qualifier is
used both will be set.</p>
<h3 id="rd">RD</h3>
<p>Set recycle delay</p>
<p>Category: Experiment</p>
<p>Format: <code>RD</code> time</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RD</code> sets the recycle delay in seconds. The recycle delay is precise to the nearest tenth of a second. If no value is
provided RNMR will prompt for it with the current recycle delay as a default.</p>
<h3 id="rdarv">RDARV</h3>
<p>Read archive name</p>
<p>Category: Data Storage</p>
<p>Format: <code>RDARV</code> arv argnam</p>
<p>Qualifiers: /LCL /GBL /ERR=<label></p>
<p>Qualifier Defaults: /LCL</p>
<p>Defaults: 1 none</p>
<p>Description:
<code>RDARV</code> reads the name of an open archive specified by arv. If arv is not specified RNMR will prompt for it with a
default of 1. The name can be saved in either a global or local argument (as selected by the /LCL or /GBL qualifiers)
named argnam. By default it will be saved to a local variable. If no argnam is provided RNMR will not prompt for it and
will print the archive name as an informational message instead of saving it to an argument. /ERR can be used to set a
label to jump to in the event that the archive name cannot be read.</p>
<h3 id="rdlst">RDLST</h3>
<p>Read list from file</p>
<p>Category: Lists</p>
<p>Format: <code>RDLST</code> nam fspec</p>
<p>Defaults: temp <nam></p>
<p>Description:
<code>RDLST</code> reads values into a list from a file. This can be used to reload values saved using <code>WRTLST</code>. The list must have
already been allocated using <code>CRTLST</code> prior to using <code>RDLST</code>. If no list name is specified RNMR will prompt for it with
default of temp. If no file is specified RNMR will prompt for it with the list name as a default. If the file name has
no extension RNMR will add .wrt to it.</p>
<h3 id="rdpps">RDPPS</h3>
<p>Read PP symbol</p>
<p>Category: Pulse Program Symbols</p>
<p>Format: <code>RDPPS</code> typ nam argnam</p>
<p>Qualifiers: /LCL /GBL /ERR=<label></p>
<p>Qualifier Defaults: /LCL</p>
<p>Defaults: none</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RDPPS</code> reads the value of a pulse program symbol. The type of the symbol is specified by typ and the name of the symbol
by nam. If either of these parameters is omitted RNMR will prompt for them with no default. The value can be saved in
either a global or local argument (as selected by the /LCL or /GBL qualifiers) named argnam. By default it will be saved
to a local variable. If no argnam is provided RNMR will not prompt for it and will print the value as an informational
message instead of saving it to an argument. /ERR can be used to set a label to jump to in the event that the pulse
program symbol value cannot be read.</p>
<h3 id="rdppsnam">RDPPSNAM</h3>
<p>Read PP symbol name</p>
<p>Category: Pulse Program Symbols</p>
<p>Format: <code>RDPPSNAM</code> typ ind argnam</p>
<p>Qualifiers: /LCL /GBL /ERR=<label></p>
<p>Qualifier Defaults: /LCL</p>
<p>Defaults: none 1 none</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RDPPSNAM</code> reads the name of a pulse program symbol specified by its index. The type of the symbol is specified by typ
and the index of the symbol by ind. If nam parameters is omitted RNMR will prompt for them with no default. If ind is
omitted RNMR will prompt for it with a default of 1. The name can be saved in either a global or local argument (as
selected by the /LCL or /GBL qualifiers) named argnam. By default it will be saved to a local variable. If no argnam is
provided RNMR will not prompt for it and will print the name as an informational message instead of saving it to an
argument. /ERR can be used to set a label to jump to in the event that the pulse program symbol name cannot be read.</p>
<h3 id="rdstr">RDSTR</h3>
<p>Read tokens from a string</p>
<p>Category: Misc.</p>
<p>Format: <code>RDSTR</code> str nam1 nam2...</p>
<p>Qualifiers: /LCL /GBL /FIRST=<ind></p>
<p>Qualifier Defaults: /LCL /FIRST=1</p>
<p>Defaults: none</p>
<p>Description:
<code>RDSTR</code> reads individual tokens from a string supplied by the str argument. The tokens are saved in either global or
local arguments (as selected by the /LCL or /GBL qualifiers) whose names are set by nam1, nam2, etc. /FIRST selects the
first token to save. By default this is set to 1 and the first token is saved to nam1 and the second to nam2 and so on.
It can be set to higher values so as to skip some number of tokens. RNMR will not prompt for any of the arguments to
<code>RDSTR</code>.</p>
<h3 id="rdtbl">RDTBL</h3>
<p>Read name table values from file</p>
<p>Category: Tables</p>
<p>Format: <code>RDTBL</code> nam fspec</p>
<p>Defaults: temp <nam></p>
<p>Description:
<code>RDTBL</code> reads values into a name table from a file. This can be used to reload values saved using <code>WRTTBL</code>. The table
must have already been allocated using <code>CRTTBL</code> prior to using <code>RDTBL</code>. If no table name is specified RNMR will prompt
for it with a default of temp. If no file is specified RNMR will prompt for it with the table name as a default. If the
file name has no extension RNMR will add .wrt to it.</p>
<h3 id="rdwrt">RDWRT</h3>
<p>Read line from file</p>
<p>Category: File IO</p>
<p>Format: <code>RDWRT</code> nam1 nam2...</p>
<p>Qualifiers: /EOF=<lab> /FIRST=<ind> /LINE=<nam> /GBL /LCL</p>
<p>Qualifier Defaults: /LCL /FIRST=1</p>
<p>Defaults: none</p>
<p>Prerequisites: File open via <code>OPNRD</code></p>
<p>Description:
<code>RDWRT</code> reads a line from a file that was opened with <code>OPNRD</code>. The line is split into tokens that are saved in either
global or local arguments (as selected by the /LCL or /GBL qualifiers) whose names are set by nam1, nam2, etc. /FIRST
selects the first token to save. By default this is set to 1 and the first token is saved to nam1 and the second to nam2
and so on. It can be set to higher values so as to skip some number of tokens. /LINE skips this tokenizing behavior and
saves the whole line as a global or local argument whose name is the nam specified via /LINE=<nam>.</p>
<p>/EOF can be used to set a label to jump to in the event end of file is encountered. If this qualifier is not used EOF
will instead cause an error.</p>
<p>After <code>RDWRT</code> has executed the file position will be have moved such that calling <code>RDWRT</code> will read the next line. To
return to the beginning of the file use <code>RWDRD</code>.</p>
<h3 id="remgbl">REMGBL</h3>
<p>Remove global arguments</p>
<p>Category: Arguments</p>
<p>Format : <code>REMGBL</code> first last</p>
<p>Defaults: temp <first></p>
<p>Description:
<code>REMGBL</code> removes all global variables that alphabetically fall between first and last inclusive. If first is not
specified RNMR will prompt for it with a default of temp. If last is not specified RNMR will not prompt for it and will
remove only an argument whose name exactly matches first.</p>
<h3 id="remlcl">REMLCL</h3>
<p>Remove local arguments</p>
<p>Category: Arguments</p>
<p>Format : <code>REMLCL</code> first last</p>
<p>Defaults: temp <first></p>
<p>Description:
<code>REMLCL</code> removes all local variables that alphabetically fall between first and last inclusive. If first is not
specified RNMR will prompt for it with a default of temp. If last is not specified RNMR will not prompt for it and will
remove only an argument whose name exactly matches first.</p>
<h3 id="remlst">REMLST</h3>
<p>Remove list value</p>
<p>Category: Lists</p>
<p>Format: <code>REMLST</code> nam ind</p>
<p>Defaults: temp 1</p>
<p>Description:
<code>REMLST</code> removes the value at position ind from list nam. If nam is not specified RNMR will prompt for it with a default
of temp. If ind is not specified RNMR will prompt for it with a default of 1. The specified ind should not exceed the
number of values in the list.</p>
<h3 id="remmac">REMMAC</h3>
<p>Remove macro table entry</p>
<p>Category: Macros</p>
<p>Format: <code>REMMAC</code> nam</p>
<p>Defaults: temp</p>
<p>Description:
<code>REMMAC</code> removes macro nam from the macro table. The macro will be removed from RNMR and cannot be used without being
reloaded, but unlike <code>DLTMAC</code> the macro file will not be deleted.</p>
<h3 id="rempps">REMPPS</h3>
<p>Remove pulse programmer symbols</p>
<p>Category: Pulse Program Symbols</p>
<p>Format : <code>REMPPS</code> typ first last</p>
<p>Defaults: temp temp <first></p>
<p>Description:
<code>REMPPS</code> removes all pulse programmer symbols of a specified type that alphabetically fall between first and last
inclusive. If typ or first is not specified RNMR will prompt for it with a default of temp. If last is not specified
RNMR will not prompt for it and will remove only a pulse programmer symbol whose name exactly matches first.</p>
<h3 id="remsym">REMSYM</h3>
<p>Remove symbols</p>
<p>Category: Arguments</p>
<p>Format : <code>REMSYM</code> first last</p>
<p>Defaults: temp <first></p>
<p>Description:
<code>REMSYM</code> removes all symbols that alphabetically fall between first and last inclusive. If first is not specified RNMR
will prompt for it with a default of temp. If last is not specified RNMR will not prompt for it and will remove only a
symbol whose name exactly matches first.</p>
<h3 id="remtbl">REMTBL</h3>
<p>Remove name table entries</p>
<p>Category: Tables</p>
<p>Format : <code>REMTBL</code> nam first last</p>
<p>Defaults: temp temp <first></p>
<p>Description:
<code>REMTBL</code> removes all entries in name table nam that alphabetically fall between first and last inclusive. If nam or
first are not specified RNMR will prompt for them with a default of temp. If last is not specified RNMR will not prompt
for it and will remove only an entry whose name exactly matches first.</p>
<h3 id="renmac">RENMAC</h3>
<p>Rename macro</p>
<p>Category: Macros</p>
<p>Format: <code>RENMAC</code> nam1 nam2</p>
<p>Defaults: temp temp</p>
<p>Description:
<code>REMMAC</code> renames macro nam1 to nam2. If either name is omitted RNMR will prompt for it with a default of temp.</p>
<h3 id="rgpib">RGPIB</h3>
<p>Read string from GPIB device</p>
<p>Category: Hardware</p>
<p>Format: <code>RGPIB</code> device</p>
<p>Defaults: none</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>RGPIB</code> reads a string from a GPIB device. If no device is specified RNMR will prompt for one with no default.</p>
<h3 id="rms">RMS</h3>
<p>Calculate root-mean-square value of data</p>
<p>Category: Data Analysis</p>
<p>Format: <code>RMS</code> llim rlim</p>
<p>Qualifiers: /REAL /IMAG /COMPLEX</p>
<p>Qualifier Defaults: current display</p>
<p>Defaults: current current</p>
<p>Description:
<code>RMS</code> computes the root mean square of the data in the visible processing buffer between llim and rlim. If either limit
is omitted RNMR will not prompt for it and will use the current left or right display limit. /REAL or /IMAG will compute
the rms of the real or imaginary part of the buffer respectively. /COMPLEX will compute the rms of the magnitude of the
buffer. The computed value will be printed as an informational message.</p>
<h3 id="rot">ROT</h3>
<p>Rotate spectrum</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>ROT</code> drot</p>
<p>Defaults: dstep</p>
<p>Description:
<code>ROT</code> rotates the visible processing buffer by an amount (drot) specified in the current units of that buffer. A portion
of the buffer drot wide is moved from the left edge of the buffer to the right edge of the buffer. If drot is not
specified RNMR will prompt for it with a default that is equal to a single point rotation.</p>
<h3 id="rotp">ROTP</h3>
<p>Rotate spectrum</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>ROTP</code> nrot</p>
<p>Defaults: 1</p>
<p>Description:
<code>ROTP</code> rotates the visible processing buffer by an amount (nrot) specified in points. A portion of the buffer nrot
points wide is moved from the left edge of the buffer to the right edge of the buffer. If nrot is not specified RNMR
will prompt for it with a default of 1.</p>
<h3 id="rppsb">RPPSB</h3>
<p>Read data byte from pulse programmer spectrometer bus</p>
<p>Category: Hardware</p>
<p>Format: <code>RPPSB</code> adr</p>
<p>Default: 0</p>
<p>Prerequisites: Pulse programmer spectrometer bus control implemented (CGFSB2); RNMRA only</p>
<p>Description:
<code>RPPSB</code> reads a data byte from the pulse programmer spectrometer bus. The adr parameter specifies the address to read
the byte from and may range of 0 to 255 inclusive. If adr is omitted RNMR will prompt for it with a default of 0.</p>
<h3 id="rptdo">RPTDO</h3>
<p>Repeat iteration of macro <code>DO</code> loop</p>
<p>Category: Control Flow</p>
<p>Format: <code>RPTDO</code></p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>RPTDO</code> repeats an iteration of a macro <code>DO</code> loop. It returns to the beginning of the loop without executing the rest of
the commands in the loop or incrementing the loop counter. Take care as this behavior can easily lead to an infinite
loop. <code>RPTDO</code> must fall between an instance of <code>DO</code> and its matching <code>ENDDO</code>.</p>
<h3 id="rrkc">RRKC</h3>
<p>Read data from an RKC device</p>
<p>Category: Hardware</p>
<p>Format: <code>RRKC</code> device</p>
<p>Defaults: none</p>
<p>Prerequisites: RKC device implemented; RNMRA only</p>
<p>Description:
<code>RRKC</code> reads data from a RKC device. If no device is specified RNMR will prompt for one with no default.</p>
<h3 id="rsb">RSB</h3>
<p>Read data byte from spectrometer bus</p>
<p>Category: Hardware</p>
<p>Format: <code>RSB</code> adr</p>
<p>Defaults: 0</p>
<p>Prerequisites: Spectrometer bus control implemented (CGFSB1); RNMRA only</p>
<p>Description:
<code>RSB</code> reads a data byte from the spectrometer bus. The adr parameter specifies the address to read the byte from and may
range of 0 to 255 inclusive. If adr is omitted RNMR will prompt for it with a default of 0.</p>
<h3 id="rstbuf">RSTBUF</h3>
<p>Restore buffer values from file</p>
<p>Category: Misc.</p>
<p>Format: <code>RSTBUF</code> fspec buf</p>
<p>Defaults: temp 1</p>
<p>Description:
<code>RSTBUF</code> restores buffer values from a file fspec written using <code>SAVBUF</code> and applies them to a
<a href="../syntax/#buffers">processing buffer</a>. If no fspec is provided RNMR will prompt for it with temp as a default. If no
buffer is specified RNMR will not prompt for it and will apply the loaded values to the visible processing buffer.</p>
<h3 id="rstgbl">RSTGBL</h3>
<p>Restore global arguments from file</p>
<p>Category: Arguments</p>
<p>Format: <code>RSTGBL</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>RSTGBL</code> restores global arguments from a file fspec written using <code>SAVGBL</code>. If no fspec is provided RNMR will prompt
for it with temp as a default. Note that global arguments from the file will overwrite existing arguments with the same
name.</p>
<h3 id="rsthtr">RSTHTR</h3>
<p>Restore heater values from file</p>
<p>Category: Heater</p>
<p>Format: <code>RSTHTR</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>RSTHTR</code> restores heater values from a file fspec written using <code>SAVHTR</code>. If no fspec is provided RNMR will prompt
for it with temp as a default.</p>
<h3 id="rstlck">RSTLCK</h3>
<p>Restore lock values from file</p>
<p>Category: Lock</p>
<p>Format: <code>RSTLCK</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>RSTLCK</code> restores lock values from a file fspec written using <code>SAVLCK</code>. If no fspec is provided RNMR will prompt
for it with temp as a default.</p>
<h3 id="rstlst">RSTLST</h3>
<p>Restore lists from file</p>
<p>Category: Lists</p>
<p>Format: <code>RSTLST</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>RSTLST</code> restores all lists from a file fspec written using <code>SAVLST</code>. If no fspec is provided RNMR will prompt for it
with temp as a default. <code>RSTLST</code> will replace the full set of lists and their values as viewed by <code>CATLST /VAL</code> with the
contents of fspec. Any lists that were already populated will be lost.</p>
<h3 id="rstshm">RSTSHM</h3>
<p>Restore shim values from file</p>
<p>Category: Shim</p>
<p>Format: <code>RSTSHM</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR shim control; RNMRA only</p>
<p>Description:
<code>RSTSHM</code> restores shim values from a file fspec written using <code>SAVSHM</code>. If no fspec is provided RNMR will prompt
for it with temp as a default.</p>
<h3 id="rsttbl">RSTTBL</h3>
<p>Restore name tables from file</p>
<p>Category: Tables</p>
<p>Format: <code>RSTTBL</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>RSTTBL</code> restores all name tables from a file fspec written using <code>SAVTBL</code>. If no fspec is provided RNMR will prompt for
it with temp as a default. <code>RSTTBL</code> will replace the full set of name tables and their values as viewed by <code>CATTBL /VAL</code>
with the contents of fspec. Any tables that were already populated will be lost.</p>
<h3 id="rtnarg">RTNARG</h3>
<p>Renames return arguments</p>
<p>Category: Arguments</p>
<p>Format: <code>RTNARG</code> nam1 nam2...</p>
<p>Defaults: none</p>
<p>Description:
<code>RTNARG</code> renames values that are returned from a macro via <code>MEXIT</code> arguments. These return arguments are initially
stored in local arguments RTN$1, RTN$2, RT$3 etc. <code>RTNARG</code> renames these arguments to nam1, nam2, nam3 etc. The number
of names need not match the number of returned arguments. Any names with no corresponding returned local will be
ignored.</p>
<h3 id="rwdrd">RWDRD</h3>
<p>Rewind file opened by <code>OPNRD</code></p>
<p>Category: File IO</p>
<p>Format: <code>RWDRD</code></p>
<p>Description:
<code>RWDRD</code> rewinds a file that was opened by <code>OPNRD</code>. This returns to the beginning of the file such that the next call to
<code>RDWRT</code> will read the first line in the file.</p>
<h3 id="rwdwrt">RWDWRT</h3>
<p>Rewind file opened by <code>OPNWRT</code></p>
<p>Category: File IO</p>
<p>Format: <code>RWDWRT</code></p>
<p>Description:
<code>RWDWRT</code> rewinds a file that was opened by <code>OPNWRT</code>. This returns to the beginning of the file such that the next call
to <code>WRT</code> will write to the beginning of the file.</p>
<h2 id="s">S</h2>
<hr />
<h3 id="sa">SA</h3>
<p>Save data to archive record</p>
<p>Category: Data Storage</p>
<p>Format: <code>SA</code> rec buf</p>
<p>Defaults: wrec 1</p>
<p>Description:
<code>SA</code> saves the date in a <a href="../syntax/#buffers">processing buffer</a> to an <a href="../syntax/#record_type">archive record</a>. If no
<a href="../syntax/#records">record number</a> is provided RNMR will not prompt for it and will use the current write record pointer
(as displayed and set by <code>PTRA</code>). The record must be in an archive which RNMR has write access to. <code>SA</code> cannot write to
scratch records which must be written using <code>SS</code> or to blocked records which must be written using <code>SB</code>. If no buffer is
specified RNMR will not prompt for it and will save the data from the visible processing buffer.</p>
<h3 id="sav">SAV</h3>
<p>Save data and parameters to averager</p>
<p>Category: Acquisition</p>
<p>Format: <code>SAV</code> blk buf</p>
<p>Prerequisites: Acquisition stopped (HALT); Time domain only (TIME); RNMRA only</p>
<p>Description:
<code>SAV</code> transfers data and parameters from a <a href="../syntax/#buffers">processing buffer</a> to the averager for further averaging.
The averager memory may be logically partitioned into two or more blocks by <code>NABLK</code> so that multiple FID's with
different experimental parameters can be acquired at once, without the need to start and stop acquisition many times.
<code>SAV</code> transfers data from a processing buffer to one of these blocks. If no block is specified RNMR will not prompt for
it and will transfer to block 1. If no buffer is specified RNMR will not prompt for it and will transfer from the
visible processing buffer.</p>
<h3 id="savarv">SAVARV</h3>
<p>Save archive</p>
<p>Category: Data Storage</p>
<p>Format: <code>SAVARV</code> arv</p>
<p>Defaults: 1</p>
<p>Description:
<code>SAVARV</code> saves an archive to disk. If no <a href="../syntax/#archives">archive number</a> is specified RNMR will prompt for it with
a default of 1. Archives will be automatically saved in a number of situations, but it can be useful to manually save an
archive especially when opening an archive in read only mode in RNMRP while it is open with write access in RNMRA. Using
<code>SAVARV</code> in RNMRA and then <code>UPDARV</code> in RNMRP ensures that all changes made from RNMRA are visible in RNMRP.</p>
<h3 id="savbuf">SAVBUF</h3>
<p>Save buffer value to file</p>
<p>Category: Misc.</p>
<p>Format: <code>SAVBUF</code> fspec buf</p>
<p>Defaults: temp 1</p>
<p>Description:
<code>SAVBUF</code> saves values from a specified <a href="../syntax/#buffers">processing buffer</a> to a file on disk fspec which can be
later be loaded using <code>RSTBUF</code>. If no file is specified RNMR will prompt for it with temp as a default. If no buffer is
specified RNMR will not prompt for it and will save values from the visible processing buffer.</p>
<h3 id="savgbl">SAVGBL</h3>
<p>Save global arguments to file</p>
<p>Category: Arguments</p>
<p>Format: <code>SAVGBL</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>SAVGBL</code> saves the value of all current global arguments to a file on disk fspec which can be later be loaded using
<code>RSTGBL</code>. If no file is specified RNMR will prompt for it with temp as a default.</p>
<h3 id="savhtr">SAVHTR</h3>
<p>Save heater values to file</p>
<p>Category: Heater</p>
<p>Format: <code>SAVHTR</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>SAVHTR</code> saves heater values to a file on disk fspec which can be later be loaded using <code>RSTHTR</code>. If no file is
specified RNMR will prompt for it with temp as a default.</p>
<h3 id="savlck">SAVLCK</h3>
<p>Save lock values to file</p>
<p>Category: Lock</p>
<p>Format: <code>SAVLCK</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>SAVLCK</code> saves lock values to a file on disk fspec which can be later be loaded using <code>RSTLCK</code>. If no file is
specified RNMR will prompt for it with temp as a default.</p>
<h3 id="savlog">SAVLOG</h3>
<p>Save logging to file</p>
<p>Category: Misc.</p>
<p>Format: <code>SAVLOG</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: Logging enabled</p>
<p>Description:
<code>SAVLOG</code> saves the contents of the logging window to a file on disk fspec. If no file is specified RNMR will prompt for
it with temp as a default. <code>SAVLOG</code> cannot be used unless logging is enabled (<code>SET LOG ON</code>).</p>
<h3 id="savlst">SAVLST</h3>
<p>Save lists to file</p>
<p>Category: Lists</p>
<p>Format: <code>SAVLST</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>SAVLST</code> saves all current lists to a file on disk fspec which can be later be loaded using <code>RSTLST</code>. If no file is
specified RNMR will prompt for it with temp as a default.</p>
<h3 id="savshm">SAVSHM</h3>
<p>Save shim values to file</p>
<p>Category: Shim</p>
<p>Format: <code>SAVSHM</code> fspec</p>
<p>Defaults: temp</p>
<p>Prerequisites: RNMR shim control; RNMRA only</p>
<p>Description:
<code>SAVSHM</code> saves shim values to a file on disk fspec which can be later be loaded using <code>RSTSHM</code>. If no file is
specified RNMR will prompt for it with temp as a default.</p>
<h3 id="savtbl">SAVTBL</h3>
<p>Save name tables to file</p>
<p>Category: Tables</p>
<p>Format: <code>SAVTBL</code> fspec</p>
<p>Defaults: temp</p>
<p>Description:
<code>SAVTBL</code> saves all current name tables to a file on disk fspec which can be later be loaded using <code>RSTTBL</code>. If no file
is specified RNMR will prompt for it with temp as a default.</p>
<h3 id="sb">SB</h3>
<p>Save data to blocked record</p>
<p>Category: Data Storage</p>
<p>Format: <code>SB</code> rec slice buf nblk</p>
<p>Defaults: wrec next 1 1</p>
<p>Description:
<code>SB</code> saves the data in a <a href="../syntax/#buffers">processing buffer</a> to 1D slices if a
<a href="../syntax/#blocked_records">blocked record</a>. If no <a href="../syntax/#records">record number</a> is provided RNMR will not prompt
for it and will use the current write record pointer (as displayed and set by <code>PTRA</code>). The record must be in an archive
which RNMR has write access to. <code>SB</code> cannot write to <a href="../syntax/#record_types">scratch records</a> which must be written
using <code>SS</code> or to archive records which must be written using <code>SA</code>.</p>
<p>Since processing buffers are one-dimensional, the user must specify which one-dimensional <a href="../syntax/#slice">slice(s)</a> of
the blocked record to save the data from the buffer to. If no slice is specified RNMR will not prompt for it and will
write to the slice after the current write blocked record pointer (as displayed and set by <code>PTRB</code>).</p>
<p>If no buffer is specified RNMR will not prompt for it and will save the data in the visible processing buffer.
Multiple blocks of the buffer may be saved to multiples slices of the blocked record. The final parameter, nslice,
specifies how many slices to save starting from the specified slice. If nslice is omitted RNMR will not prompt for it
and will save only a single slice. The value of nslice may not exceed the number of blocks the processing buffer is
partitioned into (as displayed and set by <code>DBSZ</code>). The active size of each block of the processing buffer must match the
size of the blocked record along direction 1. In order for a slice to be read it must not exceed the size of the blocked
record. If a requested slice cannot be written for the above reasons all of the requested slices that come before it
will still be successfully saved. The write blocked record pointer (as displayed and set by <code>PTRB</code>) will be updated to
point to the last slice written.</p>
<h3 id="sc">SC</h3>
<p>Scale data</p>
<p>Category: Display Control</p>
<p>Format: <code>SC</code> sf</p>
<p>Qualifiers: /ABS /REL</p>
<p>Qualifier Defaults: /REL</p>
<p>Defaults: 1.0</p>
<p>Description:
<code>SC</code> vertically scales data in the visible processing buffer. By default <code>SC</code> uses the /REL option which multiplies the
data by the value of sf. /ABS sets the absolute scale factor of the data. After scaling RNMR will print the new absolute
scale factor as an informational message. If sf is omitted RNMR will not prompt for it and will use a scale factor of
1.0.</p>
<h3 id="sel">SEL</h3>
<p>Begin macro <code>SEL</code> block</p>
<p>Category: Control Flow</p>
<p>Format: <code>SEL</code> nam</p>
<p>Qualifiers: /LCL /GBL</p>
<p>Qualifier Defaults: /LCL</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only</p>
<p>Description:
<code>SEL</code> begins a macro <code>SEL</code> block which is ended by <code>ENDSEL</code>. The block uses a global or local argument (as selected by
the /LCL or /GBL qualifiers) named nam. By default a local argument is used. If no nam is provided RNMR will prompt for
it with no default. RNMR iterates sequentially through each instance of <code>CASE</code> between <code>SEL</code> and <code>ENDSEL</code>. For each
<code>CASE</code> the value of argument nam is compared to the value of the <code>CASE</code>. The first time a match is found all of the
commands are executed that fall between that <code>CASE</code> and either the next <code>CASE</code> or <code>ENDSEL</code> whichever comes first. Then
execution proceeds from the line after <code>ENDSEL</code></p>
<h3 id="set">SET</h3>
<p>Set system state</p>
<p>Category: Misc.</p>
<p>Format: <code>SET</code> nam ...</p>
<p>Defaults: none</p>
<p>Description:
<code>SET</code> sets the state of a variety of aspects RNMR. The parameter nam specifies what state to set. If nam is not
specified RNMR will prompt for it with no default. The majority of the options available for <code>SET</code> are flags which may
be set to either ON or OFF. If not specified RNMR will prompt for the state of the flag with the current value as a
default.</p>
<p>The following flags may be set only from RNMRA:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AUTOZ</td>
<td>Automatic Z shimming</td>
<td>Turns automatic Z shimming (controlled via <code>AUTOZ</code>) on and off</td>
</tr>
<tr>
<td>HTR</td>
<td>Heater computer control</td>
<td>Turns remote heater control on and off</td>
</tr>
<tr>
<td>MAS</td>
<td>MAS controller computer control</td>
<td>Turns remot spinning control on and off</td>
</tr>
<tr>
<td>RKC</td>
<td>RKC computer control</td>
<td>Turns remote RKC control on and off</td>
</tr>
<tr>
<td>RRI</td>
<td>RRI computer control</td>
<td>turns remote RRI control on and off</td>
</tr>
<tr>
<td>SHM</td>
<td>Shim computer control</td>
<td>Turns remote shim control on and off</td>
</tr>
<tr>
<td>TRM</td>
<td>Terminal communication</td>
<td>Turns terminal communication on and off</td>
</tr>
<tr>
<td>WRFBUF</td>
<td>WRF buffer</td>
<td></td>
</tr>
<tr>
<td>WWF</td>
<td>WWF buffer</td>
<td></td>
</tr>
</tbody>
</table>
<p>RNMRA also has flags which are set on a per channel basis. When setting these flags RNMR will prompt for a channel with
1 as a default if no channel is specified. Then RNMR will prompt for a flag state with the current state as a default.
The following flags may be set in this fashion from RNMRA:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FMXBUF</td>
<td>FMX buffer</td>
<td></td>
</tr>
<tr>
<td>PSXBUF</td>
<td>PSX buffer</td>
<td></td>
</tr>
<tr>
<td>PWXBUF</td>
<td>PWX buffer</td>
<td></td>
</tr>
</tbody>
</table>
<p>The following flags may be set from both RNMRA and RNMRP:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOG</td>
<td>Logging window</td>
<td>When set on a window opens and <code>LOG</code> can be used to write logging lines to it that can be saved via <code>SAVLOG</code>. Closing the logging window will set the flag off.</td>
</tr>
<tr>
<td>LP</td>
<td>Text printer</td>
<td>When the text printer flag is on text is printed to the printer device as set and displayed by <code>LPDEV</code>. When the flag is off text printed by commands is saved to the text printer file as set and displayed by <code>LPFIL</code>. Changing <code>LPDEV</code> or <code>LPFIL</code> sets the flag to on or off respectively.</td>
</tr>
<tr>
<td>MSG</td>
<td>Message window</td>
<td>When set on a windows opens and all informational messages and messages written using <code>MSG</code> will appear in the window rather that being written to the console. Closing the message window will set the flag off.</td>
</tr>
<tr>
<td>PL</td>
<td>Plotter</td>
<td>When the plotter flag is on plots are printed to the plotting device as set and displayed by <code>PLDEV</code>. When the flag is off plots are saved to the plot file as set and displayed by <code>PLFIL</code>. Changing <code>PLDEV</code> or <code>PLFIL</code> sets the flag to on or off respectively.</td>
</tr>
<tr>
<td>REF</td>
<td>Display reference</td>
<td>When set on the current contents of the visible processing buffer are set to be the display reference. Whenever any dataset in the same domain (time or frequency) as the reference is displayed the reference data will also be shown. This reference data stays set until a different display reference is set or the flag is set off.</td>
</tr>
<tr>
<td>TIMER</td>
<td>Timer</td>
<td>When set off the amount of time since it was last set on in seconds is printed as an informational message.</td>
</tr>
<tr>
<td>TRACE</td>
<td>Trace</td>
<td>When enabled all commands that are executed as well as the command level they are executed from are printed as informational messages. This is very useful for tracing the execution of macros for debugging purposes.</td>
</tr>
</tbody>
</table>
<p>There are also several other options that are not simply flags that can be turned on/off. The following options are
available in both RNMRA and RNMRP:</p>
<p>BUF item val</p>
<p><code>SET BUF</code> sets various parameters of the visible processing buffer. If no item is specified RNMR will not prompt for it
and will do nothing. If an item is selected but no value is specified RNMR will prompt for it with the current value.
The following items may be set with <code>SET BUF</code>:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIM</td>
<td>Buffer dimension</td>
</tr>
<tr>
<td>DOM</td>
<td>Buffer domain (TIME, FREQ, UNKN)</td>
</tr>
<tr>
<td>FIRST</td>
<td>Position of first point</td>
</tr>
<tr>
<td>NACQ</td>
<td>Number of acquisitions</td>
</tr>
<tr>
<td>SF</td>
<td>Scale factor</td>
</tr>
<tr>
<td>SIZE</td>
<td>Size in points</td>
</tr>
<tr>
<td>STEP</td>
<td>Difference between position of sequential points</td>
</tr>
<tr>
<td>TITLE</td>
<td>Buffer title</td>
</tr>
</tbody>
</table>
<p>DSP state</p>
<p><code>SET DSP</code> allows for disabling display updates. This can be useful when a macro does many calculations which would
usually update the display. Instead of numerous different display states flickering across the screen the display can be
disabled and updated after all of the calculations are complete. This can also save computational time. <code>SET DSP</code>
appears to function like the flags listed above in that it takes a single argument that can be either on or off, but it
actually has a value which is incremented by <code>SET DSP ON</code> and decremented by <code>SET DSP OFF</code>. This value is initially 1.
When this value is greater than zero the display will update when commands that change the visible data are issued and
the default prompt if state is omitted will be on. Otherwise the display will not update with such commands and the
default prompt will be off. When <code>SET DSP ON</code> changes the value from 0 to 1 the display will be updated.</p>
<p>INFO typ [nam] nam1...</p>
<p><code>SET INFO</code> sets up handling of informational messages from the next command that is executed. The typ parameter
determines what type of location to send the message. The LST and TBL options use a nam parameter which determines
which list or name table to send values to. There can be multiple parameters nam1, nam2, etc. to setup multiple
informational messages from the same command. The following typ parameters are supported:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GBL</td>
<td>Save to global variables named nam1, nam2, etc.</td>
</tr>
<tr>
<td>LCL</td>
<td>Save to local variables named nam1, nam2, etc.</td>
</tr>
<tr>
<td>LST</td>
<td>Save to position nam1, nam2, etc. in list nam</td>
</tr>
<tr>
<td>OFF</td>
<td>Do not print messages</td>
</tr>
<tr>
<td>ON</td>
<td>Print messages</td>
</tr>
<tr>
<td>SYM</td>
<td>Save to symbols named nam1, nam2, etc.</td>
</tr>
<tr>
<td>TBL</td>
<td>Save to entry nam1, nam2, etc. in name table nam</td>
</tr>
</tbody>
</table>
<p>REC rec dir item val</p>
<p><code>SET REC</code> sets the value of various parameters in the title information of a record. It takes several arguments. The
first is a record to set a parameter for. If no record number is specified RNMR will prompt for it with the current
write record pointer (as displayed and set by <code>PTRA</code>) as a default. The second parameter is a direction which may be an
integer from 1 and the number of dimensions the record has. If no direction is specified RNMR will prompt for it with 1
as a default. The third argument is which item to set the value of. If no item is specified RNMR will prompt for it with
no default. Some items have only a single value for the entire record which will be set regardless of which dimension is
specified. If no value is specified RNMR will prompt for it with the current value as a default. The following items may
be set with <code>SET REC</code>:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACQTYP</td>
<td>Acquisition type</td>
</tr>
<tr>
<td>DIM</td>
<td>Dimension corresponding to the direction</td>
</tr>
<tr>
<td>DOM</td>
<td>Domain of the direction (TIME, FREQ, UNKN)</td>
</tr>
<tr>
<td>FIRST</td>
<td>Position of first point</td>
</tr>
<tr>
<td>NACQ</td>
<td>Number of acquisitions (single parameter for all directions)</td>
</tr>
<tr>
<td>NSEG</td>
<td>Number of segments (single parameter for all directions)</td>
</tr>
<tr>
<td>SF</td>
<td>Scale factor to use when loading data (single parameter for all directions)</td>
</tr>
<tr>
<td>SIZE</td>
<td>Size in points</td>
</tr>
<tr>
<td>STEP</td>
<td>Difference between position of sequential points</td>
</tr>
<tr>
<td>SYN</td>
<td>Synthesizer associated with direction</td>
</tr>
<tr>
<td>TITLE</td>
<td>Title of record (single parameter for all directions)</td>
</tr>
</tbody>
</table>
<h3 id="setidn">SETIDN</h3>
<p>Set identification values</p>
<p>Category: Display Control</p>
<p>Format: <code>SETIDN</code> idn1 idn2</p>
<p>Defaults: none none</p>
<p>Prerequisites: Macro only</p>
<p>Description:
<code>SETIDN</code> sets the text in the identification fields in the top left of the RNMR display. <code>SETIDN</code> may only be called
from within a macro and the text set with it will be unset when the macro exits. The two arguments idn1 and idn2 are the
text for the two available identification fields. If these arguments are omitted RNMR will not prompt for them and will
not change the corresponding fields.</p>
<h3 id="setv">SETV</h3>
<p>Set data values between limits</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>SETV</code> val llim rlim</p>
<p>Qualifiers: /COMPLEX /IMAG /REAL</p>
<p>Qualifier Defaults: current_display</p>
<p>Defaults: 0.0 current_display_limits</p>
<p>Description:
<code>SETV</code> sets the data values for all points in a specified region (between llim and rlim) of the visible processing
buffer to a given value. If val is omitted RNMR will prompt for it with 0.0 as a default. If either limit is omitted
RNMR will not prompt for them and will use the current display limits. The limits are specified in the current units of
the visible processing buffer. The /REAL, /IMAG, and /COMPLEX qualifiers select whether to set the real part, imaginary
part, or both parts of the buffer to the specified value. The default behavior is to set the currently visible part of
buffer (as displayed and set by <code>BUF</code>).</p>
<h3 id="setvp">SETVP</h3>
<p>Set data values for specified points</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>SETVP</code> val llim npt</p>
<p>Qualifiers: /COMPLEX /IMAG /REAL</p>
<p>Qualifier Defaults: current_display</p>
<p>Defaults: 0.0 current_display_limit 1</p>
<p>Description:
<code>SETVP</code> sets the data values for all points in a specified region (npt points starting from llim) of the visible
processing buffer to a given value. If val is omitted RNMR will prompt for it with 0.0 as a default. If llim is omitted
RNMR will not prompt for it and will use the current left display limit. The limit is specified in the current units of
the visible processing buffer. If the number of points to set, npt, is omitted RNMR will not prompt for it and will set
a single point. The /REAL, /IMAG, and /COMPLEX qualifiers select whether to set the real part, imaginary part, or both
parts of the buffer to the specified value. The default behavior is to set the currently visible part of buffer (as
displayed and set by <code>BUF</code>).</p>
<h3 id="sg">SG</h3>
<p>Start acquisition without accumulation</p>
<p>Category: Acquisition</p>
<p>Format: <code>SG</code></p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>SG</code> starts acquisition but does not accumulate data from multiple shots. An indefinite number of scans will be
performed until acquisition is halted manually with <code>QUIT</code>.</p>
<h3 id="shell">SHELL</h3>
<p>Spawn shell</p>
<p>Category: Misc.</p>
<p>Format: <code>SHELL</code></p>
<p>Description:
<code>SHELL</code> spawns a new terminal from which shell commands can be executed.</p>
<h3 id="shft">SHFT</h3>
<p>Shift data</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>SHFT</code> shft</p>
<p>Defaults: step</p>
<p>Description:
<code>SHFT</code> shifts the data in the visible processing buffer by an amount shft specified in the current buffer units. If shft
is not specified RNMR will prompt for it with the current step, the value corresponding to a single point, as a default.
Shift values greater than zero will shift to the left while values less than zero will shift to the right. The portion
of the buffer left empty after the shift will be filled with zeros.</p>
<h3 id="shftp">SHFTP</h3>
<p>Shift data by points</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>SHFTP</code> shft</p>
<p>Defaults: 1</p>
<p>Description:
<code>SHFTP</code> shifts the data in the visible processing buffer by an amount shft specified in points. If shft is not specified
RNMR will prompt for it with 1 as a default. Shift values greater than zero will shift to the left while values less
than zero will shift to the right. The portion of the buffer left empty after the shift will be filled with zeros.</p>
<h3 id="shm">SHM</h3>
<p>Set shim value</p>
<p>Category: Shim</p>
<p>Format: <code>SHM</code> name value</p>
<p>Defaults: none current</p>
<p>Prerequisites: RNMR shim control; RNMRA only</p>
<p>Description:
<code>SHM</code> sets the value of a particular shim specified by name. If name is omitted RNMR will prompt for it with no default.
If value is omitted RNMR will prompt for it with the current value of the specified shim as a default. The shim value
may be between -100.0 and 100.0 inclusive.</p>
<h3 id="shmctl">SHMCTL</h3>
<p>Open interactive shim controls</p>
<p>Category: Shim</p>
<p>Format: <code>SHMCTL</code></p>
<p>Prerequisites: RNMR shim control; RNMRA only</p>
<p>Description:
<code>SHMCTL</code> opens a pop up window for viewing and adjusting shim values. The same window is available via the shim option
in the controls drop down menu.</p>
<h3 id="show">SHOW</h3>
<p>Show information</p>
<p>Category: Misc.</p>
<p>Format: <code>SHOW</code> option</p>
<p>Default: none</p>
<p>Description:
<code>SHOW</code> shows information on various RNMR entities. The following options are available in RNMRA and RNMRP:</p>
<p>BUF item</p>
<p><code>SHOW BUF</code> displays various attributes of the visible processing buffer. The following items may be displayed with
<code>SHOW BUF</code>:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIM</td>
<td>Buffer dimension</td>
</tr>
<tr>
<td>DOM</td>
<td>Buffer domain (TIME, FREQ, UNKN)</td>
</tr>
<tr>
<td>FIRST</td>
<td>Position of first point</td>
</tr>
<tr>
<td>LAST</td>
<td>Position of last point</td>
</tr>
<tr>
<td>NACQ</td>
<td>Number of acquisitions</td>
</tr>
<tr>
<td>SF</td>
<td>Scale factor</td>
</tr>
<tr>
<td>SIZE</td>
<td>Size in points</td>
</tr>
<tr>
<td>SIZEA</td>
<td>Allocated size in points</td>
</tr>
<tr>
<td>STEP</td>
<td>Difference between position of sequential points</td>
</tr>
</tbody>
</table>
<p>REC rec dir item</p>
<p><code>SHOW REC</code> displays the value of various parameters in the title information of a record. It takes several arguments.
The first is a record to show a parameter for. Records in archives other than 1 can be specified by either pre-pending
the archive number and a ":" or specifying numbers larger than 200. For example record ## in archive 2 can be specified
either as 2:## or by adding 200 to #. The second parameter is a direction which may be an integer from 1 and the number
of dimensions the record has. The third argument is which item to show the value of. Some items have only a single value
for the entire record which will be displayed regardless of which dimension is specified. The following items may be
displayed with <code>SHOW REC</code>:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACQTYP</td>
<td>Acquisition type</td>
</tr>
<tr>
<td>DIM</td>
<td>Dimension corresponding to the direction</td>
</tr>
<tr>
<td>DOM</td>
<td>Domain of the direction (TIME, FREQ, UNKN)</td>
</tr>
<tr>
<td>FIRST</td>
<td>Position of first point</td>
</tr>
<tr>
<td>NACQ</td>
<td>Number of acquisitions (single parameter for all directions)</td>
</tr>
<tr>
<td>NDIM</td>
<td>Number of dimensions (single parameter for all directions)</td>
</tr>
<tr>
<td>NDIMX</td>
<td>Number of simultaneously accessible dimensions (single parameter for all directions)</td>
</tr>
<tr>
<td>NSEG</td>
<td>Number of segments (single parameter for all directions)</td>
</tr>
<tr>
<td>NSEGA</td>
<td>Number of allocated segments (single parameter for all directions)</td>
</tr>
<tr>
<td>NUC</td>
<td>Nucleus</td>
</tr>
<tr>
<td>OFF</td>
<td>Offset frequency</td>
</tr>
<tr>
<td>PPM</td>
<td>PPM to Hz conversion factor</td>
</tr>
<tr>
<td>REF</td>
<td>Reference frequency</td>
</tr>
<tr>
<td>SF</td>
<td>Scale factor to use when loading data (single parameter for all directions)</td>
</tr>
<tr>
<td>SIZE</td>
<td>Size in points</td>
</tr>
<tr>
<td>SIZEA</td>
<td>Allocated size in points</td>
</tr>
<tr>
<td>SIZEB</td>
<td>Size in blocks</td>
</tr>
<tr>
<td>STEP</td>
<td>Difference between position of sequential points</td>
</tr>
<tr>
<td>SYN</td>
<td>Synthesizer associated with direction</td>
</tr>
<tr>
<td>TITLE</td>
<td>Title of record (single parameter for all directions)</td>
</tr>
</tbody>
</table>
<p>In RNMRA the BUFA option is also available. BUFA behaves exactly the same as BUF but displays information about the
acquisition buffer instead of the visible processing buffer.</p>
<h3 id="sineb">SINEB</h3>
<p>Perform Sine-bell apodization</p>
<p>Category: Apodization</p>
<p>Format: <code>SINEB</code> factor time</p>
<p>Defaults: 0.0 (size+1)*step</p>
<p>Prerequisites: Time domain data in processing buffer (TIME)</p>
<p>Description:
<code>SINEB</code> performs a sinebell apodization on an FID in the visible processing buffer. The first parameter, factor, must be
between 0.0 and 1.0 inclusive and determines the initial phase of the sinebell. The initial phase is the arcsine of the
factor. Thus a value of 0.0 indicates a sine function and a value of 1.0 indicates a cosine function. If factor is
omitted RNMR will prompt for it with 0.0 as a default. The second argument, time, indicates the time at which the
sinebell reaches 0 thereby stretching or squeezing the sinebell. All points from time on are set to 0. If time is
omitted RNMR will prompt for it with (size+1)*step as a default. This default will end the sinebell at the last data
point. RNMR multiplies the time domain data in the visible processing buffer by the specified sinebell.</p>
<h3 id="size">SIZE</h3>
<p>Set acquisition size</p>
<p>Category: Experiment</p>
<p>Format: <code>SIZE</code> size</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>SIZE</code> sets the number of point in a signal to be acquired. If size is omitted RNMR will prompt for it with the current
size as a default. The value of size must be between 1 and 32768 inclusive.</p>
<h3 id="sizeb">SIZEB</h3>
<p>Displays size of blocked record</p>
<p>Category: Blocked Records</p>
<p>Format: <code>SIZEB</code> rec dim</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>SIZEB</code> displays information about the size of a <a href="../syntax/#blocked_records">blocked record</a> along a particular
dimension. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record
pointer (as displayed and set by <code>PTRA</code>) as a default. If no dimension is specified RNMR will prompt for it with 1 as a
default. This parameter is a dimension not a direction and is unaffected by <code>DIRB</code>. If the dimension is between 1 and
the number of dimensions in the blocked record RNMR will print the size and allocated size of the blocked record in
that dimension as informational messages. If dir is 0 RNMR will print the number of segments in the record and the
number of allocated segments. If dir is * RNMR will print the total number of blocks and total number of allocated
blocks in the record. No other values of dim are permitted.</p>
<h3 id="sizlst">SIZLST</h3>
<p>Display size of list</p>
<p>Category: Lists</p>
<p>Format: <code>SIZLST</code> list</p>
<p>Defaults: temp</p>
<p>Description:
<code>SIZLST</code> prints the size of a list and its allocated size as informational messages. If no list is specified RNMR will
prompt for it with a default of temp.</p>
<h3 id="siztbl">SIZTBL</h3>
<p>Display size of name table</p>
<p>Category: Tables</p>
<p>Format: <code>SIZTBL</code> tbl</p>
<p>Defaults: temp</p>
<p>Description:
<code>SIZTBL</code> prints the size of a name table and its allocated size as informational messages. If no table is specified RNMR
will prompt for it with a default of temp.</p>
<h3 id="sp">SP</h3>
<p>Display archive space information</p>
<p>Category: Data Storage</p>
<p>Format: <code>SP</code> arv</p>
<p>Qualifiers: /DATA /FILE /FREE /MAX /TITLE /USED</p>
<p>Qualifier defaults: /DATA /USED</p>
<p>Defaults: 1</p>
<p>Description:
<code>SP</code> prints information about the space in an archive as informational messages. If no
<a href="../syntax/#archives">archive number</a> is specified RNMR will not prompt for it and will display information about
archive 1. The qualifiers are used to determine what information to display. /DATA and /TITLE select the type of
information to return. /DATA returns information about the size of various aspects of the archive in 512 byte blocks.
/TITLE returns information about the number of records in the archive.</p>
<p>The other qualifiers determine the quantity to print as follows:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>/DATA</th>
<th>/TITLE</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILE</td>
<td>Allocated size of file</td>
<td>Number of allocated records</td>
</tr>
<tr>
<td>FREE</td>
<td>Allowed usable space (MAX-USED)</td>
<td>Allowed usable records (MAX-USED)</td>
</tr>
<tr>
<td>MAX</td>
<td>Maximum allowable size</td>
<td>Maximum allowable number of records</td>
</tr>
<tr>
<td>USED</td>
<td>Size of filled space</td>
<td>Number of records in use</td>
</tr>
</tbody>
</table>
<p>By default <code>SP</code> uses /DATA /USED and prints the size of the filled space in blocks as an informational message.</p>
<h3 id="spln">SPLN</h3>
<p>Spline baseline fix spectrum</p>
<p>Category: Baseline</p>
<p>Format: <code>SPLN</code> list</p>
<p>Defaults: temp</p>
<p>Prerequisites: Frequency domain data in processing buffer (FREQ)</p>
<p>Description:
<code>SPLN</code> takes a list of points and subtracts a cubic spline fit to those points from the data in the visible processing
buffer. The list should contain numerical points from left to right specified in the current units of the buffer. If no
list is specified RNMR will prompt for it with temp as a default. <code>SPLN</code> can provide more accurate baseline subtraction
than <code>BF</code> if the baseline of a spectrum is not linear. The baseline subtraction will be affected by the selection of the
list of points used to fit the spline, so it is important to choose points that are not on peaks and cover all of the
features of the baseline.</p>
<h3 id="sqz">SQZ</h3>
<p>Squeeze archive (de-allocate unused space)</p>
<p>Category: Data Storage</p>
<p>Format: <code>SQZ</code> arv</p>
<p>Defaults 1</p>
<p>Description:
<code>SQZ</code> squeezes an archive to reduce the size of the file stored on disk. After <code>SQZ</code> the number of records and data
blocks allocated in the file will match the number of used records and data blocks (<code>SP /USED</code> will equal <code>SP /FILE</code>).
If no <a href="../syntax/#archives">archive number</a> is specified RNMR will prompt for it with 1 as a default.</p>
<h3 id="sref">SREF</h3>
<p>Save processing buffer reference to nucleus table</p>
<p>Category: Frequency Control</p>
<p>Format: <code>SREF</code> nuc</p>
<p>Defaults: *</p>
<p>Description:
<code>SREF</code> stores the reference frequency (or frequencies) in the visible processing buffer in the nucleus table. If nuc is
* <code>SREF</code> saves the frequency for every channel. Otherwise a valid nucleus must be passed. If nuc is omitted RNMR will
prompt for it with a default of *.</p>
<h3 id="srefa">SREFA</h3>
<p>Save acquisition buffer reference to nucleus table</p>
<p>Category: Frequency Control</p>
<p>Format: <code>SREFA</code> nuc</p>
<p>Defaults: *</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>SREFA</code> stores the reference frequency (or frequencies) in the acquisition buffer in the nucleus table. If nuc is *
<code>SREFA</code> saves the frequency for every channel. Otherwise a valid nucleus must be passed. If nuc is omitted RNMR will
prompt for it with a default of *.</p>
<h3 id="ss">SS</h3>
<p>Save data to scratch record</p>
<p>Category: Data Storage</p>
<p>Format: <code>SS</code> rec buf</p>
<p>Defaults: 1 1</p>
<p>Description:
<code>SS</code> saves the date in a <a href="../syntax/#buffers">processing buffer</a> to a <a href="../syntax/#record_type">scratch record</a> (records
1-4 in an archive). The record must be in an archive which RNMR has write access to. If no
<a href="../syntax/#records">record number</a> is specified RNMR will not prompt for it and will use record 1. The specified
scratch record does not need to be empty for <code>SS</code> to save data to it. <code>SS</code> cannot write to archive records which must
be written using <code>SA</code> or to blocked records which must be written using <code>SB</code>. If no buffer is specified RNMR will not
prompt for it and will save the data from the visible processing buffer.</p>
<h3 id="stk">STK</h3>
<p>Add to plot stream stack</p>
<p>Category: Plotting</p>
<p>Format: <code>STK</code></p>
<p>Prerequisites: Plot stream open</p>
<p>Description:
<code>STK</code> allows plotting multiple 1D spectra offset from one another on a single plot. <code>STK</code> must fall between <code>OPNPLT</code> and
<code>CLSPLOT</code>. Each invocation of <code>STK</code> plots the current contents of the visible processing buffer offset from the previous
plot in X and Y by the values set by <code>STKOFF</code>. There are limits to the area of a plot which <code>STK</code> cannot exceed. Reduce
the size of the plots using <code>PLSIZE</code> and offsets using <code>STKOFF</code> to ensure that all of the stack plots fit within a 9x6
area.</p>
<h3 id="stkoff">STKOFF</h3>
<p>Set stack plot offset</p>
<p>Category: Plotting</p>
<p>Format: <code>STKOFF</code> xoff yoff</p>
<p>Defaults: current current</p>
<p>Prerequisites: Plot stream closed</p>
<p>Description:
<code>STKOFF</code> sets the offset values in inches to be used when creating stack plots with <code>STK</code>. If either offset is omitted
RNMR will prompt for it with the current value as a default. <code>STK</code> cannot be used between <code>OPNPLT</code> and <code>CLSPLT</code>.</p>
<h3 id="str">STR</h3>
<p>Perform string operation</p>
<p>Category: Misc.</p>
<p>Format: <code>STR</code> string beg end</p>
<p>Qualifiers: /DLT /EXT /INSBEG=<str> /INSEND=<str> /LC /LEN /LOC=<str> /REPL=<str> /UC</p>
<p>Qualifier Defaults: /EXT</p>
<p>Defaults: none <beg> <end></p>
<p>Description:
<code>STR</code> performs a variety of operations on an input string and prints the result as an informational message. If any of
the arguments are omitted RNMR will not prompt for them. By default RNMR will use an empty string and the beginning and
ending of the string. The qualifiers control what operation is performed on the string as follows:</p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/DLT</td>
<td>Delete characters from beg to end</td>
</tr>
<tr>
<td>/EXT</td>
<td>Extract characters from beg to end</td>
</tr>
<tr>
<td>/INSBEG</td>
<td>Insert str before beg</td>
</tr>
<tr>
<td>/INSEND</td>
<td>Insert str after end</td>
</tr>
<tr>
<td>/LC</td>
<td>Convert characters from beg to end to lower case</td>
</tr>
<tr>
<td>/LEN</td>
<td>Print length of substring from beg to end</td>
</tr>
<tr>
<td>/LOC</td>
<td>Print index where str matches between beg and end (0 if no match)</td>
</tr>
<tr>
<td>/REPL</td>
<td>Replace region between beg and end with str</td>
</tr>
<tr>
<td>/UC</td>
<td>Convert characters from beg to end to upper case</td>
</tr>
</tbody>
</table>
<h3 id="subv">SUBV</h3>
<p>Subtract data buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>SUBV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>SUBV</code> subtracts the contents of <a href="../syntax/#buffers">processing buffers</a> dst from src and stores the result in dst.</p>
<pre><code>DST = SRC - DST
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="sw">SW</h3>
<p>Set sweep width</p>
<p>Category: Experiment</p>
<p>Format: <code>SW</code> freq</p>
<p>Defaults: current</p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>SW</code> sets the sweep width for acquisition to freq. This also changes the dwell time as set and displayed by <code>DW</code>. If
freq is omitted RNMR will prompt for it with the current sweep width as a default. The sweep width is in the current
frequency units. Due to limitations of the hardware RNMR may adjust the desired sweep width to the closest possible
sweep width. If such an adjustment occurs RNMR will print an informational message containing the adjusted sweep width.</p>
<h3 id="swapv">SWAPV</h3>
<p>Swap data buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>SUBV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>SWAPV</code> exchanges the contents of <a href="../syntax/#buffers">processing buffers</a> src and dst.</p>
<pre><code>SRC = DST
DST = SRC
</code></pre>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="swl">SWL</h3>
<p>Set lock channel sweep width</p>
<p>Category: Lock</p>
<p>Format: <code>SWL</code> width</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>SWL</code> sets lock sweep width. If width is omitted RNMR will prompt for it with the current value as a default. The sweep
width must be between 0.0 and 100.0 inclusive.</p>
<h3 id="swp">SWP</h3>
<p>Enable or disable lock sweep</p>
<p>Category: Lock</p>
<p>Format: <code>SWP</code> state</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>SWP</code> sets the state of the lock channel sweep. The state may be either ON or OFF. If no state is specified RNMR will
prompt for it with the current value as a default.</p>
<h2 id="t">T</h2>
<hr />
<h3 id="talarm">TALARM</h3>
<p>Set temperature for probe heater alarm</p>
<p>Category: Heater</p>
<p>Format: <code>TALARM</code> temp</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>TALARM</code> sets the temperature limit for the heater alarm. If no temperature is provided RNMR will prompt for it with the
current alarm temperature as a default. The temperature must be between -200 and 125.</p>
<h3 id="tcl">TCL</h3>
<p>Set lock channel time constant</p>
<p>Category: Lock</p>
<p>Format: <code>TCL</code> tc</p>
<p>Default: current</p>
<p>Prerequisites: RNMR lock control; RNMRA only</p>
<p>Description:
<code>TCL</code> sets the lock channel time constant. If the time constant is omitted RNMR will prompt for it with the current
value as a default. The time constant must be between 1.0 and 100.0.</p>
<h3 id="th">TH</h3>
<p>Set threshold for peak selection</p>
<p>Category: Data Analysis</p>
<p>Format: <code>TH</code> val</p>
<p>Defaults: current</p>
<p>Description:
<code>TH</code> sets the threshold value used for peak picking. If no value is specified RNMR will prompt for it with the current
value as a default. The threshold is used whenever RNMR identifies peaks (<code>LPK</code>, <code>LPK2D</code>, P subcommand of <code>ZO</code>, next
peak button in zoom window etc.). The magnitude of a point must be larger that the threshold in order to be considered a
peak. The threshold value must be between -1.0 and 1.0.</p>
<h3 id="tilt">TILT</h3>
<p>Tilt blocked record</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>TILT</code> rec slice tfctr</p>
<p>Defaults: wrec 1 1.0</p>
<p>Description:
<code>TILT</code> tilts a two-dimensional slice of a <a href="../syntax/#blocked_records">blocked record</a> by an angle between 0.0 and 45.0
degrees. If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current write record
pointer (as displayed and set by <code>PTRA</code>) as a default. The first two directions of the blocked record must be frequency
domain. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and will tilt the first 2D slice of the
record. The final parameter, tfctr, determines what angle to tilt the record by. The angle is tfctr times 45.0 degrees.
If tfctr is omitted RNMR will not prompt for it and will use a value of 1.0 (45 degree tilt). The value of tfctr may be
between 0.0 and 1.0 inclusive.</p>
<h3 id="title">TITLE</h3>
<p>Set processing buffer title</p>
<p>Category: Data Storage</p>
<p>Format: <code>TITLE</code> title</p>
<p>Defaults: current</p>
<p>Description:
<code>TITLE</code> sets the title of the visible processing buffer. If no title is provided RNMR will prompt for it with the
current processing buffer title as a default.</p>
<h3 id="titlea">TITLEA</h3>
<p>Set acquisition title</p>
<p>Category: Acquisition</p>
<p>Format: <code>TITLEA</code> title</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>TITLEA</code> sets the title of the acquisition buffer. If no title is provided RNMR will prompt for it with the current
acquisition buffer title as a default. This title is transferred to a processing buffer along with the data by <code>GAV</code>.</p>
<h3 id="tm">TM</h3>
<p>Perform trapezoidal multiplication apodization</p>
<p>Category: Apodization</p>
<p>Format: <code>TM</code> lfract rfract</p>
<p>Defaults: 0.0 0.0</p>
<p>Description:
<code>TM</code> performs a trapazoidal multiplication apodization on data in the visible processing buffer. A fraction of the data
on the left is multiplied by a linear function that increases from 0.0 to 1.0 and a fraction of the data on the right is
multiplied by a linear function that decreases from 1.0 to 0.0. The parameters lfract an rfract determine what fraction
of the data each linear function is applied to. If either of these arguments is omitted RNMR will prompt for it with 0.0
as a default. Both fractions must be between 0.0 and 1.0.</p>
<h3 id="tp">TP</h3>
<p>Show phase correction values</p>
<p>Category: Phasing</p>
<p>Format: <code>TP</code></p>
<p>Description:
<code>TP</code> prints the current zero order and first order phase correction values as informational messages.</p>
<h3 id="tppi">TPPI</h3>
<p>Convert TPPI-format FID to complex FID</p>
<p>Category: Foreign</p>
<p>Format: <code>TPPI</code></p>
<p>Prerequisites: Time domain data in visible processing buffer (TIME)</p>
<p>Description:
<code>TPPI</code> converts a TPPI-format FID to a complex FID. This process uses only the real data in the visible processing
buffer. It treats every other point starting with point 1 as the real data and every other point starting with point 2
as the imaginary data. As a result the size of the visible processing buffer will be reduced by a factor of two.
Additionally, after combining the data into complex numbers every other point starting with point 2 is negated.</p>
<h3 id="tset">TSET</h3>
<p>Set heater set-point temperature</p>
<p>Category: Heater</p>
<p>Format: <code>TSET</code> temp</p>
<p>Defaults: current</p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>TSET</code> sets the target temperature for the heater. If no temperature is specified RNMR will prompt for it with the
current target temperature as a default. The temperature must be between -200 and 125.</p>
<h3 id="tst">TST</h3>
<p>Conditionally execute a block of commands based on a test</p>
<p>Category: Control Flow</p>
<p>Format: <code>TST</code> test args...</p>
<p>Qualifiers: /TRUE /FALSE</p>
<p>Qualifier defaults: /TRUE</p>
<p>Defaults: none</p>
<p>Prerequisites: Macro only (MAC)</p>
<p>Description:
<code>TST</code> begins a <code>TST</code> block which is then ended by <code>ENDTST</code> and may optionally contain an <code>ELSTST</code> command. <code>TST</code> checks
a condition and then either runs the commands between <code>TST</code> and <code>ELSTST</code> or the commands between <code>ELSTST</code> and <code>ENDTST</code>.</p>
<p>For example, the following:</p>
<pre><code>tst lcl a
  msg "The value of a is &amp;a"
elstst
  msg "local argument a does not exist"
endtst
</code></pre>
<p>will test if local argument a exists and then either print its value or the fact that it does not exist.</p>
<p>/TRUE and /FALSE determine which block executed for which test result. With /TRUE <code>TST</code> will run the commands between
<code>TST</code> and <code>ELSTST</code> if the test returns true and the commands between <code>ELSTST</code> and <code>ENDTST</code> if it returns false. /FALSE
reverses this behavior. /FALSE is mostly useful when you only have one set of commands that you want to execute when the
test is false.</p>
<p>The argument test determines which type of test to perform. Depending on the test there are additional arguments and
additional qualifiers. The additional qualifiers should be passed after the test name but before the test arguments. If
no test name is specified RNMR will not prompt for it and will treat the test as having been true.</p>
<p>The following tests are available in both RNMRA and RNMRP:</p>
<table>
<thead>
<tr>
<th>Test Name</th>
<th>Description</th>
<th>Parameters</th>
<th>Default</th>
<th>Qualifiers</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARV</td>
<td>Checks archive</td>
<td>ARV</td>
<td>1</td>
<td>/VALID, /RD, /WRT, /CLS</td>
<td>/RD</td>
</tr>
<tr>
<td>CND</td>
<td>Checks condition flag</td>
<td>CND</td>
<td>1</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>REC</td>
<td>Checks record</td>
<td>REC</td>
<td>IRREC</td>
<td>/RD, /WRT, /SCR, /PERM, /VALID, /NOALLOC, /ALLOC, /ARC, /BLK</td>
<td>/RD, /ALLOC</td>
</tr>
<tr>
<td>FIL</td>
<td>Checks for existence of file</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>RD</td>
<td>Checks for file open for <code>RDWRT</code> command</td>
<td>None</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>WRT</td>
<td>Checks for file open for <code>WRT</code> command</td>
<td>None</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>ASKYN</td>
<td>Checks for yes/no response</td>
<td>PRMPT</td>
<td>'Enter response:'</td>
<td>/NO, /YES</td>
<td>/NO</td>
</tr>
<tr>
<td>DFLT</td>
<td>Tests arg for explicit default</td>
<td>ARG</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>EQ</td>
<td>Compares two args for equality</td>
<td>ARG1, ARG2</td>
<td>None, None</td>
<td>/FLT, /INT, /LOG, /NUM, /STR, /CASE, /NOCASE, /PAD, /NOPAD</td>
<td>/INT, /STR, /NOCASE, /PAD</td>
</tr>
<tr>
<td>FLG</td>
<td>Checks flag</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>GBL</td>
<td>Checks for existence of global argument</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>LAB</td>
<td>Checks for existence of label</td>
<td>LAB</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>LCL</td>
<td>Checks for existence of local ARGUMENT</td>
<td>NAM</td>
<td>None</td>
<td>/LEV=<ilev></td>
<td>/LEV=1</td>
</tr>
<tr>
<td>LIM</td>
<td>Checks numeric value is within limits</td>
<td>VAL,LIM1,LIM2</td>
<td>* , * , *</td>
<td>/FLT, /INT</td>
<td>/INT</td>
</tr>
<tr>
<td>LST</td>
<td>Checks for existence of list</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>MAC</td>
<td>Checks for existence of macro</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>SYM</td>
<td>Checks for existence of symbol</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>TBL</td>
<td>Checks for existence of name table</td>
<td>TBL</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>TBLARG</td>
<td>Checks for existence of name table argument</td>
<td>TBL, NAM</td>
<td>None, None</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>The following tests are available in RNMRA but not in RNMRP:</p>
<table>
<thead>
<tr>
<th>Test Name</th>
<th>Description</th>
<th>Parameters</th>
<th>Default</th>
<th>Qualifiers</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>CFG</td>
<td>Checks for existence of subsystem</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>PPS</td>
<td>Checks for existence of pp symbol</td>
<td>TYP, NAM</td>
<td>None, None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>SIG</td>
<td>Checks for signal</td>
<td>NAM</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST ARV</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/VALID</td>
<td>Check for validity of the archive number</td>
</tr>
<tr>
<td>/RD</td>
<td>Check for write access</td>
</tr>
<tr>
<td>/WRT</td>
<td>Check for read access</td>
</tr>
<tr>
<td>/CLS</td>
<td>Check if the archive is closed</td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST REC</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/RD</td>
<td>Check for write access</td>
</tr>
<tr>
<td>/WRT</td>
<td>Check for read access</td>
</tr>
<tr>
<td>/SCR</td>
<td>Check if it is a scratch record written using <code>SS</code></td>
</tr>
<tr>
<td>/PERM</td>
<td>Check if it is a permanent record</td>
</tr>
<tr>
<td>/VALID</td>
<td>Check for validity of the record number</td>
</tr>
<tr>
<td>/NOALLOC</td>
<td>Check if it has not been allocated</td>
</tr>
<tr>
<td>/ALLOC</td>
<td>Check if it has been allocated</td>
</tr>
<tr>
<td>/ARC</td>
<td>Check if it is a non-blocked record written with <code>SA</code></td>
</tr>
<tr>
<td>/BLK</td>
<td>Check if it is a blocked record written using <code>SB</code></td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST ASKYN</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/NO</td>
<td>Default value of the prompt is NO</td>
</tr>
<tr>
<td>/YES</td>
<td>Default value of the prompt is YES</td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST EQ</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Number mode uses floating point numbers (also sets /NUM)</td>
</tr>
<tr>
<td>/INT</td>
<td>Number mode uses integers (also sets /NUM)</td>
</tr>
<tr>
<td>/LOG</td>
<td>Use logical mode (args must be 1 or 0)</td>
</tr>
<tr>
<td>/NUM</td>
<td>Use number mode (args must be either integers or floats depending on /INT or /FLT)</td>
</tr>
<tr>
<td>/STR</td>
<td>Use string mode</td>
</tr>
<tr>
<td>/CASE</td>
<td>Use case sensitive string comparison</td>
</tr>
<tr>
<td>/NOCASE</td>
<td>Use non-case sensitive string comparison</td>
</tr>
<tr>
<td>/PAD</td>
<td>Pad strings with spaces before comparison</td>
</tr>
<tr>
<td>/NOPAD</td>
<td>Don't pad strings with spaces before comparison</td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST LCL</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/LEV</td>
<td>Select the command level to check for the local argument. 1 indicates the current macro, 2 the macro that called the current macro, 3 the macro that called that macro, etc. The value must be an integer ranging from 1 to the depth of the call stack.</td>
</tr>
</tbody>
</table>
<p>The qualifiers for <code>TST LIM</code> have the following meanings:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/FLT</td>
<td>Use floating point numbers</td>
</tr>
<tr>
<td>/INT</td>
<td>Use integers</td>
</tr>
</tbody>
</table>
<p><code>TST</code> is a replacement for the old if commands such as <code>IFEQ</code>. If you need the old behavior of jumping to labels instead
of executing code blocks use <code>GOTST</code>.</p>
<h3 id="tval">TVAL</h3>
<p>Show heater temperature</p>
<p>Category: Heater</p>
<p>Format: <code>TVAL</code></p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>TVAL</code> prints the current heater temperature as an informational message.</p>
<h3 id="twist">TWIST</h3>
<p>Twist blocked record</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>TWIST</code> rec slice tfctr</p>
<p>Defaults: wrec 1 1.0</p>
<p>Description:
<code>TWIST</code> twists a two-dimensional slice of a <a href="../syntax/#blocked_records">blocked record</a>. If no
<a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current write record pointer (as
displayed and set by <code>PTRA</code>) as a default. The first direction of the blocked record must be frequency domain and the
second direction must be time domain. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and will
twist the first 2D slice of the record. The final parameter, tfctr, determines how much to twist the record. If tfctr
is omitted RNMR will not prompt for it and will use a value of 1.0. The value of tfctr may be between 0.0 and 1.0
inclusive. </p>
<h2 id="u">U</h2>
<hr />
<h3 id="unecho">UNECHO</h3>
<p>Rearrange buffer to simulate FID from echo</p>
<p>Category: Signal Generation</p>
<p>Format <code>UNECHO</code> time</p>
<p>Defaults: center</p>
<p>Prerequisites: Time domain data in visible processing buffer (TIME)</p>
<p>Description:
<code>UNECHO</code> takes an echo signal in the visible processing buffer and simulates an FID from it. The parameter time should
be set to the middle of the echo. <code>UNECHO</code> will use a mixture of the data from the left and right halves of the echo to
generate the FID. The part of the buffer beyond the size of the larger half of the echo will be set to 0. If time is not
provided RNMR will prompt for it with a time value corresponding to the center of the buffer.</p>
<h3 id="unfold">UNFOLD</h3>
<p>Unfold data buffer</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>UNFOLD</code> nsect</p>
<p>Defaults: 1</p>
<p>Description:
<code>UNFOLD</code> grows the visible processing buffer to hold nsect sections each with the prior size of the buffer. The data in
the buffer is then copied into each section. If nsect is not specified RNMR will prompt for it with a default of 1. If
nsect is equal to 1 then <code>UNFOLD</code> has no effect.</p>
<h3 id="unit">UNIT</h3>
<p>Set units</p>
<p>Category: Display Control</p>
<p>Format: <code>UNIT</code> unit</p>
<p>Qualifiers: /DFLT /FREQ /TIME /UNKN</p>
<p>Qualifier defaults: /TIME</p>
<p>Defaults: current</p>
<p>Description:
<code>UNIT</code> sets the unit for a given domain. /FREQ, /TIME, and /UNKN select which domain to set the unit for. /DFLT is used
to set the default unit for the selected domain. If no unit is specified RNMR will prompt for it with the current unit.</p>
<p>Valid time domain units are USEC, MSEC, and SEC. Valid frequency domain units are HZ, kHz, MHz, and PPM. PPM cannot be
the default frequency unit.</p>
<h3 id="updarv">UPDARV</h3>
<p>Update archive</p>
<p>Category: Data Storage</p>
<p>Format: <code>UPDARV</code> archive</p>
<p>Defaults: 1</p>
<p>Description:
<code>UPDARV</code> updates an archive from its file on disk. This makes any changes that have been made to the file visible from
RNMR. If no <a href="../syntax/#archives">archive number</a> is specified RNMR will prompt for it with a default of 1. This can be
useful when using an archive in read only mode in RNMRP while it is open with write access in RNMRA. Using <code>SAVARV</code> in
RNMRA and then <code>UPDARV</code> in RNMRP ensures that all changes made from RNMRA are visible in RNMRP.</p>
<h3 id="user">USER</h3>
<p>Set user name</p>
<p>Category: Data Storage</p>
<p>Format: <code>USER</code> user</p>
<p>Defaults: current</p>
<p>Description:
<code>USER</code> sets the user name that is used for record protection. Usually this is set by the login macro on startup. If no
user is specified RNMR will prompt for it with the current user as a default. If there is no current user (as is the
case when first starting RNMR) the default will be *******. RNMR will continue to prompt until the user is not
********.</p>
<h2 id="v">V</h2>
<hr />
<h3 id="val">VAL</h3>
<p>Set data value</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>VAL</code> pos valr vali</p>
<p>Qualifiers: /REAL /IMAG</p>
<p>Qualifier Defaults: /REAL /IMAG</p>
<p>Defaults: current_cursor current current</p>
<p>Description:
<code>VAL</code> sets the data value of a specific point in the visible processing buffer to a specified complex number
(valr+i*vali). The point to be modified is selected by its position in the current buffer units. If no position is
specified RNMR will prompt for it with the current cursor position as a default. /REAL and /IMAG select whether to
set the value of the real or imaginary part of the data point respectively. If neither is set <code>VAL</code> will set both. If
a value to set is omitted RNMR will prompt for it with the current value as a default.</p>
<h3 id="view">VIEW</h3>
<p>Set display source</p>
<p>Category: Display Control</p>
<p>Format: <code>VIEW</code> view</p>
<p>Defaults: current</p>
<p>Description:
<code>VIEW</code> selects the buffer to view on the display. The valid options in RNMRA are pro or acq for the visible processing
buffer or acquisition buffer respectively. In RNMRP only pro is allowed. If no view is provided RNMR will prompt for it
with the current value.</p>
<h2 id="w">W</h2>
<hr />
<h3 id="wait">WAIT</h3>
<p>Wait during acquisition</p>
<p>Category: Acquisition</p>
<p>Format: <code>WAIT</code></p>
<p>Qualifiers: /ERR=<label></p>
<p>Qualifier Defaults: none</p>
<p>Prerequisites: Acquisition running; RNMRA only</p>
<p>Description:
<code>WAIT</code> waits during acquisition. While waiting commands cannot be entered at the console. <code>WAIT</code> will terminate if
<a href="../syntax/#acquisition">acquisition</a> finishes the specified number of scans (<code>NA</code> or <code>NWAIT</code>) or if a
<a href="../syntax/#signals">signal</a> is sent by the spectrometer. /ERR may be used to specify a label to jump to in the event of
an error during acquisition.</p>
<p>Pressing Q while <code>WAIT</code> is active calls <code>QUIT</code> to halt acquisition.</p>
<p>Pressing ^ while <code>WAIT</code> is active returns control to the user at the command line. Entering exit from this command line
resumes waiting. <code>WAIT</code> cannot terminate while in this state even if acquisition finishes or a signal is sent.
Multi-dimensional acquisition usually relies on <code>WAIT</code> terminating in response to signals so the signal can be properly
handled. As a result leaving the system at this console can effectively pause multi-dimensional acquisition.</p>
<h3 id="wavb">WAVB</h3>
<p>Perform weighted average of blocked record</p>
<p>Category: Data Manipulation</p>
<p>Format: rec first last</p>
<p>Defaults: rrec 1 last</p>
<p>Description:
<code>WAVB</code> performs a weighted average of one-dimensional <a href="../syntax/#slice">slices</a> from a <a href="blocked_records">blocked record</a>
and puts the result in the visible processing buffer. The average is weighted such that any slices with all zeros have a
weight of 0 and all other blocks have a weight of 1. If no <a href="../syntax/#records">record number</a> is specified RNMR will
prompt for it with the current read record pointer (as set and displayed by <code>PTRA</code>) as a default. <code>WAVB</code> performs the
average over slices first to last. If first is omitted RNMR will prompt for it with 1 as a default. If last is omitted
RNMR will prompt for it with the number of slices in the record as a default. Setting last to 0 indicates to use the
last slice in the record.</p>
<h3 id="wavv">WAVV</h3>
<p>Perform weighted addition of buffers</p>
<p>Category: Buffer Arithmetic</p>
<p>Format: <code>WAVV</code> src dst</p>
<p>Defaults: 2 1</p>
<p>Description:
<code>WAVV</code> calculates the weighted average of <a href="../syntax/#buffers">processing buffers</a> src and dst and stores the result in
dst. The buffers are weighted based upon the number of acquisitions in each buffer. The data from the src buffer is also
scaled to the scale factor of the dst buffer for averaging purposes.</p>
<pre><code>DST = DST*NA_DST/(NA_DST+NA_SRC) + SRC*NA_SRC/(NA_DST+NA_SRC) * (SF_DST/SF_SRC)
</code></pre>
<p>This permits the proper addition of two FID's or spectra with different scale factors and/or number of
acquisitions; each data set is weighted appropriately.</p>
<p>If either argument is omitted, RNMR will prompt for a buffer number. The default source is buffer 2 while the default
destination is buffer 1. The src and dst buffers must have the same domain and active size (though not necessarily the
same allocated size).</p>
<h3 id="wgpib">WGPIB</h3>
<p>Write line to GPIB device</p>
<p>Category: Hardware</p>
<p>Format: <code>WGPIB</code> dev cmd</p>
<p>Defaults: none</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>WGPIB</code> writes a command line to a GPIB device. If no device is specified RNMR will prompt for it with no default. If no
command line is provided RNMR will prompt for one with no default.</p>
<h3 id="wndlim">WNDLIM</h3>
<p>Set processing view vertical window limits</p>
<p>Category: Display Control</p>
<p>Format: <code>WNDLIM</code> min max</p>
<p>Qualifiers: /FREQ /TIME /UNKN</p>
<p>Qualifier Defaults: /TIME</p>
<p>Defaults: current current</p>
<p>Description:
<code>WNDLIM</code> sets the vertical window limits when viewing the processing buffer. The min and max parameters set the lower
and upper bounds of the display. The value of max must be greater than the value of min. If either min or max is omitted
RNMR will prompt for it with the current window limit.</p>
<p>The window limits are set separately for data in different domains. /FREQ, /TIME, and /UNKN select which domain to set
the limits for.</p>
<h3 id="wndlima">WNDLIMA</h3>
<p>Set acquisition view vertical window limits</p>
<p>Category: Display Control</p>
<p>Format: <code>WNDLIMA</code> min max</p>
<p>Defaults: current current</p>
<p>Description:
<code>WNDLIMA</code> sets the vertical window limits when viewing the acquisition buffer. The min and max parameters set the lower
and upper bounds of the display. The value of max must be greater than the value of min. If either min or max is omitted
RNMR will prompt for it with the current window limit.</p>
<h3 id="wpk">WPK</h3>
<p>Write peaks in current display to <code>WRT</code> file</p>
<p>Category: File IO</p>
<p>Format: <code>WPK</code></p>
<p>Description:
<code>WPK</code> writes a list of peaks in the current display to a file opened with <code>WRT</code>. The peaks will be written in order from
left to right in the display. For each peak a line will be written with four values (peak number, position in current
frequency units, position in default frequency units, intensity). A maximum of 50 peaks will be written to the file. A
point is considered a peak if its magnitude is greater than the peak picking threshold (as set and displayed by <code>TH</code>)
and it is either a local maximum or minimum if its intensity is greater or less than zero respectively.</p>
<h3 id="wpk2d">WPK2D</h3>
<p>Write 2D peaks to <code>WRT</code> file</p>
<p>Category: File IO</p>
<p>Format: <code>WPK2D</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Description:
<code>WPK2D</code> writes a list within a two-dimensional slice of a <a href="../syntax/#blocked_records">blocked record</a> and within the
current display limits to a file opened with <code>WRT</code>. For each peak a line will be written to the file containing the peak
number, the position in each dimension in the current and default frequency units and the peak intensity. A maximum of
250 peaks will be written to the file.</p>
<p>If no <a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will print peaks from the first 2D slice of the record.</p>
<p>A point is considered a peak if its magnitude is greater than the peak picking threshold (as set and displayed by <code>TH</code>)
and it is either a local maximum or minimum if its intensity is greater or less than zero respectively. By setting
<code>CONMD</code> to POS, NEG, or ABS beforehand, the user may modify the selection of 2D peaks for a given threshold value.</p>
<h3 id="wppsb">WPPSB</h3>
<p>Write data byte to pulse programmer spectrometer bus</p>
<p>Category: Hardware</p>
<p>Format: <code>WPPSB</code> adr data</p>
<p>Defaults: 0 0</p>
<p>Prerequisites: Pulse programmer spectrometer bus control implemented (CGFSB2); RNMRA only</p>
<p>Description:
<code>WPPSB</code> writes a data byte from the pulse programmer spectrometer bus. The adr parameter specifies the address to write
the byte to and may range from 0 to 255 inclusive. The data parameter specifies what value to write to the bus and may
range from 0 to 255 inclusive. If adr or data is omitted RNMR will prompt for it with a default of 0.</p>
<h3 id="wrf">WRF</h3>
<p>Set waveform reference values</p>
<p>Category: Waveform</p>
<p>Format: <code>WRF</code> chan ind val1 val2</p>
<p>Defaults: 1 1 current current</p>
<p>Prerequisites: Waveform generator implemented; Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>WRF</code> sets a wave form generator reference values. The chan and ind parameters are used to set which value on which
channel to adjust. If either chan or ind are omitted RNMR will prompt for them with a default of 1. The parameters val1
and val2 are the reference values. If either val1 or val2 are omitted RNMR will prompt for them with the current value
as a default.</p>
<h3 id="wrfex">WRFEX</h3>
<p>Load waveform RF program</p>
<p>Category: Waveform</p>
<p>Format: <code>WRFEX</code></p>
<p>Defaults:</p>
<p>Prerequisites: Waveform generator implemented and HALT</p>
<h3 id="wrkc">WRKC</h3>
<p>Write data byte to RKC device</p>
<p>Category: Hardware</p>
<p>Format: <code>WRKC</code> dev data</p>
<p>Defaults: none</p>
<p>Prerequisites: RKC device implemented; RNMRA only</p>
<p>Description:
<code>WRKC</code> writes data from a RKC device. If no device or data is specified RNMR will prompt for it with no default.</p>
<h3 id="wrri">WRRI</h3>
<p>Write command line to RRI device and read response</p>
<p>Category: Hardware</p>
<p>Format: <code>WRRI</code> cmd</p>
<p>Defaults: none</p>
<p>Prerequisites: RRI device implemented; RNMRA only</p>
<p>Description:
<code>WRRI</code> writes data from a RRI device. If no command is specified RNMR will prompt for it with no default. The response
will be printed as an informational message.</p>
<h3 id="wrt">WRT</h3>
<p>Write line to file opened by <code>OPNWRT</code></p>
<p>Category: File IO</p>
<p>Format: <code>WRT</code> arg...</p>
<p>Defaults: none</p>
<p>Description:
<code>WRT</code> writes a line to a file opened by <code>OPNWRT</code>. When multiple arguments are passed to <code>WRT</code> they are all written to
the same line. Arguments are padded with spaces in multiples of 8. This means that for example if the first argument has
7 or less characters the second argument will start at the 9th character in the line. If it had 8-15 characters the
second argument would start at the 17th character and so on. The total length of the line cannot exceed 80 characters,
so <code>WRT</code> can accept a maximum of 10 arguments when each argument is less than 8 characters long. If no arguments are
provided RNMR will prompt for a single value to write.</p>
<h3 id="wrtlst">WRTLST</h3>
<p>Write list to file</p>
<p>Category: Lists</p>
<p>Format: <code>WRTLST</code> nam fspec</p>
<p>Defaults: temp <nam></p>
<p>Description:
<code>WRTLST</code> writes the contents of a list to a file. The values can be reloaded into a list using <code>RDLST</code>. If no list name
is specified RNMR will prompt for it with a default of temp. If no file is specified RNMR will prompt for it with the
list name as a default. If the file name has no extension RNMR will add .wrt to it.</p>
<h3 id="wrttbl">WRTTBL</h3>
<p>Write name table to file</p>
<p>Category: Tables</p>
<p>Format: <code>WRTTBL</code> nam fspec</p>
<p>Defaults: temp <nam></p>
<p>Description:
<code>WRTTBL</code> writes the contents of a name table to a file. The values can be reloaded into a name table using <code>RDTBL</code>. If
no table name is specified RNMR will prompt for it with a default of temp. If no file is specified RNMR will prompt for
it with the table name as a default. If the file name has no extension RNMR will add .wrt to it.</p>
<h3 id="wsb">WSB</h3>
<p>Write data byte to spectrometer bus</p>
<p>Category: Hardware</p>
<p>Format: <code>WSB</code> adr data</p>
<p>Defaults: 0 0</p>
<p>Prerequisites: Spectrometer bus control implemented (CGFSB1); RNMRA only</p>
<p>Description:
<code>WSB</code> writes a data byte to the spectrometer bus. The adr parameter specifies the address to write the byte to and may
range from 0 to 255 inclusive. The data parameter specifies what value to write to the bus and may range from 0 to 255
inclusive. If adr or data is omitted RNMR will prompt for it with a default of 0.</p>
<h3 id="wtrm">WTRM</h3>
<p>Write command line to terminal and read response</p>
<p>Category: Hardware</p>
<p>Format: <code>WTRM</code> ind cmd</p>
<p>Defaults: 1 none</p>
<p>Prerequisites: RNMRA only</p>
<p>Description:
<code>WTRM</code> writes a command to a terminal and reads a response. The terminal is specified by its index. If no index is
specified RNMR will prompt for it with a default of 1. If no command is provided RNMR will prompt for it with no
default. The response read form the terminal will be printed as an informational message.</p>
<h3 id="wtset">WTSET</h3>
<p>Wait for heater to stabilize at setpoint</p>
<p>Category: Heater</p>
<p>Format: <code>WTSET</code></p>
<p>Prerequisites: RNMR heater control; RNMRA only</p>
<p>Description:
<code>WTSET</code> waits for the heater temperature to reach its set point. Press Q while <code>WTSET</code> is active to quit waiting.</p>
<h3 id="wttim">WTTIM</h3>
<p>Wait for specified number of seconds</p>
<p>Category: Misc.</p>
<p>Format: <code>WTTIM</code> dlytime</p>
<p>Defaults: 1.0</p>
<p>Description:
<code>WTTIM</code> waits an amount of time specified by dlytime. The time is specified in seconds and must be a positive number. If
no time is specified RNMR will prompt for it with a default of 1.0. Press Q while <code>WTTIM</code> is active to quit waiting.</p>
<h3 id="wwash">WWASH</h3>
<p>Set state of plot whitewash flag</p>
<p>Category: Plotting</p>
<p>Format: <code>WWASH</code> state</p>
<p>Defaults: current</p>
<p>Description:
<code>WWASH</code> sets the state of the white wash flag for stack plotting. The flag may be either on or off. If no state is
specified RNMR will prompt for it with the current state of the flag as a default. When stack plots are created with
<code>STK</code> subsequent plots are considered to be behind previous plots. If the whitewash flag is on the portions of the line
that are behind peaks in the previous plots are not drawn. If the whitewash flag is off the whole plot is drawn for each
stacked plot.</p>
<h3 id="wwf">WWF</h3>
<p>Set waveform values</p>
<p>Category: Waveform</p>
<p>Format: <code>WWF</code> chan ind val1 val2</p>
<p>Defaults: 1 1 current current</p>
<p>Prerequisites: Waveform generator implemented; Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>WWF</code> sets wave form generator values. The chan and ind parameters are used to set which value on which channel to
adjust. If either chan or ind are omitted RNMR will prompt for them with a default of 1. The parameters val1 and val2
are the waveform values. If either val1 or val2 are omitted RNMR will prompt for them with the current value as a
default.</p>
<h3 id="wwfex">WWFEX</h3>
<p>Load waveform program</p>
<p>Category: Waveform</p>
<p>Format: <code>WWFEX</code></p>
<p>Defaults:</p>
<p>Prerequisites: Waveform generator implemented and HALT</p>
<h2 id="x">X</h2>
<hr />
<h3 id="xt">XT</h3>
<p>Extract data within specified limits</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>XT</code> llim rlim</p>
<p>Defaults: current_display_limits</p>
<p>Description:
<code>XT</code> extracts the data in the visible processing buffer that lies between llim and rlim. The limits are specified in the
current units of the buffer. If either limit is omitted RNMR not prompt for it and will use the corresponding current
display limit. All of the data outside of the specified limits will be discarded. The size of the visible processing
buffer will shrink to match the size of the extracted data points.</p>
<h3 id="xtp">XTP</h3>
<p>Extract data for points</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>XTP</code> llim npt</p>
<p>Defaults: current_display_limit 1</p>
<p>Description:
<code>XTP</code> extracts a specified number of data points in the visible processing buffer starting from llim. The left limit is
specified in the current units of the buffer. If the left limit is omitted RNMR will not prompt for it and will use the
current left display limit. If the number of points to extract is not specified RNMR will not prompt for it and will
extract a single point. All of the data outside of the specified points will be discarded. The size of the visible
processing buffer will shrink to match the size of the extracted data points.</p>
<h3 id="xval">XVAL</h3>
<p>Convert from point index to unit value</p>
<p>Category: Data Analysis</p>
<p>Format: <code>XVAL</code> ind</p>
<p>Default: current_cursor_position</p>
<p>Description:
<code>XVAL</code> converts a point index into a position in the current units of the visible processing buffer. If no point index
is specified RNMR will prompt for it with the current cursor position as a default. If the specified point is outside of
the actual data in the visible processing buffer <code>XVAL</code> will return the position of the closest point (the leftmost or
rightmost point). The converted value is printed as an informational message.</p>
<h2 id="z">Z</h2>
<hr />
<h3 id="zer">ZER</h3>
<p>Zero visible processing buffer</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>ZER</code></p>
<p>Description:
<code>ZERA</code> sets the data in the visible processing buffer to 0 and initializes the buffer parameters.</p>
<h3 id="zera">ZERA</h3>
<p>Zero acquisition buffer and shot counter</p>
<p>Category: Acquisition</p>
<p>Format: <code>ZERA</code></p>
<p>Prerequisites: Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>ZERA</code> sets the data in the acquisition buffer and the shot counter to 0 and initializes the acquisition buffer
parameters.</p>
<h3 id="zf">ZF</h3>
<p>Zero fill visible processing buffer</p>
<p>Category: Data Manipulation</p>
<p>Format: <code>ZF</code> size</p>
<p>Defaults: current</p>
<p>Description:
<code>ZF</code> zero fills the data in the visible processing buffer to a new size. The size must be greater than or equal to the
current number of data points in the buffer and must be a power of 2. The buffer will be extended to the new size and
all of the points beyond the original data are set to zero. If size is omitted RNMR will prompt for it with the smallest
power of 2 that is greater than the current data size. The current maximum size for a processing buffer is 32768, so
size may not exceed this value.</p>
<h3 id="zg">ZG</h3>
<p>Start acquisition</p>
<p>Category: Acquisition</p>
<p>Format: <code>ZG</code> first_group last_group</p>
<p>Defaults: 1 0</p>
<p>Prerequisites: Experiment loaded (LOAD); Acquisition stopped (HALT); RNMRA only</p>
<p>Description:
<code>ZG</code> zeroes the averager and shot counter then <a href="../syntax/#acquisition">starts acquisition</a> without dummy scans. The
arguments first_group and last_group specify the range of <a href="../syntax/#acqgrp">acquisition groups</a> to acquire. If either
parameter is omitted RNMR will not prompt for it and will use 1 and 0 as defaults respectively. If last_group is set to
0 then only first_group will be acquired.</p>
<h3 id="zo">ZO</h3>
<p>Zoom</p>
<p>Category: Display Control</p>
<p>Format: <code>ZO</code></p>
<p>Prerequisites: Processing buffer visible (VIEW PRO)</p>
<p>Description:
<code>ZO</code> enters the zoom subroutine. While <code>ZO</code> is active the currently selected cursor may be moved by clicking and
dragging on the display. The following subcommands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BI</td>
<td>View imaginary part of buffer</td>
</tr>
<tr>
<td>BR</td>
<td>View real part of buffer</td>
</tr>
<tr>
<td>E</td>
<td>Expand display between cursors</td>
</tr>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>F</td>
<td>Contract to display full buffer</td>
</tr>
<tr>
<td>L</td>
<td>Select left movement</td>
</tr>
<tr>
<td>M1</td>
<td>Select 1 cursor display</td>
</tr>
<tr>
<td>M2</td>
<td>Select 2 cursor display</td>
</tr>
<tr>
<td>O</td>
<td>Enter offset value after prompt</td>
</tr>
<tr>
<td>P</td>
<td>Move to next peak</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>R</td>
<td>Select right movement</td>
</tr>
<tr>
<td>S</td>
<td>Switch cursors</td>
</tr>
<tr>
<td>T</td>
<td>Enter threshold value after prompt</td>
</tr>
<tr>
<td>V</td>
<td>Enter cursor position after prompt</td>
</tr>
<tr>
<td>W</td>
<td>Write point values to file opened with <code>OPNWRT</code> (number, position in current units, position in default units, intensity)</td>
</tr>
<tr>
<td>0-3</td>
<td>Move cursor by 10^N points</td>
</tr>
</tbody>
</table>
<h3 id="zo2d">ZO2D</h3>
<p>Zoom on 2D data set</p>
<p>Category: Display Control</p>
<p>Format: <code>ZO2D</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Prerequisites: Processing buffer visible (VIEW PRO)</p>
<p>Description:
<code>ZO2D</code> performs two-dimensional zooming on a slice of a <a href="../syntax/#blocked_records">blocked record</a>. If no
<a href="../syntax/#records">record number</a> is specified RNMR will prompt for it with the current read record pointer (as
displayed and set by <code>PTRA</code>) as a default. If no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and
will display the first 2D slice of the record.</p>
<p><code>ZO2D</code> will display a single one-dimensional slice along one of the first two directions at a time. Various subcommands
allow for manipulation of which slice along which direction is displayed. Whenever the visible direction is switched the
slice to display will be determined by the position of the cursor. The following subcommands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>D1</td>
<td>View direction 1</td>
</tr>
<tr>
<td>D2</td>
<td>View direction 2</td>
</tr>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>F</td>
<td>Select forward movement</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>R</td>
<td>Select reverse movement</td>
</tr>
<tr>
<td>S</td>
<td>Switch viewed direction</td>
</tr>
<tr>
<td>V</td>
<td>Select position in unviewed direction in its units after prompt</td>
</tr>
<tr>
<td>Z</td>
<td>Call <code>ZO</code> to manipulate 1D display and cursor</td>
</tr>
<tr>
<td>0:3</td>
<td>Move in unviewed direction by 10^N slices</td>
</tr>
</tbody>
</table>
<h3 id="zo2dc">ZO2DC</h3>
<p>Zoom on 2D contour display</p>
<p>Category: Contours</p>
<p>Format: <code>ZO2DC</code> rec slice</p>
<p>Defaults: rrec 1</p>
<p>Prerequisites: Processing buffer visible (VIEW PRO)</p>
<p>Description:
<code>ZO2DC</code> displays a contour plot of a two-dimensional slice of a <a href="../syntax/#blocked_records">blocked record</a> and provides
subcommands to manipulate the contour display.  The number of contours is set by <code>NCON</code>, the contour height limits by
<code>CONLIM</code>, the type of contours by <code>CONMD</code>, and the plot limits by <code>LIMB</code>. If no <a href="../syntax/#records">record number</a> is
specified RNMR will prompt for it with the current read record pointer (as displayed and set by <code>PTRA</code>) as a default. If
no <a href="../syntax/#slice">slice</a> is specified RNMR will not prompt for it and will plot the first 2D slice of the record.</p>
<p>The following subcommands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BI</td>
<td>View imaginary part of data</td>
</tr>
<tr>
<td>BR</td>
<td>View real part of data</td>
</tr>
<tr>
<td>D</td>
<td>Select down movement</td>
</tr>
<tr>
<td>E</td>
<td>Expand display between cursors</td>
</tr>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>F</td>
<td>Contract to display full contour plot</td>
</tr>
<tr>
<td>IB</td>
<td>Integrate box centered on cursor (box size set by <code>IBOX</code>)</td>
</tr>
<tr>
<td>IR</td>
<td>Integrate region between cursors</td>
</tr>
<tr>
<td>L</td>
<td>Select left movement</td>
</tr>
<tr>
<td>M1</td>
<td>Select 1 cursor display</td>
</tr>
<tr>
<td>M2</td>
<td>Select 2 cursor display</td>
</tr>
<tr>
<td>P</td>
<td>Move to next peak</td>
</tr>
<tr>
<td>O</td>
<td>Enter offset value after prompt</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>R</td>
<td>Select right movement</td>
</tr>
<tr>
<td>S</td>
<td>Switch cursors</td>
</tr>
<tr>
<td>T</td>
<td>Enter threshold value after prompt</td>
</tr>
<tr>
<td>U</td>
<td>Select up movement</td>
</tr>
<tr>
<td>V</td>
<td>Enter cursor position after prompt</td>
</tr>
<tr>
<td>W</td>
<td>Write point values to file opened with <code>OPNWRT</code> (number, position1 in current units, position1 in default units, position2 in current units, position2 in default units, intensity)</td>
</tr>
<tr>
<td>0-3</td>
<td>Move 10^N points</td>
</tr>
</tbody>
</table>
<h3 id="zoa">ZOA</h3>
<p>Zoom on acquisition display</p>
<p>Category: Acquisition</p>
<p>Format: <code>ZOA</code></p>
<p>Prerequisites: Acquisition buffer visible (VIEW ACQ)</p>
<p>Description:
<code>ZOA</code> enters the zoom subroutine for the acquisition buffer. While <code>ZOA</code> is active the currently selected cursor may be
moved by clicking and dragging on the display. The following subcommands are available:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BI</td>
<td>View imaginary part of buffer</td>
</tr>
<tr>
<td>BR</td>
<td>View real part of buffer</td>
</tr>
<tr>
<td>E</td>
<td>Expand display between cursors</td>
</tr>
<tr>
<td>Enter</td>
<td>Terminate</td>
</tr>
<tr>
<td>F</td>
<td>Contract to display full buffer</td>
</tr>
<tr>
<td>L</td>
<td>Select left movement</td>
</tr>
<tr>
<td>Q</td>
<td>Terminate</td>
</tr>
<tr>
<td>R</td>
<td>Select right movement</td>
</tr>
<tr>
<td>S</td>
<td>Switch cursors</td>
</tr>
<tr>
<td>V</td>
<td>Enter cursor position after prompt</td>
</tr>
<tr>
<td>0:3</td>
<td>Move cursor by 10^N points</td>
</tr>
</tbody>
</table>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../command_summary/" class="btn btn-neutral" title="Command Summary"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/bcmichael/RNMR-Docs/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../command_summary/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
