# Macros
## Introduction
In RNMR, macros are user-defined procedures which consist of sequences of RNMR commands and (optionally) branching
instructions to control the flow of command execution. Simple macros may be nothing more than a collection of commands
to be executed sequentially as a unit, while more complex macros may perform calculations and manipulate acquisition and
processing functions via local and global arguments.

The creation and modification of macros may be handled entirely from within RNMR, using the Macro Edit and Define
utilities, however they can also be manipulated outside of RNMR using a text editor. After a macro some_macro.rnmrm has
been altered outside of RNMR you must type `MACRO SOME_MACRO` in order for the changes to show up inside RNMR.

A number of commands and control flow constructs will be briefly described here and some examples of their use will be
provided. More thorough documentation of these commands as well as many others can be found in the Full Command
Descriptions section.

## Global Arguments
An RNMR macro may utilize two kinds of variables. Global arguments are variables which, once defined, are accessible to
all command levels in RNMR, including the console level. If a global argument is defined in a macro, it is still defined
and accessible after the macro exits unless a `GBLDL` command is issued to delete the argument from the global table.

Global arguments are indicated in macro code by the percent operator `%` followed by the name of the argument. They may
be defined using the `GBLARG` command or by the global pop operator `>` following any RNMR command which prompts the
user for numerical or character values. In addition, a global argument may be used to store a value contained in an RNMR
informational message using a `SET INFO` block. Finally, a global argument may be generated by the `DO` command to store
an iteration counter for a macro `DO` loop. Global argument names may not exceed sixteen characters and may only include
the characters A-Z, 0-9, $, or \_. These global argument definitions are illustrated in the examples below:
```no-highlight
GBLARG TEMP 3      ;defines global argument TEMP ;and gives it the value 3
GBLARG TEMP        ;defines TEMP and prompts user for value

LB >FWHM           ;pops the current line broadening value supplied by LB into
                   ;the global argument FWHM

SET INFO GBL TEMP  ;places the RMS value (supplied as an informational message
 RMS               ;by the RMS command) in global argument TEMP

DO /GBL 1,10 ITER  ;creates global ITER, which stores the current loop
    ;ITERATION NUMBER %ITER value (from 1 to 10)
ENDDO
```

## Local Arguments
Local arguments are similar to global arguments, but are available only within the command level in which they were
defined. Thus, local arguments which were defined in a macro will be automatically deleted and thus unavailable once the
macro exits to console level. Similarly, local arguments defined at console level are not available to macros unless
they are explicitly passed as macro arguments (see "Passing arguments"). A local argument is represented in macro code
by the ampersand operator `&` followed by the name of the argument. A local argument may be defined in the same ways as
global arguments by using `LCL` in place of `GBL` and `>>` in place of `>`.  Additionally the `DFLT` command can be used
to prompt for values while providing a default. Local argument names may not exceed sixteen characters and may only
include the characters A-Z, 0-9, $, or \_. Examples of local argument definitions and assignments are shown below:
```no-highlight
LCLARG TEMP 3      ;defines local argument TEMP and gives it the value 3
LCLARG TEMP        ;defines local argument TEMP and prompts user for value

LB >>FWHM          ;pops the current line broadening value supplied by LB into
                   ;the local argument FWHM  

SET INFO LCL TEMP  ;places the RMS value (supplied as an informational message
 RMS               ;by the RMS command) in local argument TEMP

DO /LCL 1,10 ITER  ;creates local ITER, which stores the current loop
    ;ITERATION NUMBER &ITER value (from 1 to 10)
ENDDO

DFLT TEMP,1,VAL    ;if local TEMP is not defined sets the default value for TEMP
                   ;to 1 and prompts user for a value with "VAL" prompt
```

## Macro Labels
Much of the control flow in RNMR macros makes use of labels. A macro label is defined by a period followed by the label
name. When RNMR is searching for a label to jump to it will first search forward in the macro from the jump point and
then wrap around and continue searching from the beginning of the macro.

When jumping to a label a period not followed by a name will cause RNMR to simply continue execution on the next line.
Appending +# to a label will cause RNMR to start execution # lines farther down that it would otherwise. A label
including the period and line offset cannot be more than 16 characters long.

## Control Flow
The most basic control flow in RNMR macros is the `GOTO` command, which will simply jump to a label and continue
execution from there. The `GOSUB` command is similar to `GOTO` in that it jumps to a label but when the macro hits an
`MEXIT` it will return to where `GOSUB` was called from instead of exiting the macro. This is useful for creating
subroutines within macros.

Blocks of commands can be executed conditionally using the `TST` construct. `TST` checks some condition and then
executes one of two blocks of commands depending on the result. The two blocks are separated with `ELSTST` and the whole
construct ends with `ENDTST`. `ELSTST` is optional and if it is not present then nothing will be executed if the test is
false. `TST` can perform a range of different tests, such as checking equality of values or checking the existence of
arguments. For full details see the description of `TST` in the Full Command Descriptions section. For example:
```no-highlight
TST EQ &A &B
  ;Commands here execute if local args a and b are the same
ELSTST
  ;Commands here execute if local args a and b are not the same
ENDTST
```
`GOTST` performs the same type of tests as `TST`, but instead of executing one of two blocks of commands it jumps to one
of two labels.
### Loops
While you can use conditional commands and labels to construct a looping type behavior RNMR also has a `DO` loop
construct built in. A `DO` loop will execute until it reaches an `ENDDO` statement at which point it will increment the
loop value and run it again. This will repeat a number of times determined by the beginning and end values of the loop.
You may optionally specify a variable that holds the loop counter.  For example:
```no-highlight
LCLARG LOOPTO 10
DO /LCL 1 &LOOPTO COUNT
  ;Local argument COUNT will hold the loop value which will range from 1 to 10
  ;Lines entered here will in this case execute 10 times
ENDDO
```
You can also set a label to jump to in the event that an error is encountered during the execution of commands within
the macro using the `ONERR` command.

## Macro Output
There are several ways in which an RNMR macro may output data to the user. First, data resulting from a calculation,
experiment, or other manipulation may simply be stored in a global argument, which may be used on console level or in
another macro as desired. Second, data from a macro may be printed to the screen using the `MSG` command, as shown below:
```no-highlight
LCLARG ABC 9
MSG "VALUE OF ABC IS &ABC"
```
The above code will print the following message to the console:
```no-highlight
VALUE OF ABC IS 9
```
Finally, the user may write data generated by a macro to a disk file using the WRT commands, as shown below:
```no-highlight
OPNWRT XYZ
LCLARG ABC 3
 WRT &ABC
 CLSWRT
```
The above code creates a disk file called XYZ.WRT, writes the value of local argument ABC as one record in that file,
and closes XYZ.WRT. After executing this code, the user should have a file XYZ.WRT containing the text "3", the value of
`&ABC` at the time of the `WRT` command. When writing to files it is a good practice to set up error handling using
`ONERR` to ensure that `CLSWRT` gets called even if errors occur during the writing process.

## Passing Information to and from Macros
Data may be made available to all command levels using global arguments. However, it is also possible to explicitly pass
data from either console level or from a macro to a subprocedure without using global arguments.

To pass values to a macro simply supply the arguments after the macro name on the same line where it is called. Macro
arguments are automatically stored in local arguments `1`, `2`, `3` etc. based on the order they are provided in. It is
also possible to change the names of the arguments they are stored in using the `MACARG` command.

It is also possible to return values from a macro to the calling routine. Supply the return values after `MEXIT` on the
same line and they will be stored as local arguments `RTN$1`, `RTN$2`, `RTN$3` etc. in the calling procedure. The
calling procedure can use the `RTNARG` much like the `MACARG` command to put these return values into differently named
arguments.

Both `MACARG` and `RTNARG` will only create as many local arguments as the number of values that were passed.  No local
arguments will be created for any additional names which are supplied. For example, if the macro temp contains the
following:
```no-highlight
MACARG A B
MSG "ARGUMENT ONE IS &A"
MSG "ARGUMENT TWO IS &B"
LCLARG C 3
MEXIT &C 4
```
then calling the following:
```no-highlight
TEMP 1 2
 RTNARG ANSWER1 ANSWER2
MSG "THE RETURN VALUES ARE &ANSWER1 AND &ANSWER2"
```
will print the following to the console:
```no-highlight
ARGUMENT ONE IS 1
ARGUMENT TWO IS 2
THE RETURN VALUES ARE 3 AND 4
```
There is an additional method of passing information into a macro using a / in a calling procedure to specify a name of
a local argument to create in the called macro. You can also specify the values of these arguments. For example, if the
macro temp contains the following:
```no-highlight
TST LCL A
  MSG "A EXISTS AND HAS VALUE &A"
  MSG "B HAS VALUE &B"
  MEXIT
ELSTST
  MSG "A DOES NOT EXIST"
ENDTST
MEXIT
```
then calling the following:
```no-highlight
TEMP /A /B=2
```
will print the following to the console:
```no-highlight
A EXISTS AND HAS VALUE
B HAS VALUE 2
```
Note that `A` does not have a value so it shows up as blank in the printed message.

These two methods of passing arguments into macros are somewhat analogous to the positional and keyword argument
constructs in some other programing languages. You may use a mixture of both methods to pass information into a macro.

The local arguments `KEY$MAX` and `POS$MAX` will automatically be created when a macro is called and will contain the
number of each of these types of arguments that were passed to the macro. The local argument `MACRO$` will also be
created and will hold the name of the macro.
